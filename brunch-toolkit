#!/bin/bash
readonly toolkitversion="v3.0.2"
readonly discordinvite="https://discord.gg/x2EgK2M"

#<~> Brunch Config Variables (Kernels, Framework options, etc)
# All currently known framework options. Update this list as necessary (any order)
readonly fwo_page1=(
"acpi_power_button"
"advanced_als"
"alt_touchpad_config"
"alt_touchpad_config2"
"android_init_fix"
"asus_c302"
"baytrail_chromebook"
"disable_intel_hda"
"enable_updates"
"force_tablet_mode"
"More Options"
)

readonly fwo_page2=(
"goodix"
"internal_mic_fix"
"invert_camera_order"
"ipts"
"mount_internal_drives"
"no_camera_config"
"oled_display"
"pwa"
"suspend_s3"
"sysfs_tablet_mode"
"rtbth"
"Wifi Options"
)

readonly fwo_wifi=(
"broadcom_wl"
"iwlwifi_backport"
"rtl8188eu"
"rtl8188fu"
"rtl8192eu"
"rtl8723bu"
"rtl8723de"
"rtl8723du"
"rtl8812au"
"rtl8814au"
"rtl8821ce"
"rtl8821cu"
"rtl88x2bu"
"Other Options"
)

# All currently known descriptions. Mind string length
readonly fwo_page1_subs=(
"Patches support for the power button menu on some hardware"
"Patches in more auto-brightness levels on supported hardware"
"Useful for debugging touchpad issues"
"Useful for debugging touchpad issues"
"Patch the android config on ChromeOS 91 and higher"
"Hardware specific patches for the Asus c302"
"Hardware specific patches for Baytrail Chromebooks"
"Blacklists the snd_hda_intel module"
"Enable updating natively from the settings menu"
"Allows control of tablet mode from sysfs"
"Display More Options"
)

readonly fwo_page2_subs=(
"Patches to support Goodix touchscreens"
"Forcefull enable the microphone on some hardware"
"Swap default camera order"
"Enable support for some Surface touchscreens"
"Automatically mount internal drive partitions on login"
"Disables the camera config"
"Patch for OLED displays (use with Kernel 5.10)"
"Enable support for the Brunch PWA"
"Disable suspend to idle (S0ix) and use S3 suspend instead"
"Allows control of tablet mode from sysfs"
"Patches for RT3290/RT3298LE bluetooth devices"
"Display Wifi Options"
)

readonly fwo_wifi_subs=(
"Patch in support for some Broadcom wifi cards"
"Patch in support for some Intel wifi cards"
"Patch in support for rtl8188eu wifi cards"
"Patch in support for rtl8188fu wifi cards"
"Patch in support for rtl8192eu wifi cards"
"Patch in support for rtl8723bu wifi cards"
"Patch in support for rtl8723de wifi cards"
"Patch in support for rtl8723du wifi cards"
"Patch in support for rtl8812au wifi cards"
"Patch in support for rtl8814au wifi cards"
"Patch in support for rtl8821ce wifi cards"
"Patch in support for rtl8821cu wifi cards"
"Patch in support for rtl88x2bu wifi cards"
"Display Other Options"
)

# Currently avaliable kernels
readonly avaliablekernels=(kernel-4.19 kernel-5.4 kernel-5.10 kernel-chromebook)

#</>

#<~> Brunch Toolkit intro
#
# Welcome to the brunch toolkit. I've tried my best to make this code legible,
# send any bug reports to Wisteria on the brunch discord. https://discord.gg/x2EgK2M
#
# This is a near-complete rewrite of my original toolkit. Expect bugs
#
#</>

#<~> Bento boxes - Brunch's ENhanced Text Options
#
# This is the code that makes boxes possible,
# When 'bento_boxes=disabled' then the script will not draw boxes.
#
bento_version="1.0.9"
bento_usage(){

# Set variables to use in the menu
  bento_help_menu_title=("Bento $bento_version - Help Menu")
  bento_help_menu_contents=("Welcome to Bento." "Brunch's ENhanced Text Options")
  bento_help_menu_options=("Usage" "Examples" "Support" "Exit")
  bento_help_menu_tooltips=("How to use Bento" "How this menu was made" "Where to get support" "Exit")

# Use bento to generate a textbox and menu from the above variables
  bento -g -t "$bento_help_menu_title" -c "${bento_help_menu_contents[@]}" -m "${bento_help_menu_options[@]}" -s "${bento_help_menu_tooltips[@]}"

# Set a return point using function names, then parse selection.
  previous_menu="bento_usage"
  case "$selection" in
    "Usage") bento_usage_sub1 ; return ;;
    "Examples") bento_usage_sub2 ; return ;;
    "Support") bento_usage_sub3 ; return ;;
    "Exit") exit 0 ;;
  esac
 }

bento_usage_sub3(){
    clear
# make a textbox with a link to discord and some minor info about this script
    bento -t "Bento - Further Support" -c "This whole project was made by a beginner, and has been modified greatly over time as they learned more." "If you'd like to know anything specific, you can find Wisteria in the Brunch discord group." " " "https://discord.gg/x2EgK2M" -r
}

bento_usage_sub2(){
    clear
# make a textbox to describe the content of this page
    bento -t "Bento - Examples" -c "Here is how the previous menu was made:"

# output the main help menu's code as an example
echo 'bento_usage(){

# Set variables to use in the menu
  bento_help_menu_title=("Bento - Help Menu")
  bento_help_menu_contents=("Welcome to Bento." "Brunchs ENhanced Text Options")
  bento_help_menu_options=("Usage" "Examples" "Support" "Exit")
  bento_help_menu_tooltips=("How to use Bento" "How this menu was made" "Where to get support" "Exit")

# Use bento to generate a textbox and menu from the above variables
  bento -g -t "$bento_help_menu_title" -c "${bento_help_menu_contents[@]}" -m "${bento_help_menu_options[@]}" -s "${bento_help_menu_tooltips[@]}"

# Set a return point using function names, then parse selection.
  previous_menu="bento_usage"
  case "$selection" in
    "Usage") bento_usage_sub1 ; return ;;
    "Examples") bento_usage_sub2 ; return ;;
    "Support") bento_usage_sub3 ; return ;;
    "Exit") exit 0 ;;
  esac
 }'

# make another textbox with the -n (noclear) flag to have multiple textboxes on screen
    bento -c "As you can see, the main command is bento with a handful of flags and arrays afterwards. Then we use something like case to parse the selection made in the menu, and send users off to their destinations." -r -n
}

bento_usage_sub1(){
    clear
# One very large formatted array. It's split by line between elements to more easily align content
    bento_usage_contents=(
    "Basic Usage - Flags accepting options"
    ""
    "These flags are all meant to be used with options afterwards to generate content."
    'Options can be strings, $variables or ${arrays[@]}. The format is: -flag $option'
    ""
    "(-c|--content)     The following options will make up the textbox. (like this one!) "
    "(-m|--menu)        The options listed here will become selectable options for the user."
    "(-mm|--multimenu)  The options here can be toggled and multiselected together"
    "(-s|--subtitles)   These options act as on screen tooltips for the menu options."
    "(-t|--title)       This will define the titlebar displayed at the top of the box."
    "div"
    "Advanced Usage - Special flags"
    ""
    "The following flags do not accept options, and can be used to modify your boxes."
    ""
    "(-b|--boxless)     This option will disable box drawing and just display plain text."
    "(-g|--glyph)       This option turns on doublelined boxes, like what this menu uses."
    "(-n|--noclear)     Prevent Bento clearing the screen before and after making boxes."
    '(-w|--write)       User input is directed into the $selection variable'
    ""
    "(-a|--arrows)      Displays a small usage tip for selecting items in the menu. "
    "(-e|--exit)        Displays a small usage tip for exiting the script."
    '(-r|--return)      Displays a small usage tip for returning to the $previous_menu.'
    "(-x|--toggle)      Displays a small useage tip for toggling options on or off."
    "                   (This also will switch menu selection to toggle mode.)"
    "div"
    "Other useful features"
    ""
    "Array elements matching 'div' or ' ' (empty) will create dividers and spaces."
    "Array elements matching 'lid' or 'btm' will create seperate box tops and bottoms."
    "Textboxes will attempt to size themselves according to the user's terminal."
    "If a user's screen is too small, bento will not draw boxes to keep things simple."
    "If content does not fit on one line in a textbox, it will attempt to wordwrap."
    "div"
    "Alignment"
    ""
    "Elements can be aligned with a wide degree of customization."
    ""
    "(-ra|--rightaligned) (-la|--leftaligned)                   Align all text"
    "(-tra|--titlerightaligned) (-tla|--titleleftaligned)       Align title text"
    "(-cra|--contentrightaligned) (-cla|--contentrightaligned)  Align content text"
    "(-sra|--subrightaligned) (-sla|--subleftaligned)           Align tooltip text"
    "(-mra|--menurightaligned) (-mca|--menucenteraligned)       Align menu text"
    "(note that menu text defaults to be left aligned, all other text is centered)"
    )

# Make a simple box based on the above array.
    bento -t "Bento - Usage" -cla -c "${bento_usage_contents[@]}" -r
}

#<~> Bento funtions
bento(){
    if [[ -z "$*" ]] ; then
        bento_usage
    fi
    # preset variable defaults to keep menus from acidentally merging into eachother
    terminal_width=$(tput cols)             # query the Terminfo database: number of columns
    terminal_height=$(tput lines)             # query the Terminfo database: number of columns
    box_width=$(( terminal_width - 8 ))     # set the width of the box with a buffer
    if [[ "$bento_boxes" == "disabled" ]] ; then
        boxless="true"
    elif (( terminal_width < 50 )) ; then
        boxless="true"
    elif (( terminal_height < 30 )) ; then
        boxless="true"
    else
      boxless="false"
    fi
    glyph="─"
    noclear="false"
    keys_opt_arrows="Arrow Keys Up/Down (↑/↓)  Press Enter (⏎) to select."
    keys_opt_return="Press Enter (⏎) to return to the previous menu."
    keys_opt_exit="Press Enter (⏎) to continue."
    keys_opt_input="Type your selection, then press Enter (⏎) to continue."
    keys_opt_toggle="Arrow Keys Up/Down (↑/↓)  Press Enter (⏎) to toggle."
    toggle_hint="Options marked with ◯ are disabled, ◆ are enabled.  "
    arrows="false"
    return="false"
    toggle="false"
    rightaligned="false"
    leftaligned="false"
    crightaligned="false"
    cleftaligned="false"
    trightaligned="false"
    tleftaligned="false"
    srightaligned="false"
    sleftaligned="false"
    mrightaligned="false"
    mcenteraligned="false"
    multiselection="false"
    exit="false"
    input="false"
    # parse bento flags here
    PARAMS=""
while (( "$#" )); do
  case "$1" in
    -w|--write)
    # set $selection to a written in input with read
      input="true"
      shift
      ;;
    -ra|--rightaligned)
    # Align all text to the right
      rightaligned="true"
      shift
      ;;
    -la|--leftaligned)
    # Align all text to the left
      leftaligned="true"
      shift
      ;;
    -cra|--contentrightaligned)
    # Align all -c content to the right
      crightaligned="true"
      shift
      ;;
    -cla|--contentleftaligned)
    # Align all -c content to the left
      cleftaligned="true"
      shift
      ;;
    -tra|--titlerightaligned)
    # Align -t title to the right
      trightaligned="true"
      shift
      ;;
    -tla|--titleleftaligned)
    # Align -t title to the left
      tleftaligned="true"
      shift
      ;;
    -sra|--subrightaligned)
    # Align -s subtitle/tooltips to the right
      srightaligned="true"
      shift
      ;;
    -sla|--subleftaligned)
    # Align -s subtitle/tooltips to the right
      sleftaligned="true"
      shift
      ;;
    -mra|--menurightaligned)
    # Align -m menu options to the right
      mrightaligned="true"
      shift
      ;;
    -mca|--menucenteraligned)
    # Align -m menu options to the left
      mcenteraligned="true"
      shift
      ;;
    -b|--boxless)
    # Dont draw boxes (sets all box components to "")
      boxless="true"
      shift
      ;;
    -u|--update)
    # Display bento help menu
      bento_update
      exit 0
      ;;
    -i|--install)
    # Display bento help menu
      bento_install
      exit 0
    ;;
    -h|--help)
    # Display bento help menu
      bento_usage
      exit 0
      ;;
    -d|--debug)
    # Display bento debug menu
      bento_debug
      exit 0
      ;;
    -a|--arrows)
    # displays: "Arrow Keys Up/Down (↑/↓)  Press Enter (⏎) to select." under content
      arrows="true"
      shift
      ;;
    -r|--return)
    # displays: "Press Enter (⏎) to return to the previous menu." under content
    # waits for input then returns to $previous_menu
      return="true"
      shift
      ;;
    -e|--exit)
    # displays: "Press Enter (⏎) to continue." under content
    # waits for input, does not set a $selection and continues to next function
      exit="true"
      shift
      ;;
    -x|--toggle)
    # Work in progress
    # displays: "Arrow Keys Up/Down (↑/↓)  Press Enter (⏎) to toggle." "Options marked with ◯ are disabled, ◆ are enabled." under content
      toggle="true"
      shift
      ;;
    -g|--glyph)
    # Sets textbox borders to doublelined bars
      glyph="true"
      shift
      ;;
    -n|--noclear)
    # does not 'clear' when starting a textbox
      noclear="true"
      shift
      ;;
    -t|--title)
    # displays all options until the next -flag as a title, supports multiple lines
      if [ -n "$2" ] ; then
          # shift to next variable, the -flag is not included
          shift 1
          array=("$@")
          for ((i = 0; i < ${#array[@]}; ++i)); do
          # keep looping for every option to add them to our array
          if [[ "${array[$i]}" == -* ]] ; then
              break # end loop at next flag
          else
              title+=("${array[$i]}")
          fi
          done
      else
        echo "Error: Argument for $1 is missing" >&2
        exit 1
      fi
      ;;
    -c|--content)
    # displays all options until the next -flag as content, supports multiple lines
      if [ -n "$2" ] ; then
          # shift to next variable, the -flag is not included
          shift 1
          array=("$@")
          for ((i = 0; i < ${#array[@]}; ++i)); do
          # keep looping for every option to add them to our array
          if [[ "${array[$i]}" == -* ]] ; then
              break # end loop at next flag
          else
              content+=("${array[$i]}")
          fi
          done
      else
        echo "Error: Argument for $1 is missing" >&2
        exit 1
      fi
      ;;
    -m|--menu)
    # displays all options until the next -flag as menu options, supports multiple lines
      if [ -n "$2" ] ; then
          # shift to next variable, the -flag is not included
          shift 1
          array=("$@")
          for ((i = 0; i < ${#array[@]}; ++i)); do
          # keep looping for every option to add them to our array
          if [[ "${array[$i]}" == -* ]] ; then
              break # end loop at next flag
          else
              menu+=("${array[$i]}")
          fi
          done
      else
        echo "Error: Argument for $1 is missing" >&2
        exit 1
      fi
      ;;
  -mm|--multimenu)
  # displays all options until the next -flag as menu options, supports multiple lines
    if [ -n "$2" ] ; then
        # shift to next variable, the -flag is not included
        shift 1
        array=("$@")
        for ((i = 0; i < ${#array[@]}; ++i)); do
        # keep looping for every option to add them to our array
        if [[ "${array[$i]}" == -* ]] ; then
            break # end loop at next flag
        else
            multimenu+=("${array[$i]}")
        fi
        done
        # to allow for multiple selections, add a confirmation option at the end and set a var
            multimenu+=("Confirm Selection")
            # let the script know we're doing something complicated here
            multiselection="true"
    else
      echo "Error: Argument for $1 is missing" >&2
      exit 1
    fi
    ;;
    -s|--subtitles)
    # displays all options until the next -flag as tooltip text, supports multiple lines
      if [ -n "$2" ] ; then
          # shift to next variable, the -flag is not included
          shift 1
          array=("$@")
          for ((i = 0; i < ${#array[@]}; ++i)); do
          # keep looping for every option to add them to our array
          if [[ "${array[$i]}" == -* ]] ; then
              break # end loop at next flag
          else
              submenu+=("${array[$i]}")
          fi
          done
      else
        echo "Error: Argument for $1 is missing" >&2
        exit 1
      fi
      ;;
    --*=|-*) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
    *) # preserve positional arguments
      PARAMS="$PARAMS $1"
      shift
      ;;
  esac
done
# set positional arguments in their proper place
eval set -- "$PARAMS"

    if [[ "$noclear" == false ]] ; then
    clear
    fi

# generate the title
    if [[ -n "$title" ]] ; then
        # set alignment
        if [[ "$trightaligned" == "true" ]] ; then
            rightaligned="true"
        elif [[ "$tleftaligned" == "true" ]] ; then
            leftaligned="true"
        fi
        # if boxes are disabled, dont bother with formattting
        if [[ "$boxless" == "false" ]] ; then
            echo ""
            # make top of the box
            bento_vars
            printf "${blank_spacer}${top_left_corner}${left_bar}${topbar}${right_bar}${top_right_corner}\n"
        fi
        # loop for each line in the box
        for line in "${title[@]}"; do
            bento_vars
            # if the text is too long, split it into another line
            if (( (text_width + 8) > terminal_width )) ; then
                long_title="$(echo "$line" | fold -w $box_width -s)"
                IFS=$'\n'
                multi_array=($long_title)
                unset IFS
                multititle "${multi_array[@]}"
            else
                printf "${blank_spacer}${title_left_wall}\033[7m${title_left_border}${filler}${line}${filler}${title_right_border}\033[27m${title_right_wall}\n"
            fi
        done
        # if theres no content, make a box bottom instead of a divider
        if [[ -z "$content" ]] && [[ "$boxless" == "false" ]] ; then
            printf "${blank_spacer}${btm_left_corner}${left_bar}${topbar}${right_bar}${btm_right_corner}\n"
        elif [[ -n "$content" ]] && [[ "$boxless" == "false" ]] ; then
            printf "${blank_spacer}${left_div_wall}${left_bar}${topbar}${right_bar}${right_div_wall}\n"
        fi
    else
        # if theres no title, just make the top of the box
        echo ""
        bento_vars
        printf "${blank_spacer}${top_left_corner}${left_bar}${topbar}${right_bar}${top_right_corner}\n"
    fi
        # unset alignment if it was only for this section
        if [[ "$trightaligned" == "true" ]] || [[ "$tleftaligned" == "true" ]] ; then
            rightaligned="false"
            leftaligned="false"
        fi

    # generate the content
    if [[ -n "$content" ]] ; then
        # set alignment
        if [[ "$crightaligned" == "true" ]] ; then
            rightaligned="true"
        elif [[ "$cleftaligned" == "true" ]] ; then
            leftaligned="true"
        fi
        # loop for each line in the box
        for line in "${content[@]}"; do
            bento_vars
            # if the text is too long, split it into another line
            if (( (text_width + 8) > terminal_width )) ; then
            long_content="$(echo "$line" | fold -w $box_width -s)"
            IFS=$'\n'
            multi_array=($long_content)
            unset IFS
            multibox "${multi_array[@]}"
            else
            printf "${blank_spacer}${left_wall}${left_border}${filler}${line}${filler}${right_border}${right_wall}\n"
            fi
        done
        if [[ "$boxless" == "false" ]] ; then
            printf "${blank_spacer}${btm_left_corner}${left_bar}${topbar}${right_bar}${btm_right_corner}\n"
        fi
    fi

# display optional guides
if [[ "$boxless" == "false" ]] ; then
    if [[ "$arrows" == "true" ]] || [[ "$return" == "true" ]] || [[ "$exit" == "true" ]] || [[ "$toggle" == "true" ]] ; then
        if [[ "$arrows" == "true" ]] ; then
            line="${keys_opt_arrows}"
        elif [[ "$return" == "true" ]] ; then
            menu="previous_menu"
            line="${keys_opt_return}"
        elif [[ "$exit" == "true" ]] ; then
            menu="continue"
            line="${keys_opt_exit}"
        elif [[ "$input" == "true" ]] ; then
            line="${keys_opt_input}"
        elif [[ "$toggle" == "true" ]] ; then
            line="${keys_opt_toggle}"
        fi
        bento_vars
        if (( (text_width + 8) > terminal_width )) ; then
            long_content="$(echo "$line" | fold -w $box_width -s)"
            IFS=$'\n'
            multi_array=($long_content)
            unset IFS
            multistep "${multi_array[@]}"
        else
            printf "${blank_spacer}${blank_spacer}${left_border}${line}${right_border} \n"
        fi
    fi
    if [[ "$toggle" == "true" ]] ; then
        line="$toggle_hint"
        bento_vars
        if (( (text_width + 8) > terminal_width )) ; then
            long_content="$(echo "$line" | fold -w $box_width -s)"
            IFS=$'\n'
            multi_array=($long_content)
            unset IFS
            multistep "${multi_array[@]}"
        else
            printf "${blank_spacer}${blank_spacer}${left_border}${line}${right_border} \n"
        fi
    fi
fi
    # unset alignment if it was only for this section
    if [[ "$crightaligned" == "true" ]] || [[ "$cleftaligned" == "true" ]] ; then
        rightaligned="false"
        leftaligned="false"
    fi

    # generate the menu
    if [[ -n "$menu" ]] || [[ -n "$multimenu" ]]; then
            echo ""
            menumaker
    fi

    # if using a user-generated input...
    if [[ "$input" == "true" ]] ; then
        echo ""
        input_reader
        selection="$input_selection"
    fi

    bento_cleanup
}

input_reader(){
    input_selection=""
    if [[ "$boxless" == "true" ]] ; then
        b="-b"
    fi
    read -rp ' >> ' input_selection
    bento_cleanup
    if [[ -z "$input_selection" ]] ; then
    bento $b -t "Confirm" -c "Continue without entering anything?" -m "Yes" "No" "Back" "Exit" -s "Confirm entry" "Try again" "Go back to the previous menu" "Exit without saving"
    else
    bento $b -t "Confirm" -c "Is this correct?" "$input_selection" -m "Yes" "No" "Back" "Exit" -s "Confirm entry" "Try again" "Go back to the previous menu" "Exit without saving"
    fi
    case "$selection" in
        "Yes") return ;;
        "No") input_reader ; return ;;
        "Back") $previous_menu ; return ;;
        "Exit") exit 0 ;;
    esac

}

menumaker(){
    unset selection
    if [[ "$multiselection" == "true" ]] ; then
        if [[ -n "${menu[*]}" ]] ; then
            for ((i = 0; i < ${#menu[@]}; ++i)); do
                # keep looping for every option to add them to our array
                multimenu+=("${menu[$i]}")
            done
            unset menu
        fi
        for ((i = 0; i < ${#multimenu[@]}; ++i)); do
            # keep looping for every option to add them to our array
            menu+=("${multimenu[$i]}")
        done
        unset multimenu
    fi
    select_opt "${menu[@]}"
        # parse selection
        if [[ "$selection" == "previous_menu" ]] ; then
            bento_cleanup
            unset selection
            $previous_menu
        elif [[ "$selection" == "continue" ]] ; then
                bento_cleanup
                unset selection
                : # continue to the next part of script logically
        elif [[ -n "$selection" ]] ; then
        echo ""
        echo ""
                echo "[o] User selected: ${selection[*]}"
        fi
        bento_cleanup
}

bento_cleanup(){
    # cleanup arrays for next box
    unset title
    unset content
    unset menu
    unset multimenu
    unset submenu
    unset line
    unset long_title
    unset long_content
    unset multi_array
    unset array
    unset multi
}

bento_vars(){
    padding="2"
    text_width=${#line}
    size_limit=$(( text_width + 8 ))
    if (( size_limit < 40 )) ; then
      size_limit="40"
    fi
    title_text_width=${#line}
    title_size_limit=$(( title_text_width + 8 ))
    if (( title_size_limit < 40 )) ; then
      title_size_limit="40"
    fi
    # Glyph settings
    filler=" "                              # box filler, just use spaces
    title_filler="░"                        # title box filler
    # make matching corners and walls as necessary
      possible_bars=(─ ═)
     left_div_walls=(├ ╠)
    right_div_walls=(┤ ╣)
   top_left_corners=(┌ ╔)
   btm_left_corners=(└ ╚)
  top_right_corners=(┐ ╗)
  btm_right_corners=(┘ ╝)
              walls=(│ ║)
  if [[ "$glyph" == "true" ]] ; then
      top_left_corner="╔"
      top_right_corner="╗"
      btm_left_corner="╚"
      btm_right_corner="╝"
      title_left_wall="║"
      title_right_wall="║"
      left_wall="║"
      right_wall="║"
      left_div_wall="╠"
      right_div_wall="╣"
      topbar="═"
  else
      top_left_corner="┌"
      top_right_corner="┐"
      btm_left_corner="└"
      btm_right_corner="┘"
      title_left_wall="│"
      title_right_wall="│"
      left_wall="│"
      right_wall="│"
      left_div_wall="├"
      right_div_wall="┤"
      topbar="─"
  fi
    # some bars are a bit short, align them appropriately
    short_bars=(─━┄┅┈┉╌╍═░▒▓)
    if [[ "${short_bars[@]}" =~ "$topbar" ]] && [[ "${short_bars[@]}" != "" ]]; then
    bar_width=$(( ((terminal_width - (padding * 2) - 1) / 2) - 1 ))
    else
    bar_width=$(( ((terminal_width - (padding * 2) - 1) / 2) - 2 ))
    fi
    border_width=$(( ((terminal_width - (padding * 2) - text_width) / 2) - 2 ))
    title_border_width=$(( ((terminal_width - (padding * 2) - title_text_width) / 2) - 2 ))
    border=                         # shape of the border
    title_border=                         # shape of the border
    bar=

    # special search/replace for making dividers

    # special search/replace for making dividers
    if [[ "$line" == "div" ]] ; then
        line="$topbar$topbar$topbar"
        filler="$topbar"
        title_filler="$topbar"
        left_wall="$left_div_wall"
        right_wall="$right_div_wall"

    elif [[ "$line" == "lid" ]] ; then
        line="$topbar$topbar$topbar"
        filler="$topbar"
        title_filler="$topbar"
        left_wall="$top_left_corner"
        right_wall="$top_right_corner"

    elif [[ "$line" == "btm" ]] ; then
        line="$topbar$topbar$topbar"
        filler="$topbar"
        title_filler="$topbar"
        left_wall="$btm_left_corner"
        right_wall="$btm_right_corner"

    fi
    # create the border (left side or right side)
    for ((i=0; i<border_width; i++))
    do
        border+="${filler}"
    done
    for ((i=0; i<title_border_width; i++))
    do
        title_border+="${title_filler}"
    done
    # create the topbar (left side or right side)
    for ((i=0; i<bar_width; i++))
    do
        bar+="${topbar}"
    done
    # a side of the border may be longer (e.g. the right border)
    if (( ( terminal_width - ( padding * 2 ) - text_width ) % 2 == 0 ))
    then
        # the left and right borders have the same width
        left_border="$border"
        right_border="$left_border"
    else
        # the right border has one more character than the left border
        # the text is aligned leftmost
        left_border="$border"
        right_border="$left_border$filler"
    fi
    # a side of the border may be longer (e.g. the right border)
    if (( ( terminal_width - ( padding * 2 ) - title_text_width ) % 2 == 0 ))
    then
        # the left and right borders have the same width
        title_left_border="$title_border"
        title_right_border="$title_left_border"
    else
        # the right border has one more character than the left border
        # the text is aligned leftmost
        title_left_border="$title_border"
        title_right_border="$title_left_border$title_filler"
    fi
    # set alignments by combining variables then clearing one of them.
    if [[ "$rightaligned" == "true" ]] ; then
        left_border="$left_border""$right_border"
        right_border=""
        title_left_border="$title_left_border""$title_right_border"
        title_right_border=""
    elif [[ "$leftaligned" == "true" ]] ; then
        right_border="$left_border""$right_border"
        left_border=""
        title_right_border="$title_left_border""$title_right_border"
        title_left_border=""
    fi
    # a side of the topbar may be longer (e.g. the right border)
    if (( ( terminal_width - ( padding * 2 ) - 1 ) % 2 == 0 ))
    then
        # the left and right bars have the same width
        left_bar=$bar
        right_bar=$left_bar
    else
        # the right bar has one more character than the left bar
        # the text is aligned leftmost
        left_bar=$bar
        right_bar="${bar}${topbar}"
    fi
    # undo all of this if we arent making boxes
    blank_spacer="  "
    if [[ "$boxless" == "true" ]] ; then
        blank_spacer=""
        top_left_corner=""
        top_right_corner=""
        btm_left_corner=""
        btm_right_corner=""
        left_wall=""
        right_wall=""
        title_left_wall=""
        title_right_wall=""
        left_div_wall="$topbar"
        right_div_wall="$topbar"
        topbar=""
        #title_filler=""
        #filler=""
        left_bar=""
        right_bar=""
        left_border+="${filler}${filler}${filler}"
        right_border+="${filler}${filler}${filler}"
        title_left_border+="${title_filler}${title_filler}${title_filler}"
        title_right_border+="${title_filler}${title_filler}${title_filler}"
      fi
}

multibox(){
  local multi=("$@")
  for line in "${multi[@]}" ; do
      bento_vars
  printf "${blank_spacer}${left_wall}${left_border}${filler}${line}${filler}${right_border}${right_wall}\n"
  done
}

multititle(){
  local multi=("$@")
  for line in "${multi[@]}" ; do
      bento_vars
  printf "${blank_spacer}${title_left_wall}\033[7m${title_left_border}${title_filler}${line}${title_filler}${title_right_border}\033[27m${title_right_wall}\n"
  done
}

multisub(){
  local multi=("$@")
  for line in "${multi[@]}" ; do
      bento_vars
          echo ""
          printf "\33[A\33[2K\r%s"
      printf "\r%s${blank_spacer}${left_wall}${left_border}${filler}${line}${filler}${right_border}${right_wall}\n"
  done
}

multistep(){
  local multi=("$@")
  for line in "${multi[@]}" ; do
      bento_vars
      printf "${blank_spacer}${blank_spacer}${left_border}${filler}${line}${filler}${right_border} \n"
  done
}

# This is the code that makes the nice selection UI
# When 'tooltips=disabled' then tooltips won't be avaliable.
# Modified from https://unix.stackexchange.com/questions/146570/arrow-key-enter-menu/415155#415155
# Renders a text based list of options that can be selected by the
# user using up, down and enter keys and returns the chosen option.
#
#   Arguments   : list of options, maximum of 256
#                 "opt1" "opt2" ...
#   Return value: selected index (0 for opt1, 1 for opt2 ...)

#<~> Menu Maker functions

function select_option {

toggle_selection(){
    # search already selected item to see if this option was already selected and deselect it
    # use the found variable to confirm if it was an exact match
    found="false"
    if [[ "${selection[*]}" =~ "${menu[$selected]}" ]] ; then
        for selectopt in "${selection[@]}" ; do
            if [[ "${selection[$selectopt]}" == "${menu[$selected]}" ]] ; then
                unset "selection[$selectopt]"
                found="true"
            fi
        done
    fi
    # If the option was not found in the selection
    if [[ "$found" == "false" ]] ; then
        selection+=("${menu[$selected]}")
    else # If it was found, clean up the arrays
        for i in "${selection[*]}" ; do
            temparr+=("${selection[@]}")
        done
        unset selection
        for i in "${temparr[*]}" ; do
            selection+=("${temparr[@]}")
        done
        unset temparr
    fi
}

    local menuopts=("$@")
    local terminal_height=$(tput lines)     # query the Terminfo database: number of lines
    local box_height=$(( terminal_height - 13 ))
    local terminal_width=$(tput cols)     # query the Terminfo database: number of columns
    local box_width=$(( terminal_width - 8 ))
    # little helpers for terminal print control and key input
    ESC=$( printf "\033")
    cursor_blink_on()  { printf "$ESC[?25h"; }
    cursor_blink_off() { printf "$ESC[?25l"; }
    cursor_to()        { printf "$ESC[$1;${2:-1}H"; }

#   control display of non-highlighted options
#   print_option()     { printf "\33[A\33[2K\r%s    $1 "; }
    print_option()     {
    # check if option is among selections
    if [[ ${selection[@]} =~ "$1" ]]
    then
            hilite="$ESC[7m" && end_hilite="$ESC[27m"
        else
            hilite="" && end_hilite=""
    fi


    # set alignment
    if [[ "$1" == "div" ]] ; then
        printf "   "
    elif [[ "$mrightaligned" == "true" ]] ; then
                line="$1"
                bento_vars
                printf "\33[A\33[2K\r   $hilite $line $end_hilite${left_border}${right_border}"
    elif [[ "$mcenteraligned" == "true" ]] ; then
                line="$1"
                bento_vars
                printf "\33[A\33[2K\r  $hilite ${left_border}${right_border}$line $end_hilite"
    else
                printf "\33[A\33[2K\r%s   $hilite $1 $end_hilite"
    fi
    # turn highlights back off
        hilite="" && end_hilite=""
}

#   control display of currently-highlighted options
#   print_selected()   { printf "\33[A\33[2K\r%s ⮞ $ESC[7m $1 $ESC[27m";
    print_selected()   {
    if [[ "$return" == "true" ]] || [[ "$exit" == "true" ]] ; then
        # dont bother displaying an option with these enabled
        printf " "
    elif [[ "$1" == "div*" ]] ; then
        printf "   "
    else
    if [[ "$mrightaligned" == "true" ]] ; then
            line="$1"
            bento_vars
            printf "\33[A\33[2K\r ➤ ${left_border}${right_border}$ESC[7m $line $ESC[27m"
    elif [[ "$mcenteraligned" == "true" ]] ; then
            line="$1"
            bento_vars
            printf "\33[A\33[2K\r ➤ $ESC[7m $line $ESC[27m${left_border}${right_border}"
    else
            printf "\33[A\33[2K\r%s ➤ $ESC[7m $1 $ESC[27m"
    fi fi
}

    #get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
    key_input()        { read -s -n3 key 2>/dev/null >&2
                         if [[ $key = $ESC[A ]]; then echo up;     fi
                         if [[ $key = $ESC[B ]]; then echo down;   fi
                         if [[ $key = ""     ]]; then echo enter;  fi; }

    get_menuopts_total(){
      menuopts_length=0
        for x in "${menuopts[@]}" ; do
          ((menuopts_length++))
        done
      if [ $menuopts_length -gt $box_height ] ; then
         : # do nothing for now, this may be useful again later
      fi
    }

    get_subtitle_max_size(){
          subtitle_length=-1
            for x in "${submenu[@]}" ; do
              if [[ ${#x} -gt $subtitle_length ]] ; then
                subtitle_length=$(( ${#x} + 0 ))
              fi
            done
        }

    make_subtitles(){
        if (( terminal_height > 29 )) && [[ "$boxless" == "true" ]] ; then
          get_menuopts_total
          get_subtitle_max_size
          if [[ ! "$tooltips" == "disabled" ]] ; then
            cursor_to $lastrow
            printf "\33[A\33[2K\r%s\n"
            bento_subs
            printf "\33[2K\r%s\n"
            printf "\33[2K\r%s\n"
            fi
        elif (( terminal_height > 39 )) && [[ "$boxless" == "false" ]] ; then
            get_menuopts_total
            get_subtitle_max_size
            if [[ ! "$tooltips" == "disabled" ]] ; then
              cursor_to $lastrow
              printf "\33[A\33[2K\r%s\n"
              bento_subs
              printf "\33[2K\r%s\n"
              printf "\33[2K\r%s\n"
            fi
        fi
        }

    bento_subs(){
        if [[ -n "${submenu[$idx]}" ]] ; then
                    if [[ "$srightaligned" == "true" ]] ; then
                        rightaligned="true"
                    elif [[ "$sleftaligned" == "true" ]] ; then
                        leftaligned="true"
                    fi
            glyph="true"
            if [[ "$boxless" == "false" ]] ; then
            bento_vars
                printf "\r%s${blank_spacer}${top_left_corner}${left_bar}${topbar}${right_bar}${top_right_corner}\n"
            fi

                line="${submenu[$idx]}"
                bento_vars
                if (( (text_width + 8) > terminal_width )) ; then
                long_content="$(echo "$line" | fold -w $box_width -s)"
                IFS=$'\n'
                multi_array=($long_content)
                unset IFS
                multisub "${multi_array[@]}"
                else
                    echo ""
                    printf "\33[A\33[2K\r%s"
                printf "\r%s${blank_spacer}${left_wall}${left_border} $line ${right_border}${right_wall}\n"
                fi

            if [[ "$boxless" == "false" ]] ; then
            echo ""
            bento_vars
            printf "\33[A\33[2K\r%s"
            printf "\r%s${blank_spacer}${btm_left_corner}${left_bar}${topbar}${right_bar}${btm_right_corner}\n"
            fi
            printf "\r%s"

                    if [[ "$srightaligned" == "true" ]] || [[ "$sleftaligned" == "true" ]] ; then
                        rightaligned="false"
                        leftaligned="false"
                    fi
        fi
        }


    # initially print empty new lines (scroll down if at bottom of screen)
    #for opt ; do
    #printf "\n"; done

    # determine current screen position for overwriting the options
    #lastrow=`get_cursor_row`
    #local lastrow="$terminal_height"
    #startrow=$(($lastrow - $#))

        # ensure cursor and input echoing back on upon a ctrl+c during read -s
    trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
    cursor_blink_off

    local selected=0
    while true; do
        # print options by overwriting the last lines
        local idx=0
        for opt; do
            cursor_to $(($startrow + $idx))
            if [ $idx -eq $selected ]; then
                print_selected "$opt"
                make_subtitles
            else
                print_option "$opt"
            fi

            ((idx++))
        done

        # user key control
        case `key_input` in
            enter)
		if [[ "$multiselection" == "true" ]] ; then
            	for ((i = 0; i < ${#menu[@]}; ++i)); do
                # keep looping for every option to add them to our array
                if [[ "${menu[$i]}" == "Confirm Selection" ]] ; then
                	break # end loop at "Confirm Selection" dont let it or others after it be add>
                else
                	multimenu+=("${menu[$i]}")
                fi
           	done
        	fi
        	if  [[ "$multiselection" == "true" ]] && [[ "${menu[$selected]}" == "Confirm Selection" ]] ; then
            		break
        	elif [[ "$multiselection" == "true" ]] && [[ "${multimenu[$selected]}" == "${menu[$selected]}" ]] ; then
            		# toggle selection on or off
            		toggle_selection
        	else
            		# standard menu function down here
            		selection=("${menu[$selected]}")
            		break
        	fi
		;;
            up)    ((selected--))
                   if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi
                    until [[ ! "${menu[$selected]}" == "div" ]] ; do
                        ((selected--));
                        if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi
                    done ;;

                   #if [[ "${menu[$selected]}" == "div" ]]; then
                   #((selected--))
                   #if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi ; fi ;;
            down)  ((selected++));
                   if [ $selected -ge $# ]; then selected=0; fi
                   until [[ ! "${menu[$selected]}" == "div" ]] ; do
                       ((selected++));
                       if [ $selected -ge $# ]; then selected=0; fi
                   done
                   #if [[ "${menu[$selected]}" == "div" ]]; then
                   #((selected++));
                   #if [ $selected -ge $# ]; then selected=0; fi ; fi ;;
        esac
    done

    # cursor position back to normal
    cursor_to $lastrow
    printf "\n"
    cursor_blink_on
    return $selected
}

get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }

screen_size_warning(){
        bento_cleanup
        bento -t "Warning" -c " " "Your terminal is too small to display this menu, please zoom out or expand the terminal and try again." " "

        if [[ -z "$previous_menu" ]] ; then
            error_destination="Back"
        else
            error_destination="Exit"
        fi

        printf " ➤ \033[7m $error_destination \033[27m"
            trap "printf '\033[?25h'; stty echo; printf '\n'; exit" 2
        printf "\033[?25l"
        read -rsn1 -p "" ; echo
        printf "\033[?25h"
        if [[ -z "$previous_menu" ]] ; then
            selection="Exit"
        else
            selection="Back"
        fi
}

function select_opt {
    echo ""
    for opt ; do
    printf "\n"; done
    lastrow=`get_cursor_row`
    startrow=$(($lastrow - $#))

    if (( lastrow > (terminal_height - 1) )) ; then
        screen_size_warning
    else
        select_option "$@" 1>&2
        local result=$?
        #echo $result
        return $result
    fi
}
#</>
#</>

bento_update(){
      update_failed="false"
      sudo mkdir -p /var/brunch/toolkit
      sudo chown -R $USER /var/brunch
      bento -t "Update" -c "Updating Bento, please wait..."
      curl -l https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/bento -o /var/brunch/toolkit/bento || update_failed="true"
      sudo install -Dt /usr/local/bin -m 755 /var/brunch/toolkit/bento || update_failed="true"
      rm /var/brunch/toolkit/bento
      if [[ "$update_failed" == "true" ]] ; then
      bento -t "Update" -c "Unable to update Bento!" "Make sure your internet connection is stable and try again." "You can also update manually by downloading Bento from:" "https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/bento" "then run: bash ~/Downloads/bento --install" -e
      else
          bento -t "Update" -c "Update succesful!" -e
      fi
}

bento_install(){
    install_failed="false"
    bento -t "Update" -c "Installing Bento $bento_version, please wait..."
    sudo install -Dt /usr/local/bin -m 755 "$0" || install_failed="true"
    if [[ "$update_failed" == "true" ]] ; then
    bento -t "Update" -c "Unable to update Bento!" 'Try moving Bento to /usr/local/bin manually, or to somewhere else in your $PATH' -e
    else
        bento -t "Update" -c "Install succesful!" -e
    fi
}

bento_debug(){
    bento -t "Test" -c "Testing multi select menu" -mm "one" "two" "three" "four" "five" "six" -m "seven" "eight" "Exit" -a
    case "$selection" in
        "Exit") exit 0 ;;
    esac
    bento -t "Results" -c "Here are the results" 'Array "${selection[@]}" returns the following:' "div" "${selection[@]}" "btm" "lid" "Test again?" -m "Restart" "Exit"
    case "$selection" in
        "Restart") bento -d ; return ;;
        "Exit") exit 0 ;;
    esac
}

#</>

#<~> Startup Utilities

preset_vars(){
    readonly userid=`id -u $USERNAME`
    onlineallowed="true"
    current_brunch_version=$(cat /etc/brunch_version 2>/dev/null |  cut -d' ' -f3 )
    path_to_downloads
}

path_to_downloads(){
if [[ -n "$DOWNLOADS" ]] ; then
    downloads="$DOWNLOADS"
elif [[ "$toolkit_mode" =~ "wsl" ]] ; then
    downloads=$(wslpath $(cmd.exe /C "echo %USERPROFILE%/Downloads"))
else
    downloads="$HOME/Downloads"
fi

}

check_for_options(){
    if [[ -z "$*" ]] ; then
        : # Do nothing, continue as normal
    fi
    # parse flags here
    PARAMS=""
while (( "$#" )); do
  case "$1" in
  -o|--offline)
  # Disable online functions
    onlineallowed="false"
    shift
    ;;
  -d|--debug)
  # Do debug functions
    toolkit_debug
    exit 0
    ;;
  --*=|-*) # unsupported flags
    echo "Error: Unsupported flag $1" >&2
    exit 1
    ;;
  *) # preserve positional arguments
    PARAMS="$PARAMS $1"
    shift
    ;;
esac
done
# set positional arguments in their proper place
eval set -- "$PARAMS"
}

check_for_shell(){
    if [ "$SHELL" == "/bin/bash" ] ; then
    echo ""
    echo ""
      bento -t "Shell Authorization" -c "This toolkit is only compatible with the default sh shell, please do not run it in the developer console or with alternative shells" -e
      exit 0
    fi
}

# Toolkit behaves badly if ran as root, check to avoid that
check_for_root(){
    if [ $userid -eq 0 ] ; then
        bento -t "User Authorization" -c "Do not run this toolkit as root or with sudo" -e
        exit 0
    fi
}

# Checks for an internet connection and disables unnecessary options when no connection is present
check_for_network() {
    if [[ $onlineallowed == "true" ]] ; then
        bento -t "Network Check" -c "Checking network status, please wait..." " " "To run the toolkit offline, use the -o flag"
        case "$(curl -s --max-time 2 -I http://google.com | sed 's/^[^ ]*  *\([0-9]\).*/\1/; 1q')" in
            [23]) : ;; # do nothing and continue quietly
               5) bento -t "Network Check" -c "The network is blocked, unable to use online features." "Check your firewall settings and try again later." -e ; onlineallowed="false" ;;
               *) bento -t "Network Check" -c "The network is down or very slow, unable to use online features." "Check your firewall settings and try again later." -e ; onlineallowed="false" ;;
        esac
    else
        bento -t "Network Check" -c "Networking has been disabled" -e
        onlineallowed="false"
    fi
}

quick_network_check(){
    # Check for a stable internet connection #
    case "$(curl -s --max-time 2 -I http://google.com | sed 's/^[^ ]*  *\([0-9]\).*/\1/; 1q')" in
    # If connection is good, do nothing and proceed quietly
        [23]) : ;;
    # Error on weak or empty connection
        *) bento -t "Network Check" -c "The network is down or very slow, unable to continue." "Check your connection and try again later." -r ; $previous_menu ;;
    esac
}


get_os_ver() {
      source /etc/os-release 2>/dev/null
      if [ -z "$GOOGLE_CRASH_ID" ]; then
          current_chromeos_version=$"$ID $VERSION $BUILD_ID"
      else
          current_chromeos_version=$"$BUILD_ID"
      fi
      }



check_for_dualboot(){
    source=$(rootdev -d)
    if (expr match "$source" ".*[0-9]$" >/dev/null); then
        partsource="$source"p
    else
        partsource="$source"
    fi
    if [[ "$source" =~ .*"loop".* ]] ; then
      dualboot="true"
    else
      dualboot="false"
    fi
}

check_install_type(){
    # options: toolkit_mode=[brunch|brunch_dualboot|brunch_usb|linux|linux_usb|wsl|arch|arch_usb|arch_wsl]
    # Checks the user's system for keywords and adjusts the functions of the script accordingly
        if [ -z "$current_brunch_version" ] && [[ $(grep icrosoft /proc/version 2> /dev/null) ]] && [[ -f "/etc/arch-release" ]] ; then
            toolkit_mode="arch_wsl"
        elif [ -z "$current_brunch_version" ] && [[ $(grep icrosoft /proc/version 2> /dev/null) ]] ; then
            toolkit_mode="wsl"
        elif [ -z "$current_brunch_version" ] && [[ -f "/etc/arch-release" ]] ; then
            toolkit_mode="arch"
        elif [ -z "$current_brunch_version" ] && [[ -z $(grep icrosoft /proc/version 2> /dev/null) ]] ; then
            toolkit_mode="linux"
        else
            #assume the user is using brunch at this point
            get_os_ver
            check_for_dualboot
            if [[ "$dualboot" == "true" ]] ; then
                    toolkit_mode="brunch_dualboot"
            else
                    toolkit_mode="brunch"
            fi
        fi
}

#</>

#<~> Toolkit Config
#
# Source config info for brunch. If they don't exist, make them.
# Use this to set special settings that don't need to be asked or prompted very often.
# For normal usage, save this config file in /var/brunch/toolkit as toolkit.cfg
check_for_config(){
config_file="/var/brunch/toolkit/toolkit.cfg"
if [[ -f "$config_file" ]] ; then
    # Config exists, update a couple things
    get_os_ver
    sed -i "s/current_brunch_version=.*/current_brunch_version=$current_brunch_version/" "$config_file"
    currentsemversion=$(echo "$toolkitversion" | sed -e "s/^v//" -e "s/b$//")
    sed -i "s/current_toolkit_version=.*/current_toolkit_version=$currentsemversion/" "$config_file"
    sed -i "s/current_chromeos_version=.*/current_chromeos_version=$current_chromeos_version/" "$config_file"
    source "$config_file" 2> /dev/null
    clear
else
    # Config does not exist yet
    create_config_file
fi
}

create_config_file(){
    sudo mkdir -p /var/brunch/toolkit
    sudo chown -R $USER /var/brunch
    touch "$config_file"
    tee > "$config_file" <<EOF

#      ___                  _      _____         _ _   _ _
#     | _ )_ _ _  _ _ _  __| |_   |_   _|__  ___| | |_(_) |_
#     | _ \ '_| || | ' \/ _|  _ \   | |/ _ \/ _ \ | / / |  _|
#     |___/_|  \_,_|_||_\__|_||_|   |_|\___/\___/_|_\_\_|\__|
#

# Looking for help? Find me on discord: https://discord.gg/x2EgK2M


# This is the configuration file for the Brunch Toolkit,
# and is automatically generated by the toolkit.
# These settings should be managed directly with the toolkit,
# but I will attempt to document them here just in case.

# First time init
# If this is not set or set to enabled, the toolkit will run
# first time init hen it is opened next time. This init is used
# to set all of the following variables in this config file.
# Usage: [enabled|disabled]
first_time_init=

# App Splash Screen
# This value will show an ascii splash screen when launching
# the toolkit if enabled. Typically this animation is only seen
# on first launch and is disabled by default afterwards.
# Usage: [enabled|disabled]
startup_anim=

# Use Bento Boxes
# This value will determine the style of the toolkit's UI,
# specifically whether or not the toolkit will use the new
# textbox UI called "Bento" which is enabled by default.
# Usage: [enabled|disabled]
bento_boxes=
bento_version=

# Display Tooltips
# The following value will set the avaliability of tooltips,
# which are enabled by default. These are dynamic boxes
# displayed at the bottom of the terminal when making selections.
# If bento is disabled, these tooltips will be plain as well.
# Some menus do not have tooltips.
# Usage: [enabled|disabled]
tooltips=

# Detected Install Type
# This setting is based on the user's installation, and can
# only be changed directly from this file. This setting changes
# core functions of the toolkit, do not change it unless you're
# sure of what you are doing.
# Usage: [brunch|brunch_dualboot|brunch_usb|linux|linux_usb|linux_wsl|arch|arch_usb|arch_wsl]
toolkit_mode=

# Chosen Recovery
# This sets which recovery the toolkit will download. By
# default, it is set based on the user's CPU compatibility.
# Use common sense when changing this setting, refer to the
# brunch github or the toolkit's compatibility checker for
# valid recoveries.
# Usage: selected_recovery= "string"
selected_recovery=

# Dependencies installed
# Only important on non-brunch devices, if set to false
# certain options will prompt for the dependencies to be
# installed before they will work properly.
# Usage: [true|false]
dependencies_installed=

# Advanced Options
# This allows the user to access extra options in the toolkit
# This is disabled by default to help prevent user error
# Usage: [enabled|disabled]
advanced_options=

# Brunch Editor
# This setting lets you choose which text editor to use
# In the advanced settings page you can toggle between
# nano or vi, but you can declare anything from here
# Usage: [program]
brunch_editor=

# Downloads location
# Allows setting a specific location for new downloads
# This is most useful for WSL users.
# Usage: [path/to/downloads]
downloads=

# ImageMagick settings
# Preset variables used by ImageMagick when converting images
# to be used as grub themes, bootsplash or boot animation frames
# Height and Width of the user's screen, tries to fetch automatically
height=
width=

# Scaling used for converted images
# Usage: [centered|fit|iconify] defaults to centered when unset
scaling=

# Prefered color for the canvas/borders when cropping (Currently Unused)
usercolor=

# Check for updates at startup
# Prompts the toolkit to check for updates when it's launched.
# Default is disabled to avoid issues with github's limiting.
# The toolkit will keep track of various options here.
# Usage: [enabled|disabled]
autocheck=

latest_brunch_version=
current_brunch_version=
stable_update=

get_unstable_updates=
latest_brunch_unstable_version=
unstable_update=

latest_chromeos_version=
current_chromeos_version=
chromeos_update=

latest_toolkit_version=
current_toolkit_version=
toolkit_update=

saved_announcement_ver=

EOF

}
#</>

#<~> Toolkit Startup Animation
startup_anim(){
frame=("1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15" "16" "17" "18" "19" "20" "21" "22" "23")
frame1=("◜                " "◝ B              " "◞ Br             " "◟ Bru            " "◜ Brun           " "◝ Brunc          " "◞ Brunch         " "◟ Brunch         " "◜ Brunch T       " "◝ Brunch To      " "◞ Brunch Too     " "◟ Brunch Tool    " "◜ Brunch Toolk   " "◝ Brunch Toolki  " "◞ Brunch Toolkit " "◟ Brunch Toolkit " "◜ Brunch Toolkit " "◝ Brunch Toolkit " "◞ Brunch Toolkit " "◟ Brunch Toolkit " "◜ Brunch Toolkit " "◝ Brunch Toolkit " "◞ Brunch Toolkit " "◟ Brunch Toolkit ")
if [[ ! $startup_anim == "disabled" ]] ; then
clear
terminal_height=$(tput lines)     # query the Terminfo database: number of lines
center_height=$(( terminal_height / 2 - 1 ))
terminal_width=$(tput cols)

draw_frame(){
printf "%*s\r" $(((20+$terminal_width)/2)) "$layer1"
sleep .04
}

x="$center_height"
while [ "$x" -gt 0 ] ; do
    printf "\n"
    x=$(($x-1))
done
for i in "${frame[@]}" ; do
    layer1="${frame1[$i]}"
    draw_frame
done
clear
fi
}
#</>

#<~> First Time init
# Set some important variables for the toolkit
# Only do this on the first boot or if prompted
#

first_time_init_startup(){
    if [[ ! "$first_time_init" == "disabled" ]] ; then
    first_time_init_page1
    fi
}

first_time_init_page1(){
if [[ "$first_time_init" == "enabled" ]] ; then
    fti_startup_screen=("Welcome back to the Brunch Toolkit" "It looks like you're resetting some options, lets get started!")
elif [[ -z "${first_time_init}" ]]  ; then
        fti_startup_screen=("Welcome to the Brunch Toolkit." "It looks like this may be the first time you've used this version of the toolkit." "Please be patient as we set up some options." "All options can be changed later.")
fi
    bento -t "Brunch Toolkit - Startup" -c "${fti_startup_screen[@]}" -m "Start" "Exit" -a -s "Start the setup process" "Close the toolkit"
      case "$selection" in
        "Start") first_time_init_page2 ; return ;;
        "Exit") exit 0 ;;
      esac
}

first_time_init_page2(){
    bento -t "Loading Animation" -c " " "Display the loading animation when launching the Brunch Toolkit?" " " -m "No" "Yes" "Exit" -a -s "Do not display the loading animation" "Display the loading animation" "Exit without saving"
    case "$selection" in
        "No") startup_anim="disabled" ;;
        "Yes") startup_anim="enabled" ;;
        "Exit") exit 0 ;;
    esac
first_time_init_page3
}

first_time_init_page3(){
    bento -t "Bento" -c "This script is built with Bento." "Bento is a custom made textbox and menu interface for Brunch." "If you dont like textboxes, you can disable them on this page." "Use Bento to make textboxes?" -m "Yes" "No" "Back" "Exit" -s "Keep Bento enabled" "Disable textboxes" "Go back to the previous page" "Exit without saving" -a
    case "$selection" in
        "Yes") bento_boxes="enabled" ;;
        "No") bento_boxes="disabled" ; export bento_boxes ;;
        "Back") first_time_init_page2 ; return ;;
        "Exit") exit 0 ;;
    esac
first_time_init_page4
}

first_time_init_page4(){
    bento -t "Tooltips" -c "Keep tooltips enabled at the bottom of the terminal?" "(When enabled, they might not be avalible on every menu)" -m "Yes" "No" "Back" "Exit" -s "Keep tooltips enabled" "Disabled tooltips" "Go back to the previous page" "Exit without saving" -a
    case "$selection" in
        "Yes") tooltips="enabled" ;;
        "No") tooltips="disabled" ; export tooltips ;;
        "Back") first_time_init_page3 ; return ;;
        "Exit") exit 0 ;;
    esac
    selection_made="false"
first_time_init_page5
}


first_time_init_page5(){
    if [[ "$selection_made" == "true" ]] ; then
        first_time_init_page6
    else
    check_install_type
    if [[ "$toolkit_mode" == "arch" ]] || [[ "$toolkit_mode" == "linux" ]] ; then
        bento -t "Installation Details" -c "Are you currently running $toolkit_mode from a live USB?" -m "No" "Yes" "Back" "Exit" -s "This is not a live USB" "This is a live USB" "Go back to the previous page" "Exit without saving" -a
        case "$selection" in
            "No") : ;; #do nothing and continue
            "Yes") toolkit_mode="$toolkit_mode"_usb ;;
            "Back") first_time_init_page4 ; return ;;
            "Exit") exit 0 ;;
        esac
        quiet_compatibility_check
        if [[ "$detected_recovery" == "unsupported" ]] ; then
            compatible="no"
        bento -t "Installation Details" -c "Your currently detected CPU is not compatible with Brunch" "If you want to continue, please select which recovery you want to use." "" "If you believe this is an error, please contact Wisteria on the Brunch Discord Server." -m "Select a Recovery" "Back" "Exit" -s "Select your preferred recovery" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Select a Recovery") previous_page="first_time_init_page5" ; select_a_recovery ; return ;;
            "Back") first_time_init_page4 ; return ;;
            "Exit") exit 0 ;;
        esac
        else
            compatible="yes"
        bento -t "Installation Details" -c "Your currently detected CPU is compatible with $detected_recovery" "Save this as your preferred recovery?" -m "Yes" "No" "Back" "Exit" -s "Use suggested recovery" "Select something else" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Yes") selected_recovery="$detected_recovery" ;;
            "No")  previous_page="first_time_init_page5" ; select_a_recovery ; return ;;
            "Back") first_time_init_page4 ; return ;;
            "Exit") exit 0 ;;
        esac
        fi
    elif [[ "$toolkit_mode" =~ "brunch" ]] ; then
        detected_recovery=$(printenv | grep CHROMEOS_RELEASE_BOARD | cut -d"=" -f2 | cut -d"-" -f1)
        bento -t "Installation Details" -c "Your currently detected recovery is $detected_recovery" "Save this as your preferred recovery?" -m "Yes" "No" "Back" "Exit" -s "This is my recovery" "Select something else" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Yes") selected_recovery="$detected_recovery" ;;
            "No")  previous_page="first_time_init_page5" ; select_a_recovery ; return ;;
            "Back") first_time_init_page4 ; return ;;
            "Exit") exit 0 ;;
        esac
    else
        previous_page="first_time_init_page4"
    fi
first_time_init_page6
fi
}

first_time_init_page6(){
    bento -t "Check for Updates" -c "Would you like the toolkit to check for updates automatically when it is launched?" "(You can still check for updates from the main menu when this is disabled.)" -m "No" "Yes" "Back" "Exit" -a -s "Do not check for updates automatically" "Check for updates automatically" "Go back to the previous page" "Exit without saving"
    case "$selection" in
        "Yes") autocheck="enabled" ;;
        "No")  autocheck="disabled" ;;
        "Back") first_time_init_page5 ; return ;;
        "Exit") exit 0 ;;
    esac
first_time_init_page7
}

first_time_init_page7(){
    if [[ ! "$toolkit_mode" =~ "brunch" ]] && [[ ! "$dependencies_installed" == "true" ]]; then
        previous_menu="first_time_init_page7"
        dependency_search
    elif [[ "$toolkit_mode" =~ "brunch" ]] ; then
        dependencies_installed="true"
    fi
    first_time_init_page8
}


first_time_init_page8(){
# Compile the results of all of the init pages so far into one and write them to the config file
fti_finalize=(
"Thank you for your patience."
"The following settings have been written to your config file,"
"They can be changed later from the main menu if needed."
""
"div"
"Loading Animation          $startup_anim"
"Bento                      $bento_boxes"
"Tooltips                   $tooltips"
"Check for Updates          $autocheck"
"Installation Details       $toolkit_mode"
)
if [[ "$toolkit_mode" =~ "brunch" ]] ; then
fti_finalize+=(
"Selected Recovery          $selected_recovery"
"Current Brunch release     $current_brunch_version")
else
fti_finalize+=(
"Dependencies Installed     $dependencies_installed"
"Selected Recovery          $selected_recovery")
    if [[ "$compatible" == "yes" ]] ; then
    fti_finalize+=("This CPU is compatible with Brunch" "$cputype")
elif [[ "$compatible" == "no" ]] ; then
    fti_finalize+=("This CPU is not compatible with Brunch" "$cputype")
    fi
fi
path_to_downloads
update_config_file
bento -t "Startup - Summary" -cla -c "${fti_finalize[@]}" -m "Continue to Main Menu"
case "$selection" in
    *) main_menu_startup ; return ;;
esac
}

update_config_file(){
    sed -i "s/startup_anim=.*/startup_anim=$startup_anim/" "$config_file"
    sed -i "s/bento_boxes=.*/bento_boxes=$bento_boxes/" "$config_file"
    sed -i "s/bento_version=.*/bento_version=$bento_version/" "$config_file"
    sed -i "s/tooltips=.*/tooltips=$tooltips/" "$config_file"
    sed -i "s/toolkit_mode=.*/toolkit_mode=$toolkit_mode/" "$config_file"
    sed -i "s/selected_recovery=.*/selected_recovery=$selected_recovery/" "$config_file"
    sed -i "s/compatible=.*/compatible=$compatible/" "$config_file"
    sed -i "s/dependencies_installed=.*/dependencies_installed=$dependencies_installed/" "$config_file"
    sed -i "s/downloads=.*/downloads=$downloads/" "$config_file"
    sed -i "s/autocheck=.*/autocheck=$autocheck/" "$config_file"
    sed -i "s/current_brunch_version=.*/current_brunch_version=$current_brunch_version/" "$config_file"
    currentsemversion=$(echo "$toolkitversion" | sed -e "s/^v//" -e "s/b$//")
    sed -i "s/current_toolkit_version=.*/current_toolkit_version=$currentsemversion/" "$config_file"
    sed -i "s/current_chromeos_version=.*/current_chromeos_version=$current_chromeos_version/" "$config_file"
    # Some of these get set automatically to a predetermined default
    sed -i "s/first_time_init=.*/first_time_init=disabled/" "$config_file"
    sed -i "s/brunch_editor=.*/brunch_editor=nano/" "$config_file"
    sed -i "s/advanced_options=.*/advanced_options=disabled/" "$config_file"
    sed -i "s/get_unstable_updates=.*/get_unstable_updates=false/" "$config_file"
    sed -i "s|downloads=.*|downloads=$downloads|" "$config_file"
    sed -i "s/scaling=.*/scaling=fit/" "$config_file"
}

#</>

#<~> Dependency installer

dependency_search(){
    command -v pv >/dev/null 2>&1 || needed_programs+=("pv")
    command -v unzip >/dev/null 2>&1 || needed_programs+=("unzip")
    command -v tar >/dev/null 2>&1 || needed_programs+=("tar")
    command -v cgpt >/dev/null 2>&1 || needed_programs+=("cgpt")
    command -v git >/dev/null 2>&1 || needed_programs+=("git")
    if [[ -n "${needed_programs[*]}" ]] ; then
    bento -t "Additional Dependencies" -c "Brunch has a few additional requirements on linux systems." "Needed programs: ${needed_programs[*]}" "The brunch toolkit can attempt to install them for you now." -m "Install now" "Install later" "Back" "Exit" -s "Attempt to install programs automatically" "Install later (Some functions will be disabled)" "Go back to the previous page" "Exit without saving" -a
    case "$selection" in
        "Install now") dependency_installer ; return ;;
        "Install Later") dependencies_installed="false" ; return ;;
        "Back") "$previous_menu" ; return ;;
        "Exit") exit 0 ;;
    esac
    else
        dependencies_installed="true"
        bento -t "Additional Dependencies" -c "All required dependencies are installed!" -r
    fi
}

dependency_installer(){
    if [[ "$toolkit_mode" =~ "linux" ]] ; then
        bento -t "Additional Dependencies" -c "Please wait while the toolkit installs dependencies." "Your password may be required for sudo."
        sudo apt update
        sudo apt install -y "${needed_programs[*]}" || dep_installation_failed="true"
    elif [[ "$toolkit_mode" =~ "arch" ]] ; then
        # find all arch dependencies seperately
            command -v pv >/dev/null 2>&1 || needed_programs_arch+=("pv")
            command -v unzip >/dev/null 2>&1 || needed_programs_arch+=("unzip")
            command -v tar >/dev/null 2>&1 || needed_programs_arch+=("tar")
            command -v git >/dev/null 2>&1 || needed_programs_arch+=("git")
            command -v sed >/dev/null 2>&1 || needed_programs_arch+=("sed")
            command -v patch >/dev/null 2>&1 || needed_programs_arch+=("patch")
            command -v gcc >/dev/null 2>&1 || needed_programs_arch+=("base-devel")
            command -v cgpt >/dev/null 2>&1 || need_vboot_utils="true"

        bento -t "Additional Dependencies" -c "Please wait while the toolkit installs dependencies." "Your password may be required for sudo."

        # use pacman for most of these, set a failed var if something goes wrong.
        sudo pacman -Syu "${needed_programs_arch[*]}" || dep_installation_failed="true"
        # build trousers and vboot-utils for cgpt, including workaround from Sebanc
            if [[ "$need_vboot_utils" == "true" ]] ; then
                git clone https://aur.archlinux.org/trousers.git
                cd trousers
                yes | makepkg -si
                cd ..
                git clone https://aur.archlinux.org/vboot-utils.git
                cd vboot-utils
                sed -i "s@cd vboot_reference@cd vboot_reference\n  sed -i 's/-Werror//g' Makefile@g" PKGBUILD
                yes | makepkg -si
                cd ..
            fi
    fi
    if [[ "$dep_installation_failed" == "true" ]] ; then
    dep_results=("There was an issue installing dependencies." "Please install them manually.")
    dependencies_installed="false"
    else
    dep_results=("Installation succesful!")
    dependencies_installed="true"
    fi
    bento -t "Additional Dependencies" -c "$dep_results" -r
}

#</>

#<~> Recovery Selection menu

select_a_recovery(){
    previous_menu="$previous_page"
    quick_network_check
    unset allrecoveries
    unset allrecoveries_page1
    unset allrecoveries_page2
    unset allrecoveries_page3
    unset allrecoveries_page4
    clear
    bento -n -t "Select a Recovery" -c "Fetching recoveries,  please wait..."
    if [[ "$detected_recovery" == "unsupported" ]] ; then
    suggested_recoveries=("Rammus" "Volteer" "Grunt" "Zork")
    else
    get_chrome_recoveries=($(curl https://cros-updates-serving.appspot.com/ | grep 'id="' | cut -d\" -f2 | sed -e s/cros-updates/remove-this/))
    fi
    ignored_recoveries='"hana" "daisy" "jaq" "minnie" "speedy" "peach" "trogdor" "elm" "kitty" "jacuzzi" "kukui" "skate" "kevin" "bob" "scarlet" "mickey" "falco" "mario" "alex" "ZGB" "Lumpy" "Stumpy" "parrot" "butterfly" "link" "stout" "snow" "beltino" "slippy" "rambi" "nyan" "banjo" "candy" "auron"'
    if [[ -n "$get_chrome_recoveries" ]] ; then
        for ((i = 0; i < ${#get_chrome_recoveries[@]}; ++i)); do
        if [[ "${get_chrome_recoveries[$i]}" == "remove-this" ]] ; then
            : # do nothing
        elif [[ "$ignored_recoveries" =~ "${get_chrome_recoveries[$i]}" ]] ; then
            : # do nothing
        elif [[ "${get_chrome_recoveries[$i]}" == "zork" ]]  ; then
            allrecoveries+=("${get_chrome_recoveries[$i]}")
            break # dont bother with outdated recoveries at the end of the list (starting after zork)
        else
            allrecoveries+=("${get_chrome_recoveries[$i]}")
        fi
        done
        for ((i = 0; i < ${#allrecoveries[@]}; ++i)); do
        if (( i < 10)) ; then
            allrecoveries_page1+=("${allrecoveries[$i]}")
        elif (( i < 20)) ; then
            allrecoveries_page2+=("${allrecoveries[$i]}")
        elif (( i < 30)) ; then
            allrecoveries_page3+=("${allrecoveries[$i]}")
        elif (( i < 40)) ; then
            allrecoveries_page4+=("${allrecoveries[$i]}")
        elif (( i < 50)) ; then
            allrecoveries_page5+=("${allrecoveries[$i]}")
        fi
    done
            current_page="1"
        long_recovery_menu
    else
         allrecoveries=("Rammus" "Volteer" "Grunt" "Zork")
         clear
         bento -t "Select a Recovery" -c "Please select which option you'd like to save as your preferred recovery." -m "${allrecoveries[@]}" div "Back" "Exit" -a -s "${allrecoveries[@]}" div "Go back to the previous page" "Exit without saving"
         case "$selection" in
             "Back") $previous_page ; return ;;
             "Exit") exit 0 ;;
             *) selected_recovery="$selection" ; selection_made="true" ; $previous_page ; return ;;
         esac
    fi
}

long_recovery_menu(){
    if [[ "$current_page" == "1" ]] ; then
        clear
        bento -t "Select a Recovery" -c "Please select which option you'd like to save as your preferred recovery." div "Page $current_page of 5" -m "${allrecoveries_page1[@]}" div "Next Page" "Previous Page" "Back" "Exit" -a -s "${allrecoveries_page1[@]}" div "See next set of recoveries" "See previous set of recoveries" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Back") $previous_page ; return ;;
            "Exit") exit 0 ;;
            "Next Page") current_page="2" ; long_recovery_menu ;;
            "Previous Page")  current_page="5" ; long_recovery_menu ;;
            *) selected_recovery="$selection" ; selection_made="true" ; $previous_page ; return ;;
        esac
    elif [[ "$current_page" == "2" ]] ; then
        clear
        bento -t "Select a Recovery" -c "Please select which option you'd like to save as your preferred recovery." div "Page $current_page of 5" -m "${allrecoveries_page2[@]}" div "Next Page" "Previous Page" "Back" "Exit" -a -s "${allrecoveries_page2[@]}" div "See next set of recoveries" "See previous set of recoveries" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Back") $previous_page ; return ;;
            "Exit") exit 0 ;;
            "Next Page") current_page="3" ; long_recovery_menu ;;
            "Previous Page")  current_page="1" ; long_recovery_menu ;;
            *) selected_recovery="$selection" ; selection_made="true" ; $previous_page ; return ;;
        esac
    elif [[ "$current_page" == "3" ]] ; then
        clear
        bento -t "Select a Recovery" -c "Please select which option you'd like to save as your preferred recovery." div "Page $current_page of 5" -m "${allrecoveries_page3[@]}" div "Next Page" "Previous Page" "Back" "Exit" -a -s "${allrecoveries_page3[@]}" div "See next set of recoveries" "See previous set of recoveries" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Back") $previous_page ; return ;;
            "Exit") exit 0 ;;
            "Next Page") current_page="4" ; long_recovery_menu ;;
            "Previous Page")  current_page="2" ; long_recovery_menu ;;
            *) selected_recovery="$selection" ; selection_made="true" ; $previous_page ; return ;;
        esac
    elif [[ "$current_page" == "4" ]] ; then
        clear
        bento -t "Select a Recovery" -c "Please select which option you'd like to save as your preferred recovery." div "Page $current_page of 5" -m "${allrecoveries_page4[@]}" div "Next Page" "Previous Page" "Back" "Exit" -a -s "${allrecoveries_page4[@]}" div "See next set of recoveries" "See previous set of recoveries" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Back") $previous_page ; return ;;
            "Exit") exit 0 ;;
            "Next Page") current_page="5" ; long_recovery_menu ;;
            "Previous Page")  current_page="3" ; long_recovery_menu ;;
            *) selected_recovery="$selection" ; selection_made="true" ; $previous_page ; return ;;
        esac
    elif [[ "$current_page" == "5" ]] ; then
        clear
        bento -t "Select a Recovery" -c "Please select which option you'd like to save as your preferred recovery." div "Page $current_page of 5" -m "${allrecoveries_page5[@]}" div "Next Page" "Previous Page" "Back" "Exit" -a -s "${allrecoveries_page5[@]}" div "See next set of recoveries" "See previous set of recoveries" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Back") $previous_page ; return ;;
            "Exit") exit 0 ;;
            "Next Page") current_page="1" ; long_recovery_menu ;;
            "Previous Page")  current_page="4" ; long_recovery_menu ;;
            *) selected_recovery="$selection" ; selection_made="true" ; $previous_page ; return ;;
        esac
    fi
}
#</>

#<~> Compatibility Check

# Define function to determine brunch compatibility & suggested recoveries
# Ideally this entire code can be safely incorperated into other scripts

quiet_compatibility_check(){
        cputype=$(cat /proc/cpuinfo | grep "model name" | head -1 | awk -F '[:]' '{print $2}')
        if [[ ! "$cputype" =~ .*"AMD".* ]] && [[ ! "$cputype" =~ .*"Intel".* ]]   ; then
            detected_recovery="unsupported"
        elif [[ "$cputype" =~ .*"AMD".* ]] ; then
            quietamdcpu
        elif [[ "$cputype" =~ .*"Intel".* ]] ; then
            quietintelcpu
        else
            detected_recovery="unsupported"
            bento -t "ERROR" -c "Something seems to have gone wrong, your cpu support could not be determined." "If you're seeing this error, please contact Wisteria on the Brunch Discord Server." -r
        fi
    }

quietamdcpu(){
        oldcpu=$(grep -Ewo 'sse4_2' /proc/cpuinfo  | sort | uniq)
        amdtype=$(cat /proc/cpuinfo | grep "[a|e][0-9]-9" | head -1 | awk -F '[:]' '{print $2}')
        if [[ "$cputype" =~ .*"yzen".* ]] ; then
            detected_recovery="zork"
        elif [[ "$cputype" =~ .*"$amdtype".* ]] ; then
            detected_recovery="grunt"
        elif [[ -z "$amdtype" ]] ; then
            detected_recovery="unsupported"
        else
            detected_recovery="unsupported"
            bento -t "ERROR" -c "Something seems to have gone wrong, your cpu support could not be determined." "If you're seeing this error, please contact Wisteria on the Brunch Discord Server." -r
        fi
    }

quietintelcpu(){
        newcpu=$(cat /proc/cpuinfo  | sed -e "s/G//g" | grep "i[3|5|7|9]-1[0-1][0-9][0-9][0-9]")
        oldcpu=$(grep -Ewo 'sse4_2' /proc/cpuinfo  | sort | uniq | sed -e 's/sse4_2/Rammus is suggested./g')
        if [ -z "$oldcpu" ] ; then
            detected_recovery="unsupported"
        elif [ -n "$oldcpu" ] && [ -z "$newcpu" ] ; then
            echo "$oldcpu"
            detected_recovery="rammus"
        elif [ -n "$newcpu" ] ; then
            detected_recovery="volteer"
        else
            detected_recovery="unsupported"
            bento -t "ERROR" -c "Something seems to have gone wrong, your cpu support could not be determined." "If you're seeing this error, please contact Wisteria on the Brunch Discord Server." -r
        fi
    }

#</>

#<~> Main Menu

main_menu_startup(){
    check_for_updates
    check_for_notifications
    set_main_menu_options
    check_for_announcements

    sed -i "s/current_brunch_version=.*/current_brunch_version=$current_brunch_version/" "$config_file"
    # Only display notifications if there are actually notifications.
    if [[ -n "$notify_content" ]] ; then
        header=("Brunch $current_brunch_version | Toolkit $toolkitversion" -c "Need help? Found a bug? Find me in the Brunch Discord! --Wisteria" "$discordinvite" div "${notify_content[@]}")
    else
        header=("Brunch $current_brunch_version | Toolkit $toolkitversion" -c "Need help? Found a bug? Find me in the Brunch Discord! --Wisteria" "$discordinvite")
    fi
    if [[ "$boxless" == "false" ]] ; then
        bento -g -t "${header[@]}"
    elif [[ -n "$notify_content" ]] && [[ "$boxless" == "true" ]] ; then
        bento -t "Brunch Toolkit $toolkitversion" -c div "${notify_content[@]}"
    elif [[ "$boxless" == "true" ]] ; then
        bento -t "Brunch Toolkit $toolkitversion"
    fi
    bento -n -c "Main Menu" -m "${main_menu_options[@]}" -s "${main_menu_options_subs[@]}" -a
    previous_menu="main_menu_startup"
    case "$selection" in
        "Exit") exit 0 ;;
        "Install Dependencies") dependency_search ; main_menu_startup ; return;;
        "Check for Updates") force_update="true" ; check_for_updates ; main_menu_startup ; return ;;
        "Update Toolkit") update_brunch_toolkit ; main_menu_startup ; return ;;
        "Brioche Options") brioche_menu ; return ;;
        "Bootscripts") bootscript_menu ; return ;;
        "Update Brunch Unstable") update_brunch_unstable ; main_menu_startup ; return ;;
        "Update Brunch") update_brunch ; main_menu_startup ; return ;;
        "Toolkit Settings") toolkit_settings_menu ; return ;;
        "Compatibility Check") loud_compatibility_check ; main_menu_startup ; return ;;
        "Compatibility Report") compatibility_report ; main_menu_startup ; return ;;
        "Advanced Options") advanced_options_menu ; main_menu_startup ; return ;;
        "Install Brunch") install_brunch ; main_menu_startup ; return ;;
        "Framework Options") framework_options ; main_menu_startup ; return ;;
        "Grub Options") grub_options_menu ; main_menu_startup ; return ;;
    esac
}

set_main_menu_options(){
    unset main_menu_options
    #Set according to the user's system and avaliability

    # Allow checking for updates manually if autocheck is disabled. if network is disabled, dont show any option
    if [[ "$onlineallowed" == "true" ]] && [[ ! "$autocheck" == "enabled" ]] ; then
        main_menu_options+=("Check for Updates")
        main_menu_options_subs+=("Check for Updates to Brunch or the Toolkit")
    fi
    # only show update option if an update is actually avaliable
    if [[ "$toolkit_mode" =~ "brunch" ]] && [[ "$stable_update" == "true" ]] && [[ ! "$update_complete" == "true" ]] ; then
        main_menu_options+=("Update Brunch")
        main_menu_options_subs+=("Update Brunch to the latest release")
    fi
    if [[ "$toolkit_mode" =~ "brunch" ]] && [[ "$unstable_update" == "true" ]] && [[ ! "$update_complete" == "true" ]] ; then
        main_menu_options+=("Update Brunch Unstable")
        main_menu_options_subs+=("Update Brunch to the latest unstable release")
    fi
    if [[ "$onlineallowed" == "true" ]] && [[ "$toolkit_update" == "true" ]] ; then
        main_menu_options+=("Update Toolkit")
        main_menu_options_subs+=("Update the Toolkit to the latest release")
    fi
    # prompt user to install dependencies if they havent been installed yet
    if [[ "$dependencies_installed" == "false" ]] ; then
        main_menu_options+=("Install Dependencies")
        main_menu_options_subs+=("Install required dependencies for Brunch")
    else
        main_menu_options+=("Install Brunch")
        main_menu_options_subs+=("Install Brunch to another disk")
    fi
    if [[ "$toolkit_mode" =~ "brunch" ]] ; then
        main_menu_options+=("Grub Options")
        main_menu_options_subs+=("Edit Grub Options")
        main_menu_options+=("Bootscripts")
        main_menu_options_subs+=("Add Bootscripts to Brunch")
        main_menu_options+=("Brioche Options")
        main_menu_options_subs+=("Explore Brioche settings")
        compatibility_option="Compatibility Report"
    else
        compatibility_option="Compatibility Check"
    fi
        main_menu_options+=("$compatibility_option")
        main_menu_options_subs+=("Open the $compatibility_option tool")
        if [[ "$advanced_options" == "enabled" ]] ; then
        main_menu_options+=("Advanced Options")
        main_menu_options_subs+=("Open Advanced Options")
        fi
        main_menu_options+=("Toolkit Settings")
        main_menu_options_subs+=("Open the Brunch Toolkit Settings")
        main_menu_options+=("Exit")
        main_menu_options_subs+=("Exit the Toolkit")
}
#</>

#<~> Grub Options
check_grub_format(){
    mount_grub
        # Look for the new flavor of grub, and adjust these variables as needed
        brunch_config="$HOME/tmp/brunch-workspace/efi/boot/settings.cfg"
        new_grub="true"
        if [[ ! -e "$brunch_config" ]] ; then
            brunch_config="$HOME/tmp/brunch-workspace/efi/boot/grub.cfg"
            new_grub="false"
        fi
          if (( $current_brunch_version < 20210621 )) && [[ "$toolkit_mode" == "brunch_dualboot" ]] ; then
            grub_editable="false"
        elif (( $current_brunch_version > 20210620 )) && [[ "$toolkit_mode" == "brunch_dualboot" ]] && [[ "$new_grub" == "false" ]] ; then
            grub_editable="false"
        elif (( $current_brunch_version > 20210620 )) && [[ "$toolkit_mode" == "brunch_dualboot" ]] && [[ "$new_grub" == "true" ]] ; then
            grub_editable="true"
        else
            grub_editable="true"
        fi
    unset brunch_framework_options
    unset brunch_brunch_bootsplash
    unset brunch_chromeos_bootsplash
    unset brunch_kernel_options
    unset brunch_cmdline_options
    unset avaliable_themes
    unset current_theme

    brunch_framework_options=($(cat "$brunch_config" | grep -m 1 "options=" | sed "s/.*options=//g" | cut -d' ' -f1 | sed "s/,/ /g"))
    brunch_framework_options_unfiltered=$(cat "$brunch_config" | grep -m 1 "options=" | sed "s/.*options=//g" | cut -d' ' -f1)
    brunch_brunch_bootsplash=$(cat "$brunch_config" | grep -m 1 "brunch_bootsplash=" | sed "s/.*brunch_bootsplash=//g" | cut -d' ' -f1)
    brunch_chromeos_bootsplash=$(cat "$brunch_config" | grep -m 1 "chromeos_bootsplash=" | sed "s/.*chromeos_bootsplash=//g" | cut -d' ' -f1)
    if [[ "$brunch_config" =~ "grub" ]] ; then
    brunch_kernel_option=$(cat "$brunch_config" | grep -m 1 "kernel" | sed "s/.*kernel/kernel/g" | cut -d' ' -f1)
    brunch_cmdline_options="Not Avaliable"
    elif [[ "$brunch_config" =~ "settings" ]] ; then
    brunch_kernel_option=$(cat "$brunch_config" | grep -m 1 "kernel=" | sed "s|.*kernel=||g" | cut -d' ' -f1)
    brunch_cmdline_options=$(cat "$brunch_config" | grep -m 1 "cmdline_params=" | sed "s/.*cmdline_params=//g" | cut -d' ' -f1)
    fi
    if [[ "$brunch_kernel_option" == "kernel" ]] ; then
        brunch_kernel_option="kernel-5.4"
    fi
    unmount_grub
}

    grub_options_menu(){
        previous_menu="main_menu_startup"
    check_for_dualboot
    check_grub_format
if [[ -z "$brunch_editor" ]] ; then
    brunch_editor="nano"
fi
    unset grub_opts
    grub_opts=(
        "Framework Options"
        "ChromeOS Boot Animation"
    )

    grub_subs=(
        "Toggle Framework Options"
        "Change ChromeOS boot Animation"
    )

    toolchain_installed=$(command -v start-toolchain 2>&1)
    if [[ -n "$toolchain_installed" ]] ; then
        grub_opts+=("Brunch Bootsplash")
        grub_subs+=("Change Brunch bootsplash")
    fi

    if [[ ! "$toolkit_mode" =~ "dualboot" ]] ; then
        grub_opts+=(
        "Grub Themes")
        grub_subs+=("Change grub themes")
    fi
    #if [[ "$new_grub" == "true" ]] ; then
    #    grub_opts+=(
    #    "Commandline Parameters      [Coming Soon!]")
    #    grub_subs+=("Add commandline parameters")
    #fi
    if (( $current_brunch_version > 20201215 )) ; then
        grub_opts+=("Kernel Options")
        grub_subs+=("Swap between kernels")
    fi
    if [[ "$advanced_options" == "enabled" ]] ; then
        grub_opts+=("Edit Grub Manually")
        grub_subs+=("Open Brunch's Grub config in $brunch_editor")
        grub_opts+=("Change editor (Currently $brunch_editor)")
        grub_subs+=("Toggle which editor you'd like to use")
    fi

    if [[ "$grub_editable" == "false" ]] ; then
        bento -t "Grub Options" -c "Grub options are not currently avaliable to your install." "Edit grub from the other OS you're dualbooting with." -r
    else
        bento -t "Grub Options" -c "Modify grub related options." -a -m "${grub_opts[@]}" "Back" "Exit" -s "${grub_subs[@]}"  "Go back to the previous menu" "Exit the toolkit"
    fi
        case "$selection" in
            "Exit") exit 0 ;;
            "Back") $previous_menu ;;
            "Framework Options") framework_options ; grub_options_menu ; return ;;
            "Kernel Options") kernel_options ; grub_options_menu ; return ;;
            "Brunch Bootsplash") bootsplash_engine ; grub_options_menu ; return ;;
            "Grub Themes") theme_engine ; grub_options_menu ; return ;;
            "ChromeOS Boot Animation") boot_anim_engine ; grub_options_menu ; return ;;
            "Edit Grub Manually") edit_grub_config ; grub_options_menu ; return ;;
            "Change editor (Currently $brunch_editor)")
                                                    if [[ "$brunch_editor" == "nano" ]] ; then
                                                        brunch_editor="vi"
                                                    else
                                                        brunch_editor="nano"
                                                    fi
                                                    sed -i "s/brunch_editor=.*/brunch_editor=$brunch_editor/" "$config_file"
                                                    grub_options_menu ; return ;;
        esac
    }
#</>

#<~> Brunch Bootsplash
bootsplash_engine(){
        previous_menu="grub_options_menu"
        check_grub_format
        unpack_initramfs
        dont_include_default="false"
        get_bbs_from_initramfs
        unmount_grub
        remove_initramfs
        bento -t "Brunch Bootsplash" -c "Current Bootsplash: $brunch_brunch_bootsplash" -m "${bbs_options[@]}" div "Install Bootsplash" "Remove Bootsplash" "Back" "Exit" -s "${bbs_options_sub[@]}" div "Install a new bootsplash" "Remove an installed bootsplash" "Go back to the previous menu" "Exit the toolkit" -a
        if [[ "$selection" =~ (◆|◯) ]] ; then
            selection=${selection:4}
        fi
            case "$selection" in
                "Exit")  exit 0 ;;
                "Back")  $previous_menu ;;
                "Install Bootsplash") zip_mode="bbs" ; find_images zip ; bootsplash_installer ; bootsplash_engine ;;
                "Remove Bootsplash") bootsplash_remover ; bootsplash_engine ;;
                *) bootsplash_changer ; bootsplash_engine ;;
            esac
}

bootsplash_installer(){
    previous_menu="bootsplash_engine"
            if [[ "$scaling" == "fit" ]] ; then
                    scaling_tip="Fits the image to the canvas as well as it can. Quality may be lost at the risk of fitting the canvas as well as possible."
            elif [[ "$scaling" == "shrink" ]] ; then
                scaling_tip="Shrinks the image and tries to render a background automatically based on the top-left pixel. This is great for turning large images into centered icons"
            else
                scaling="center"
                scaling_tip="Centers the image and tries to render a background automatically based on the top-left pixel. Select this if your image is the right size already to preserve scale."
            fi
            if [[ -z "$test_convert" ]] ; then
                test_convert="disabled"
            fi
    if (( $page_number == 5 )) ; then
        bento -t "Brunch Bootsplash" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split" "This is the maximum number of images the toolkit can show currently." -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page5[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs5[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 4 )) ; then
        bento -t "Brunch Bootsplash" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page4[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs4[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 3 )) ; then
        bento -t "Brunch Bootsplash" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page3[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled."  div "${found_images_subs3[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 2 )) ; then
        bento -t "Brunch Bootsplash" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page2[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs2[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    else
        page_number=1
        bento -t "Brunch Bootsplash" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page1[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs1[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    fi
        case "$selection" in
            "Exit") exit 0 ;;
            "Back") $previous_menu ;;
            "Image Scaling Method: ${scaling^}") toggle_scaling_method ; bootsplash_installer ;;
            "Preview Image Conversion: ${test_convert^}") toggle_test_convert ; bootsplash_installer ;;
            "Next Page") page_number=$(( page_number + 1 )) ; bootsplash_installer ;;
            "First Page") page_number=1 ; bootsplash_installer ;;
            "Last Page") page_number=$(( page_number - 1 )) ; bootsplash_installer ;;
            *)
                if [[ "$test_convert" == "enabled" ]] ; then
                    bootsplash_installer_sub_debug
                    bootsplash_installer
                else
                    bootsplash_installer_sub
                    bootsplash_engine
                fi ;;
        esac

}


bootsplash_installer_sub_debug(){
    target_img="main.png"
    image_converter
    sudo cp -r ~/tmp/brunch-image_converter/$target_img "$downloads"/results.png
}

bootsplash_installer_sub(){
    target_img="main.png"
    image_converter
    get_bootsplash_name
    check_grub_format
    unpack_initramfs
    # Make a folder for the new theme
    sudo mkdir -p "$HOME/tmp/brunch-initramfs/bootsplash/$bootsplash_name"
    # Copy the new bootsplash images over
    if [[ "$file_is_zip" == "true" ]] ; then
        sudo cp -r ~/tmp/brunch-image_converter/*.png "$HOME/tmp/brunch-initramfs/bootsplash/$bootsplash_name/"
    else
        bbs_outputs=("main.png" "rebuilding.png" "patching.png" "incompatible.png")
        for elem in "${bbs_outputs[@]}" ; do
            sudo cp -r ~/tmp/brunch-image_converter/main.png "$HOME/tmp/brunch-initramfs/bootsplash/$bootsplash_name/$elem"
        done
    fi
    repack_initramfs
    unmount_grub
    rm -rf ~/tmp/brunch-image_converter
    mount_grub
    sudo sed -i "s/brunch_bootsplash=$brunch_brunch_bootsplash/brunch_bootsplash=$bootsplash_name/" "$brunch_config"
    unmount_grub
}


get_bootsplash_name(){
    if [[ "$name_warning" == "true" ]] ; then
    bento -t "Brunch Bootsplash" -c "Selected image: $source_img" " " "Input a name for this bootsplash, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed."
    bento -n -c "Previous input: $selection" "Input contains a disallowed character, try again." -w
    else
    bento -t "Brunch Bootsplash" -c "Selected image: $source_img" " " "Input a name for this bootsplash, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed." -w
    fi
    if [[ "$selection" =~ ['!@#$%^&*()+'] ]] || [[ "$selection" == *" "* ]] ; then
        name_warning="true"
        get_boot_anim_name
    else
        name_warning="false"
        bootsplash_name="$selection"
    fi
}

bootsplash_remover(){
    previous_menu="bootsplash_engine"
    check_grub_format
    unpack_initramfs
    dont_include_default="true"
    get_bbs_from_initramfs
    unmount_grub
    remove_initramfs
    if [[ -z "$bbs_options" ]] ; then
        bootsplash_engine
    else
        bento -t "Brunch Bootsplash" -c "Current Bootsplash: $brunch_brunch_bootsplash" -m "${bbs_options[@]}" div "Back" "Exit" -s "${bbs_options_sub[@]}" div "Go back to the previous menu" "Exit the toolkit" -a
    fi
            if [[ "$selection" =~ (◆|◯) ]] ; then
                selection=${selection:4}
            fi
                case "$selection" in
                    "Exit") exit 0 ;;
                    "Back") $previous_menu ;;
                    *) bootsplash_remover_sub ; bootsplash_remover ;;
                esac
}

bootsplash_remover_sub(){
    check_grub_format
    unpack_initramfs
    sudo rm -rf "$HOME/tmp/brunch-initramfs/bootsplash/$selection"
    bento -c "Repacking initramfs, please wait..."
    repack_initramfs
    unmount_grub
    remove_initramfs
    if [[ "$selection" == "$brunch_brunch_bootsplash" ]] ; then
        mount_grub
        sudo sed -i "s/brunch_bootsplash=$brunch_brunch_bootsplash/brunch_bootsplash=default/" "$brunch_config"
        unmount_grub
    fi
}

bootsplash_changer(){
    mount_grub
    sudo sed -i "s/brunch_bootsplash=$brunch_brunch_bootsplash/brunch_bootsplash=$selection/" "$brunch_config"
    unmount_grub
}

unpack_initramfs(){
    if [[ ! "$initramfs_unpacked" == "true" ]] ; then
        mkdir -p ~/tmp/brunch-workspace
        mkdir -p ~/tmp/brunch-initramfs
        sudo mount "$partsource"7 ~/tmp/brunch-workspace
        curdir=$(pwd)
        bento -c "Unpacking initramfs, please wait..."
        cd ~/tmp/brunch-initramfs && zcat ~/tmp/brunch-workspace/initramfs.img | cpio -i
        cd "$curdir"
        initramfs_unpacked="true"
    fi
}

get_bbs_from_initramfs(){
    curdir=$(pwd)
    cd ~/tmp/brunch-initramfs/bootsplash
    unset bbs_options
    unset bbs_options_sub
    if [[ -z "$dont_include_default" ]] || [[ "$dont_include_default" == "false" ]]  ; then
        dont_include_default="false"
    else
        dont_include_default="true"
    fi
    while IFS=  read -r -d $'\0'; do
        if [[ ! "$REPLY" =~ " " ]] ; then
            REPLY="${REPLY:2}"
            if [[ "$dont_include_default" == "false" ]] ; then
                if [[ "$REPLY" == "$brunch_brunch_bootsplash" ]] ; then
                    bbs_options+=("◆ $REPLY")
                else
                    bbs_options+=("◯ $REPLY")
                fi
                    bbs_options_sub+=("Switch to $REPLY")
            elif [[ "$dont_include_default" == "true" ]] && [[ ! "$REPLY" == "default" ]] && [[ ! "$REPLY" == "default_notext" ]] ; then
                if [[ "$REPLY" == "$brunch_brunch_bootsplash" ]] ; then
                    bbs_options+=("◆ $REPLY")
                else
                    bbs_options+=("◯ $REPLY")
                fi
                    bbs_options_sub+=("Switch to $REPLY")
            fi
        fi
    done < <(find . -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
    cd "$curdir"
}

repack_initramfs(){
    curdir=$(pwd)
    cd ~/tmp/brunch-initramfs && find . | cpio -o -H newc | gzip | sudo tee ~/tmp/brunch-workspace/initramfs.img > /dev/null
    cd "$curdir"
    unmount_grub
    remove_initramfs
}

remove_initramfs(){
    # this just cleans the local directory, might do other things later
    initramfs_unpacked="false"
    sudo rm -rf ~/tmp/brunch-initramfs/*
}
#</>

#<~> ChromeOS Boot Animation
boot_anim_engine(){
    previous_menu="grub_options_menu"
    check_grub_format
    # Make this directory if it doesnt already exist
    sudo mkdir -p /mnt/stateful_partition/unencrypted/bootsplash/
    # Look inside to see if boot animations exist
    unset cba_options
    unset cba_options_sub
    curdir=$(pwd)
    cd /mnt/stateful_partition/unencrypted/bootsplash/
    while IFS=  read -r -d $'\0'; do
        if [[ ! "$REPLY" =~ " " ]] ; then
            REPLY="${REPLY:2}"
            if [[ "$REPLY" == "$brunch_chromeos_bootsplash" ]] && [[ ! -z "$brunch_chromeos_bootsplash" ]] ; then
            cba_options+=("◆ $REPLY")
            else
            cba_options+=("◯ $REPLY")
            fi
            cba_options_sub+=("Switch to $REPLY")
        fi
    done < <(find . -mindepth 1 -maxdepth 1 -type d -print0)
    cd "$curdir"
    if [[ -z "$cba_options" ]] ; then
        bento -t "ChromeOS Boot Animation" -c "No boot animation detected!" -m "Install Boot Animation" "Back" "Exit" -s "Install a new boot animation" "Go back to the previous menu" "Exit the toolkit" -a

    else
        bento -t "ChromeOS Boot Animation" -c "Current Boot Animation: $brunch_chromeos_bootsplash" -m "${cba_options[@]}" div "Install Boot Animation" "Remove Boot Animation" "Back" "Exit" -s "${cba_options_sub[@]}" div "Install a new boot animation" "Remove an installed boot animation" "Go back to the previous menu" "Exit the toolkit" -a
    fi
    if [[ "$selection" =~ (◆|◯) ]] ; then
        selection=${selection:4}
    fi
        case "$selection" in
            "Exit") unmount_grub ; exit 0 ;;
            "Back") $previous_menu ;;
            "Install Boot Animation") zip_mode="cba" ; find_images zip ; boot_anim_installer ; boot_anim_engine ;;
            "Remove Boot Animation") boot_anim_remover ; boot_anim_engine ;;
            *) boot_anim_changer ; boot_anim_engine ;;
        esac
}

boot_anim_installer(){
        previous_menu="boot_anim_engine"
        if [[ "$scaling" == "fit" ]] ; then
                scaling_tip="Fits the image to the canvas as well as it can. Quality may be lost at the risk of fitting the canvas as well as possible."
        elif [[ "$scaling" == "shrink" ]] ; then
            scaling_tip="Shrinks the image and tries to render a background automatically based on the top-left pixel. This is great for turning large images into centered icons"
        else
            scaling="center"
            scaling_tip="Centers the image and tries to render a background automatically based on the top-left pixel. Select this if your image is the right size already to preserve scale."
        fi
        if [[ -z "$test_convert" ]] ; then
            test_convert="disabled"
        fi
if (( $page_number == 5 )) ; then
    bento -t "ChromeOS Boot Animation" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split" "This is the maximum number of images the toolkit can show currently." -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page5[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs5[@]}" "Go back to the previous menu" "Exit the toolkit" -a
elif (( $page_number == 4 )) ; then
    bento -t "ChromeOS Boot Animation" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page4[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs4[@]}" "Go back to the previous menu" "Exit the toolkit" -a
elif (( $page_number == 3 )) ; then
    bento -t "ChromeOS Boot Animation" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page3[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled."  div "${found_images_subs3[@]}" "Go back to the previous menu" "Exit the toolkit" -a
elif (( $page_number == 2 )) ; then
    bento -t "ChromeOS Boot Animation" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page2[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs2[@]}" "Go back to the previous menu" "Exit the toolkit" -a
else
    page_number=1
    bento -t "ChromeOS Boot Animation" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page1[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs1[@]}" "Go back to the previous menu" "Exit the toolkit" -a
fi
    case "$selection" in
        "Exit") unmount_grub ; exit 0 ;;
        "Back") unmount_grub ; $previous_menu ;;
        "Image Scaling Method: ${scaling^}") toggle_scaling_method ; boot_anim_installer ;;
        "Preview Image Conversion: ${test_convert^}") toggle_test_convert ; boot_anim_installer ;;
        "Next Page") page_number=$(( page_number + 1 )) ; boot_anim_installer ;;
        "First Page") page_number=1 ; boot_anim_installer ;;
        "Last Page") page_number=$(( page_number - 1 )) ; boot_anim_installer ;;
        *)
            if [[ "$test_convert" == "enabled" ]] ; then
                boot_anim_installer_sub_debug
                boot_anim_installer
            else
                boot_anim_installer_sub
                boot_anim_engine
            fi ;;
    esac
}


boot_anim_installer_sub_debug(){
    target_img="boot_splash_frame01.png"
    image_converter
    sudo cp -r ~/tmp/brunch-image_converter/boot_splash_frame01.png "$downloads"/results.png
    rm -rf ~/tmp/brunch-image_converter
}

boot_anim_installer_sub(){
    target_img="boot_splash_frame01.png"
    image_converter
    # Check if the selection was a zip or not
    # If the selection was not a zip, split t into frames
    if [[ "$file_is_zip" == "false" ]] ; then
    bento -c "Building Boot Animation, please wait..."
        for i in {2..9} ; do
            cp boot_splash_frame01.png boot_splash_frame0$i.png
        done
        for i in {10..13} ; do
            cp boot_splash_frame01.png boot_splash_frame$i.png
        done
    fi
    get_boot_anim_name
    mount_grub
    # Make a folder for the new animation
    sudo mkdir -p /mnt/stateful_partition/unencrypted/bootsplash/"$boot_anim_name"/images_100_percent
    sudo mkdir -p /mnt/stateful_partition/unencrypted/bootsplash/"$boot_anim_name"/images_200_percent
    # Copy the new animation over
    sudo cp -r ~/tmp/brunch-image_converter/boot_splash_frame*.png /mnt/stateful_partition/unencrypted/bootsplash/"$boot_anim_name"/images_100_percent
    sudo cp -r ~/tmp/brunch-image_converter/boot_splash_frame*.png /mnt/stateful_partition/unencrypted/bootsplash/"$boot_anim_name"/images_200_percent
    # clean up
    rm -rf ~/tmp/brunch-image_converter
    # set the grub variable
    sudo sed -i "s/chromeos_bootsplash=$brunch_chromeos_bootsplash/chromeos_bootsplash=$boot_anim_name/" "$brunch_config"
    unmount_grub
}


get_boot_anim_name(){
    if [[ "$name_warning" == "true" ]] ; then
    bento -t "ChromeOS Boot Animation" -c "Input a name for this boot animation, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed."
    bento -n -c "Previous input: $selection" "Input contains a disallowed character, try again." -w
    else
    bento -t "ChromeOS Boot Animation" -c "Input a name for this boot animation, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed." -w
    fi
    if [[ "$selection" =~ ['!@#$%^&*()+'] ]] || [[ "$selection" == *" "* ]] ; then
        name_warning="true"
        get_boot_anim_name
    else
        name_warning="false"
        boot_anim_name="$selection"
    fi
}

boot_anim_remover(){
        previous_menu="boot_anim_engine"
        check_grub_format
        # Make this directory if it doesnt already exist
        sudo mkdir -p /mnt/stateful_partition/unencrypted/bootsplash/
        # Look inside to see if boot animations exist
        unset cba_options
        unset cba_options_sub
        curdir=$(pwd)
        cd /mnt/stateful_partition/unencrypted/bootsplash/
        while IFS=  read -r -d $'\0'; do
            if [[ ! "$REPLY" =~ " " ]] ; then
                REPLY="${REPLY:2}"
                if [[ "$REPLY" == "$brunch_chromeos_bootsplash" ]] && [[ ! -z "$brunch_chromeos_bootsplash" ]] ; then
                cba_options+=("◆ $REPLY")
                else
                cba_options+=("◯ $REPLY")
                fi
                cba_options_sub+=("Remove $REPLY")
            fi
        done < <(find . -mindepth 1 -maxdepth 1 -type d -print0)
        cd "$curdir"
        if [[ -z "$cba_options" ]] || [[ -z "$brunch_chromeos_bootsplash" ]] ; then
            boot_anim_engine
        else
            bento -t "ChromeOS Boot Animation" -c "Current Boot Animation: $brunch_chromeos_bootsplash" -m "${cba_options[@]}" div "Back" "Exit" -s "${cba_options_sub[@]}" div "Go back to the previous menu" "Exit the toolkit" -a
        fi
                if [[ "$selection" =~ (◆|◯) ]] ; then
                    selection=${selection:4}
                fi
                    case "$selection" in
                        "Exit") unmount_grub ; exit 0 ;;
                        "Back") $previous_menu ;;
                        *) boot_anim_remover_sub ; boot_anim_remover ;;
                    esac
}

boot_anim_remover_sub(){
    mount_grub
    sudo rm -rf "/mnt/stateful_partition/unencrypted/bootsplash/$selection"
    if [[ "$selection" == "$brunch_chromeos_bootsplash" ]] ; then
        sudo sed -i "s/chromeos_bootsplash=$brunch_chromeos_bootsplash/chromeos_bootsplash=/" "$brunch_config"
    fi
    unmount_grub
}

boot_anim_changer(){
    mount_grub
    sudo sed -i "s/chromeos_bootsplash=$brunch_chromeos_bootsplash/chromeos_bootsplash=$selection/" "$brunch_config"
    unmount_grub
}
#</>

#<~> Grub Themes
    theme_engine(){
        previous_menu="grub_options_menu"
        mount_grub
            theme_config="$HOME/tmp/brunch-workspace/efi/boot/theme.cfg"
            curdir=$(pwd)
            cd "$HOME/tmp/brunch-workspace/efi/boot/themes"
            current_theme=$(cat "$theme_config" | grep -m 1 "grub_theme=" | sed "s/.*grub_theme=//g")
            unset avaliable_themes
            unset avaliable_themes_subs
            while IFS=  read -r -d $'\0'; do
                if [[ ! "$REPLY" =~ " " ]] ; then
                    REPLY="${REPLY:2}"
                if [[ ! "$REPLY" == "default" ]] ; then
                    if [[ "$REPLY" == "$current_theme" ]] ; then
                    avaliable_themes+=("◆ $REPLY")
                    else
                    avaliable_themes+=("◯ $REPLY")
                    fi
                    avaliable_themes_subs+=("Switch to $REPLY")
                fi
                fi
            done < <(find . -mindepth 1 -maxdepth 1 -type d -print0)
            cd "$curdir"
        unmount_grub

        bento -t "Grub Themes" -c "Current theme: $current_theme" -m "${avaliable_themes[@]}" div "Install New Theme" "Remove a Theme" "Back" "Exit" -s "${avaliable_themes_subs[@]}" div "Add a new theme to choose from" "Remove a theme from the selection" "Go back to the previous menu" "Exit the toolkit" -a
        if [[ "$selection" =~ (◆|◯) ]] ; then
            selection=${selection:4}
        fi
            case "$selection" in
                "Exit") unmount_grub ; exit 0 ;;
                "Back") unmount_grub ; $previous_menu ;;
                "Install New Theme") find_images ; theme_installer ; theme_engine ;;
                "Remove a Theme") theme_remover ; theme_engine ;;
                *) theme_changer ; theme_engine ;;
            esac
    }

theme_changer(){
    mount_grub
    sudo sed -i "s/grub_theme=$current_theme/grub_theme=$selection/" "$theme_config"
    unmount_grub
}


theme_remover(){
        previous_menu="theme_engine"
        mount_grub
            theme_config="$HOME/tmp/brunch-workspace/efi/boot/theme.cfg"
            curdir=$(pwd)
            cd "$HOME/tmp/brunch-workspace/efi/boot/themes"
            current_theme=$(cat "$theme_config" | grep -m 1 "grub_theme=" | sed "s/.*grub_theme=//g")
            unset avaliable_themes
            unset avaliable_themes_subs
            while IFS=  read -r -d $'\0'; do
                if [[ ! "$REPLY" =~ " " ]] ; then
                    REPLY="${REPLY:2}"
                    if [[ ! "$REPLY" == "default" ]] ; then
                        if [[ "$REPLY" == "$current_theme" ]] ; then
                            avaliable_themes+=("◆ $REPLY")
                        else
                            avaliable_themes+=("◯ $REPLY")
                        fi
                    avaliable_themes_subs+=("Remove $REPLY from avaliable themes")
                    fi
                fi
            done < <(find . -mindepth 1 -maxdepth 1 -type d -print0)
            cd "$curdir"
        unmount_grub

        bento -t "Grub Themes" -c "Select a theme to remove" "" "Current theme: $current_theme" -m "${avaliable_themes[@]}" div "Back" "Exit" -s "${avaliable_themes_subs[@]}" div "Go back to the previous menu" "Exit the toolkit" -a
        if [[ "$selection" =~ (◆|◯) ]] ; then
            selection=${selection:4}
        fi
            case "$selection" in
                "Exit") unmount_grub ; exit 0 ;;
                "Back") $previous_menu ;;
                *) theme_remover_sub ; theme_remover ;;
            esac
}

theme_remover_sub(){
    mount_grub
    sudo rm -rf "$HOME/tmp/brunch-workspace/efi/boot/themes/$selection"
    if [[ "$selection" == "$current_theme" ]] ; then
        sudo sed -i "s/grub_theme=$current_theme/grub_theme=default/" "$theme_config"
    fi
    unmount_grub
}

theme_installer(){
    previous_menu="theme_engine"
    if [[ "$scaling" == "fit" ]] ; then
            scaling_tip="Fits the image to the canvas as well as it can. Quality may be lost at the risk of fitting the canvas as well as possible."
    elif [[ "$scaling" == "shrink" ]] ; then
        scaling_tip="Shrinks the image and tries to render a background automatically based on the top-left pixel. This is great for turning large images into centered icons"
    else
        scaling="center"
        scaling_tip="Centers the image and tries to render a background automatically based on the top-left pixel. Select this if your image is the right size already to preserve scale."
    fi
    if [[ -z "$test_convert" ]] ; then
        test_convert="disabled"
    fi

    if (( $page_number == 5 )) ; then
        bento -t "Grub Themes" -c "Select an image to use for Grub" div "Page $page_number of $total_images_split" "This is the maximum number of images the toolkit can show currently." -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page5[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs5[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 4 )) ; then
        bento -t "Grub Themes" -c "Select an image to use for Grub" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page4[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs4[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 3 )) ; then
        bento -t "Grub Themes" -c "Select an image to use for Grub" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page3[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled."  div "${found_images_subs3[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 2 )) ; then
        bento -t "Grub Themes" -c "Select an image to use for Grub" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page2[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs2[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    else
        page_number=1
        bento -t "Grub Themes" -c "Select an image to use for Grub" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page1[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs1[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    fi
        case "$selection" in
            "Exit") unmount_grub ; exit 0 ;;
            "Back") $previous_menu ;;
            "Image Scaling Method: ${scaling^}") toggle_scaling_method ; theme_installer ;;
            "Preview Image Conversion: ${test_convert^}") toggle_test_convert ; theme_installer ;;
            "Next Page") page_number=$(( page_number + 1 )) ; theme_installer ;;
            "First Page") page_number=1 ; theme_installer ;;
            "Last Page") page_number=$(( page_number - 1 )) ; theme_installer ;;
            *)
                if [[ "$test_convert" == "enabled" ]] ; then
                    theme_installer_sub_debug
                    theme_installer
                else
                    theme_installer_sub
                    theme_engine
                fi ;;
        esac
}

toggle_scaling_method(){
    if [[ "$scaling" == "fit" ]] ; then
        scaling="shrink"
    elif [[ "$scaling" == "shrink" ]] ; then
        scaling="center"
    else
        scaling="fit"
    fi
        sed -i "s/scaling=.*/scaling=$scaling/" "$config_file"
}

toggle_test_convert(){
    if [[ "$test_convert" == "enabled" ]] ; then
        test_convert="disabled"
    else
        test_convert="enabled"
    fi
}

theme_installer_sub_debug(){
    target_img="background.png"
    image_converter
    sudo cp -r ~/tmp/brunch-image_converter/$target_img "$downloads"/results.png
}

theme_installer_sub(){
    target_img="background.png"
    image_converter
    get_theme_name
    mount_grub
    # Make a folder for the new theme
    sudo mkdir -p "$HOME/tmp/brunch-workspace/efi/boot/themes/$theme_name"
    # Copy over the default theme's assets
    sudo cp -r "$HOME/tmp/brunch-workspace/efi/boot/themes/default/." "$HOME/tmp/brunch-workspace/efi/boot/themes/$theme_name"
    # Copy the new background image over
    sudo cp -r ~/tmp/brunch-image_converter/$target_img "$HOME/tmp/brunch-workspace/efi/boot/themes/$theme_name/$target_img"
    rm -rf ~/tmp/brunch-image_converter
    sudo sed -i "s/grub_theme=$current_theme/grub_theme=$theme_name/" "$theme_config"
    unmount_grub
}

get_theme_name(){
    if [[ "$name_warning" == "true" ]] ; then
    bento -t "Grub Themes" -c "Selected image: $source_img" " " "Input a name for this theme, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed."
    bento -n -c "Previous input: $selection" "Input contains a disallowed character, try again." -w
    else
    bento -t "Grub Themes" -c "Selected image: $source_img" " " "Input a name for this theme, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed." -w
    fi
    if [[ "$selection" =~ ['!@#$%^&*()+'] ]] || [[ "$selection" == *" "* ]] ; then
        name_warning="true"
        get_theme_name
    else
        name_warning="false"
        theme_name="$selection"
    fi
}
#</>

#<~> ImageMagick Functions

#<~> Image finder
find_images(){
        curdir=$(pwd)
        cd "$downloads"
        page_number=1
        unset found_images
        unset found_images_subs
        unset found_images_page1
        unset found_images_subs1
        unset found_images_page2
        unset found_images_subs2
        unset found_images_page3
        unset found_images_subs3
        unset found_images_page4
        unset found_images_subs4
        unset found_images_page5
        unset found_images_subs5
        # Find files and sort by extention
    if [[ "$1" == "zip" ]] ; then
        while IFS=  read -r -d $'\0'; do
            prefix="${REPLY:2:2}"
            if [[ ! "$REPLY" =~ " " ]] && [[ ! "$prefix" == '._' ]] && [[ ! "$prefix" == '--' ]]; then
                found_images+=("${REPLY:2}")
                found_images_subs+=("Select ${REPLY:2}")
            fi
        done < <(find . -mindepth 1 -maxdepth 1 -regex '.*\.\(zip\|png\|jpg\|jpeg\)' -print0 | sort -z)
    else
        while IFS=  read -r -d $'\0'; do
            prefix="${REPLY:2:2}"
            if [[ ! "$REPLY" =~ " " ]] && [[ ! "$prefix" == '._' ]] && [[ ! "$prefix" == '--' ]]; then
                found_images+=("${REPLY:2}")
                found_images_subs+=("Select ${REPLY:2}")
            fi
        done < <(find . -mindepth 1 -maxdepth 1 -regex '.*\.\(png\|jpg\|jpeg\)' -print0)
    fi
        cd "$curdir"
        #theme_installer_sub
        total_images="${#found_images[@]}"
        if (( "$total_images" > 10 )) ; then
            total_images_split=$((( total_images / 10 ) + ( total_images % 10 > 0 )))
            i=1
            while (($i <= $total_images_split)) ; do
                # only do 5 loops max for a total of 50 images
                if (( $i == 1 )) ; then
                    for x in {1..10} ; do
                        if [[ ! -z "${found_images[$x]}" ]] ; then
                        found_images_page1+=("${found_images[$x]}")
                        found_images_subs1+=("${found_images_subs[$x]}")
                        fi
                    done
                        found_images_page1+=('div')
                        found_images_subs1+=('div')
                    if [[ ! -z "${found_images[11]}" ]] ; then
                        found_images_page1+=('Next Page')
                        found_images_subs1+=('Go to the next page')
                    fi
                fi
                if (( $i == 2 )) ; then
                    for x in {11..20} ; do
                        if [[ ! -z "${found_images[$x]}" ]] ; then
                        found_images_page2+=("${found_images[$x]}")
                        found_images_subs2+=("${found_images_subs[$x]}")
                    fi
                    done
                        found_images_page2+=('div')
                        found_images_subs2+=('div')
                    if [[ ! -z "${found_images[21]}" ]] ; then
                        found_images_page2+=('Next Page')
                        found_images_subs2+=('Go to the next page')
                        found_images_page2+=('Last Page')
                        found_images_subs2+=('Go to the last page')
                    else
                        found_images_page2+=('First Page')
                        found_images_subs2+=('Go to the first page')
                    fi
                fi
                if (( $i == 3 )) ; then
                    for x in {21..30} ; do
                        if [[ ! -z "${found_images[$x]}" ]] ; then
                        found_images_page3+=("${found_images[$x]}")
                        found_images_subs3+=("${found_images_subs[$x]}")
                    fi
                    done
                        found_images_page3+=('div')
                        found_images_subs3+=('div')
                    if [[ ! -z "${found_images[31]}" ]] ; then
                        found_images_page3+=('Next Page')
                        found_images_subs3+=('Go to the next page')
                    else
                        found_images_page3+=('First Page')
                        found_images_subs3+=('Go to the first page')
                    fi
                        found_images_page3+=('Last Page')
                        found_images_subs3+=('Go to the last page')
                fi
                if (( $i == 4 )) ; then
                    for x in {31..40} ; do
                        if [[ ! -z "${found_images[$x]}" ]] ; then
                        found_images_page4+=("${found_images[$x]}")
                        found_images_subs4+=("${found_images_subs[$x]}")
                    fi
                    done
                        found_images_page4+=('div')
                        found_images_subs4+=('div')
                    if [[ ! -z "${found_images[41]}" ]] ; then
                        found_images_page4+=('Next Page')
                        found_images_subs4+=('Go to the next page')
                    else
                        found_images_page4+=('First Page')
                        found_images_subs4+=('Go to the first page')
                    fi
                        found_images_page4+=('Last Page')
                        found_images_subs4+=('Go to the last page')
                fi
                if (( $i == 5 )) ; then
                    for x in {41..50} ; do
                        if [[ ! -z "${found_images[$x]}" ]] ; then
                        found_images_page5+=("${found_images[$x]}")
                        found_images_subs5+=("${found_images_subs[$x]}")
                    fi
                    done
                        found_images_page5+=('div')
                        found_images_subs5+=('div')
                        found_images_page5+=('First Page')
                        found_images_subs5+=('Go to the first page')
                        found_images_page5+=('Last Page')
                        found_images_subs5+=('Go to the last page')
                fi
                i=$((i + 1))
            done
        else
            for elem in "${found_images[@]}" ; do
                found_images_page1+=("$elem")
            done
            for elem in "${found_images_subs[@]}" ; do
                found_images_subs1+=("$elem")
            done
                found_images_page1+=('div')
                found_images_subs1+=('div')
            total_images_split=1
        fi
        if (( "$total_images_split" > 5 )) ; then
            total_images_split=5
        fi
}
#</>

get_screen_size(){
    previous_menu="theme_installer"
    gsc_width
    previous_menu="gsc_width"
    gsc_height
    previous_menu="theme_installer"
    bento -t "Grub Themes" -c "Your screen's dimensions are $width x $height" "Is this correct?" -m "Yes - Save as default" "Yes - Don't save as default" "No" "Back" "Exit" -s "Confirm screen size" "Reinput screen size" "Go back to the theme menu" "Exit the toolkit" -a
    case "$selection" in
        "Exit") exit 0 ;;
        "Back") $previous_menu ;;
        "No")   get_screen_size ;;
        "Yes - Save as default")  save_screen_size ;; #Continue to the rest of the imagemagick script
        "Yes - Don't save as default")  : ;; #Continue to the rest of the imagemagick script
    esac
}

save_screen_size(){
    sed -i "s/height=.*/height=$height/" "$config_file"
    sed -i "s/width=.*/width=$width/" "$config_file"
}

gsc_width(){
    if [[ -z "$retry_value" ]] ; then
        bento -t "Grub Themes" -c "Unable to determine your screen size." "Please enter your screen's exact width in pixels." -w
    else
        bento -t "Grub Themes" -c "Unable to determine your screen size." "Please enter your screen's exact width in pixels."
        bento -c "A numeric value is required" -w
    fi
width=$(echo "$selection" | tr -d -c 0-9 )
if [[ -z "$width" ]] ; then
    gsc_width
fi
retry_value=
}

gsc_height(){
    if [[ -z "$retry_value" ]] ; then
        bento -t "Grub Themes" -c "Unable to determine your screen size." "Please enter your screen's exact height in pixels." -w
    else
        bento -t "Grub Themes" -c "Unable to determine your screen size." "Please enter your screen's exact height in pixels."
        bento -c "A numeric value is required" -w
    fi
height=$(echo "$selection" | tr -d -c 0-9 )
if [[ -z "$height" ]] ; then
    gsc_height
fi
retry_value=
}

check_for_all_cba(){
    bento -c "Checking zip contents, please wait..."
    valid_cba=
    for i in {1..9} ; do
        if [[ ! "$valid_cba" == "false" ]] ; then
            ls ~/tmp/brunch-image_converter/boot_splash_frame0$i.png 2> /dev/null || valid_cba="false"
        fi
    done
    for i in {10..13} ; do
        if [[ ! "$valid_cba" == "false" ]] ; then
        ls ~/tmp/brunch-image_converter/boot_splash_frame$i.png 2> /dev/null || valid_cba="false"
        fi
    done
    if [[ "$valid_cba" == "false" ]] ; then
        bento -c "This zip archive does not contain a valid ChromeOS Boot Animation" "A valid ChromeOS Boot Animation should contain 13 pngs named as follows:" "" "boot_splash_frame01.png through boot_splash-frame13.png" -e
        cd "$curdir"
        rm -rf ~/tmp/brunch-image_converter/*
        boot_anim_installer
    else
        source_img=$(ls ~/tmp/brunch-image_converter/boot_splash_frame01.png 2> /dev/null)
    fi
}

check_for_all_bbs(){
    bento -c "Checking zip contents, please wait..."
    valid_bbs=
        ls ~/tmp/brunch-image_converter/main.png 2> /dev/null || valid_bbs="false"
        ls ~/tmp/brunch-image_converter/rebuilding.png 2> /dev/null || valid_bbs="false"
        ls ~/tmp/brunch-image_converter/patching.png 2> /dev/null || valid_bbs="false"
        ls ~/tmp/brunch-image_converter/incompatible.png 2> /dev/null || valid_bbs="false"

        if [[ "$valid_bbs" == "false" ]] ; then
            bento -c "This zip archive does not contain a valid Brunch Bootsplash" "A valid Brunch Bootsplash should contain 4 pngs named as follows:" "" "main.png" "rebuilding.png" "patching.png" "incompatible.png" -e
            cd "$curdir"
            rm -rf ~/tmp/brunch-image_converter/*
            bootsplash_installer
        else
            source_img=$(ls ~/tmp/brunch-image_converter/main.png 2> /dev/null)
        fi
}

image_converter(){
    #grub should not be mounted here, make absolutely sure that it isn't
    unmount_grub
    # We're making a different directory here than usual, this is because we may need access to these files when grub is mounted later so we do not want to mount over them
    mkdir -p ~/tmp/brunch-image_converter
    # we don't want any stray files in there if it already exists
    rm -rf ~/tmp/brunch-image_converter/*
    cp "$downloads/$selection" ~/tmp/brunch-image_converter
    curdir="$pwd"
    cd ~/tmp/brunch-image_converter
    source_img="$selection"
    file_is_zip="false"
    # if the source_img is a zip file, unzip the file directly first
    if [[ "${source_img##*.}" == "zip" ]] ; then
        file_is_zip="true"
        # Unzip the file and parse contents accordingly
        bsdtar -xvf "$source_img" --exclude "*_MACOSX*" | pv -s $(du -sb ~/tmp/brunch-image_converter/ | awk '{print $1}')
        if [[ "$zip_mode" == "cba" ]] ; then
            # Check if zip is a valid ChromeOS Boot Animation based on contents
            check_for_all_cba
        elif [[ "$zip_mode" == "bbs" ]] ; then
            # Check if zip is a valid Brunch Bootsplash based on contents
            check_for_all_bbs
        fi
    fi
# Get height and width of the user's screen for setting final image size
    if [[ -z "$width" ]] || [[ -z "$height" ]] ; then
        width=$(dmesg | grep -i drm_get_panel | tail -1 | cut -d" " -f8 | sed "s#width=##g")
        height=$(dmesg | grep -i drm_get_panel | tail -1 | cut -d" " -f9 | sed "s#height=##g")
        # If these can't be autodetected, prompt the user to set the values.
            if [[ -z "$width" ]] || [[ -z "$height" ]] ; then
                get_screen_size
            else
                save_screen_size
            fi
    fi
# Define a usercolor from the top left pixel color in the selection
# This color will be used as padding in case the image has borders/letterboxing
    usercolor=$(convert $source_img -format "%[pixel:p{0,0}]" info:)
# assume black  if color cannot be retrieved from selection
    if [ -z "$usercolor" ] || [ "$usercolor" == "srgba(0,0,0,0)" ] ; then
        usercolor="black"
    fi
# Get the height and width of the selected image
    img_width=$(identify $source_img | cut -f 3 -d " " | sed s/x.*//)
    img_height=$(identify $source_img | cut -f 3 -d " " | sed s/.*x//)
# set scaling
    if [[ "$scaling" == "center" ]] || [[ -z "$scaling" ]] ; then
            # Center image on canvas
            canvas_width=$(( $width + $img_width ))
            canvas_height=$(( $height + $img_height ))
            scale_height="$canvas_height"
            scale_width="$canvas_width"
    elif [[ "$scaling" == "fit" ]] ; then
            # fit image to canvas
        if (( $img_height > $img_width )) ; then
                padding=$(( $img_height - $img_width ))
                canvas_width=$(( $img_width + $padding ))
                canvas_height="$img_height"
        else
                canvas_width="$img_width"
                canvas_height="$img_height"
        fi
            scale_height="$height"
            scale_width="$width"
    elif [[ "$scaling" == "shrink" ]] ; then
                    # Center image on canvas as an icon
                    canvas_width=$(( ( $width * 4 ) + $img_width ))
                    canvas_height=$(( ( $height * 4) + $img_height ))
                    scale_height="$height"
                    scale_width="$width"
    fi

    if [[ "$file_is_zip" == "true" ]] ; then
        if [[ "$zip_mode" == "cba" ]] ; then
        bento -c "Converting images to fit your screen, please wait..."
            for i in {1..9} ; do
                convert boot_splash_frame0$i.png -gravity center -background "$usercolor" -flatten -extent "$canvas_width"x"$canvas_height" -geometry "$scale_width"x"$scale_height"^ -crop "$width"x"$height"+0+0 boot_splash_frame0$i.png
            done
            for i in {10..13} ; do
                convert boot_splash_frame$i.png -gravity center -background "$usercolor" -flatten -extent "$canvas_width"x"$canvas_height" -geometry "$scale_width"x"$scale_height"^ -crop "$width"x"$height"+0+0 boot_splash_frame0$i.png
            done
        elif [[ "$zip_mode" == "bbs" ]] ; then
            bento -c "Converting images to fit your screen, please wait..."
            bbs_outputs=("main.png" "rebuilding.png" "patching.png" "incompatible.png")
            for elem in "${bbs_outputs[@]}" ; do
                convert "$elem" -gravity center -background "$usercolor" -flatten -extent "$canvas_width"x"$canvas_height" -geometry "$scale_width"x"$scale_height"^ -crop "$width"x"$height"+0+0 "$elem"
            done
        fi
    else
        bento -c "Converting image to fit your screen, please wait..."
        convert $source_img -gravity center -background "$usercolor" -flatten -extent "$canvas_width"x"$canvas_height" -geometry "$scale_width"x"$scale_height"^ -crop "$width"x"$height"+0+0 "$target_img"
    fi
    cd "$curdir"
}

#</>

#<~> Change Kernels
    kernel_options(){
        check_for_dualboot
        check_grub_format
            previous_menu="grub_options_menu"
        get_possible_kernels
        previous_menu="grub_options_menu"
        bento -t "Kernel Options" -c "Quickly swap between avaliable Brunch Kernels" "" "WARNING! Changing kernels can prevent users from logging in to their ChromeOS account, in which case a powerwash is the only solution (CTRL + ALT + SHIFT + R at the login screen)." "Before switching to a different kernel, make sure there is a backup of all user data!" div "Current Kernel: $brunch_kernel_option" -m "${avaliable_kernels[@]}" div "Back" "Exit" -s "${avaliable_kernels_subs[@]}" div "Go back to the previous menu" "Exit the toolkit" -a
            case "$selection" in
                "Exit") exit 0 ;;
                "Back") $previous_menu ;;
                *) select_kernel ; kernel_options ;;
            esac
    }

    select_kernel(){
        if [[ "$selection" == "kernel-5.4" ]] ; then
            selection="kernel"
        fi
        if [[ "$brunch_kernel_option" == "kernel-5.4" ]] ; then
            brunch_kernel_option="kernel"
        fi
        mount_grub
        if [[ "$new_grub" == "true" ]] ; then
        sudo sed -i "s|kernel=$brunch_kernel_option|kernel=/$selection|" "$brunch_config"
        else
        sudo sed -i "s/$brunch_kernel_option/$selection/" "$brunch_config"
        unmount_grub
        fi

    }

    get_possible_kernels(){
        if (( $current_brunch_version > 20201226 )) ; then
            avaliable_kernels=("kernel-4.19" "kernel-5.4" "kernel-5.10")
            avaliable_kernels_subs=("Swap to kernel-4.19" "Swap to kernel-5.4" "Swap to kernel-5.10")
        else
            avaliable_kernels=("kernel-4.19" "kernel-5.4")
            avaliable_kernels_subs=("Swap to kernel-4.19" "Swap to kernel-5.4")
        fi
    }
#</>

#<~> Framework Options

mount_grub(){
    mkdir -p ~/tmp/brunch-workspace
    sudo mount "$partsource"12 ~/tmp/brunch-workspace
}

unmount_grub(){
    # do this twice to be sure
    sudo umount ~/tmp/brunch-workspace 2> /dev/null
        sudo umount ~/tmp/brunch-workspace 2> /dev/null
}

framework_options(){
    previous_menu="grub_options_menu"
    check_grub_format
    build_framework_menu
    fwo_menu=(-t "Framework Options" -c "Select Framework Options to toggle them on or off, changes are saved automatically." -x -m )
    if [[ "$current_page" == "page1" ]] ; then
        bento "${fwo_menu[@]}" "${menu_fwo_page1[@]}" div "Back" "Exit" -s "${fwo_page1_subs[@]}" div "Go back to the previous menu" "Exit the toolkit"
    elif [[ "$current_page" == "page2" ]] ; then
        bento "${fwo_menu[@]}" "${menu_fwo_page2[@]}" div "Back" "Exit" -s "${fwo_page2_subs[@]}" div "Go back to the previous menu" "Exit the toolkit"
    elif [[ "$current_page" == "wifi" ]] ; then
        bento "${fwo_menu[@]}" "${menu_fwo_wifi[@]}" div "Back" "Exit" -s "${fwo_wifi_subs[@]}" div "Go back to the previous menu" "Exit the toolkit"
    fi
    case "$selection" in
            "Exit") exit 0 ;;
            "Back") current_page= ; $previous_menu ;;
            "More Options") current_page="page2" ;;
            "Wifi Options") current_page="wifi" ;;
            "Other Options") current_page="page1" ;;
            *) toggle_fwo ;;
    esac
    # reloop this menu for the aesthetic
    framework_options
}

toggle_fwo(){
    unset temp_fwo
    if [[ "$selection" =~ "◆" ]] ; then
    selection="${selection:4}"
        #remove this option from the array
        #for (( i=0; i < "${#brunch_framework_options[@]}"; i++ )) ; do
        for elem in "${brunch_framework_options[@]}" ; do
            if [[ ! "$elem" == "$selection" ]] ; then
                temp_fwo+=" $elem"
            fi
        done
    elif [[ "$selection" =~ "◯" ]] ; then
    selection="${selection:4}"
        #add this option to the array
        for (( i=0; i < "${#brunch_framework_options[@]}"; i++ )) ; do
            temp_fwo+=" ${brunch_framework_options[$i]}"
        done
        temp_fwo+=" $selection"
    fi
    # return array to the original format, opt1,opt2,opt3
    temp_fwo_unfiltered=$(echo "${temp_fwo[@]}" | xargs | sed "s/ /,/g")
    # swap the original unfiltered options with the new unfiltered option
    mount_grub
    sudo sed -i "s/options=$brunch_framework_options_unfiltered/options=$temp_fwo_unfiltered/" "$brunch_config"
    unmount_grub
}

build_framework_menu(){
    unset menu_fwo_page1
    unset menu_fwo_page2
    unset menu_fwo_wifi
    #compare user options to arrays and mark ◆ or ◯ as needed
        for (( i=0; i < "${#fwo_page1[@]}"; i++ )) ; do
            if [[ "${fwo_page1[$i]}" =~ "Options" ]] ; then
                menu_fwo_page1+=("${fwo_page1[$i]}")
            elif [[ "${brunch_framework_options[@]}" =~ "${fwo_page1[$i]}" ]] ; then
                # if theres a match
                menu_fwo_page1+=("◆ ${fwo_page1[$i]}")
            else # if theres NO match
                menu_fwo_page1+=("◯ ${fwo_page1[$i]}")
            fi
        done
        for (( i=0; i < "${#fwo_page2[@]}"; i++ )) ; do
            if [[ "${fwo_page2[$i]}" =~ "Options" ]] ; then
                menu_fwo_page2+=("${fwo_page2[$i]}")
            elif [[ "${brunch_framework_options[@]}" =~ "${fwo_page2[$i]}" ]] ; then
                # if theres a match
                menu_fwo_page2+=("◆ ${fwo_page2[$i]}")
            else # if theres NO match
                menu_fwo_page2+=("◯ ${fwo_page2[$i]}")
            fi
        done
        for (( i=0; i < "${#fwo_wifi[@]}"; i++ )) ; do
            if [[ "${fwo_wifi[$i]}" =~ "Options" ]] ; then
                menu_fwo_wifi+=("${fwo_wifi[$i]}")
            elif [[ "${brunch_framework_options[@]}" =~ "${fwo_wifi[$i]}" ]] ; then
                # if theres a match
                menu_fwo_wifi+=("◆ ${fwo_wifi[$i]}")
            else # if theres NO match
                menu_fwo_wifi+=("◯ ${fwo_wifi[$i]}")
            fi
        done
    if [[ -z "$current_page" ]] ; then current_page="page1" ; fi
}
#</>

#<~> Install Brunch

install_brunch(){
    unset boot_opts
    unset boot_opts_subs
    if [[ "$toolkit_mode" =~ "usb" ]] ; then
        boot_opts=("Singleboot" "Generate IMG" "Back" "Exit")
            boot_opts_subs=("Install Brunch to a single disk" "Create an IMG file" "Go back to the previous menu" "Exit the toolkit without installing")
    elif [[ "$toolkit_mode" =~ "wsl" ]] ; then
        boot_opts=("Generate IMG" "Back" "Exit")
            boot_opts_subs=("Create an IMG file" "Go back to the previous menu" "Exit the toolkit without installing")
    else
        boot_opts=("Install to USB" "Singleboot" "Dualboot" "Generate IMG" "Back" "Exit")
            boot_opts_subs=("Install Brunch to a USB" "Install Brunch to a single disk" "Install Brunch to a single partition" "Create an IMG file" "Go back to the previous menu" "Exit the toolkit without installing")
    fi
    bento -t "Install Brunch" -c "Select installation type." -m "${boot_opts[@]}" -s "${boot_opts_subs[@]}" -a
    # Currently USB and singleboot are the same
    # Generate IMG is the same as dualboot until the grub section. If in WSL dont mount a dst
    case "$selection" in
            "Exit") exit 0 ;;
            "Back") main_menu_startup ;;
            *) install_method="$selection" ; install_brunch_sub ; main_menu_startup ; return ;;
    esac
}

install_brunch_sub(){
    if [[ "$toolkit_mode" =~ "wsl" ]] ; then
        # if using WSL, don't bother selecting a dst since it's always a chromeos.img
        selected_dst="chromeos.img"
        selected_size="14"
        select_src
        else
    unset possible_outs
        unset possible_outs_subs
    data=($(lsblk -b -io KNAME,TYPE,SIZE,TRAN | grep "[smn][dmv]" | grep -Ev "part" | sed 's/.*dev//'  | awk '$3 > 16*2^30 {print $1"="$3/1073741824"G="$4}'))
    for elem in "${data[@]}" ; do
        seperate_parts=$(echo "$elem" | sed 's/=/    /g' | sed 's/sata/Internal/' | sed 's/usb/USB/')
        possible_outs+=("$seperate_parts")
        possible_outs_subs+=("Select $seperate_parts")
    done
    bento -t "Install Brunch" -c "Please select which of these disks you would like to install Brunch to." div "Only disks large enough for Brunch are shown. (16GB or larger)" -m "${possible_outs[@]}" "Back" "Exit" -s "${possible_outs_subs[@]}" "Go back to the previous menu" "Exit the toolkit without installing" -a
    case "$selection" in
            "Exit") exit 0 ;;
            "Back") install_brunch ; return ;;
            *) selected_dst=$(echo "$selection" | awk '{print $1}') ; select_dst ; return ;;
    esac
fi
    }

select_dst(){
    unset possible_outs
        unset possible_outs_subs
    if [[ "$install_method" =~ "USB" ]] || [[ "$install_method" = "Singleboot" ]] ; then
        selected_dst="/dev/$selected_dst"
        select_src
    elif [[ "$install_method" = "Dualboot" ]] ||  [[ "$install_method" =~ "IMG" ]] ; then
        data=($(lsblk -b -io KNAME,TYPE,SIZE | grep "$selected_dst" | grep -Ev "disk" | sed 's/.*dev//'  | awk '$3 > 16*2^30 {print $1"="$3/1073741824"G"}'))
        for elem in "${data[@]}" ; do
            seperate_parts=$(echo "$elem" | sed 's/=/    /g')
            possible_outs+=("$seperate_parts")
            possible_outs_subs+=("Select $seperate_parts")
        done
        bento -t "Install Brunch" -c "Please select which of these partitions you would like to install Brunch to." div "Only partitions large enough for Brunch are shown. (16GB or larger)" -m "${possible_outs[@]}" "Back" "Exit" -s "${possible_outs_subs[@]}" "Go back to the previous menu" "Exit the toolkit without installing" -a
        case "$selection" in
                "Exit") exit 0 ;;
                "Back") install_brunch_sub ; return ;;
                *) selected_dst=$(echo "$selection" | awk '{print $1}') ; select_size ; return ;;
        esac
    fi
}

select_size(){
    previous_menu="install_brunch_sub"
    unmount_target
    mount_target
    avaliable_space=$(df -BG ~/tmpmount | awk 'NR==2 {print $4}')
    unmount_target
    if [[ -n "$avaliable_space" ]] ; then
    avaliable_space=$(echo "${avaliable_space%.*}" | sed 's/G//')
    avaliable_space_text="Avaliable space: ${avaliable_space%.*}"
    fi
    bento -t "Install Brunch" -c "What size in GB should this installation be?" "$avaliable_space_text" div "Enter size in GB, must be at least 14" -w
        previous_menu="select_size"
    if [[ -z "${selection##*[!0-9]*}" ]] ; then
        bento -g -c "Entered value is not numeric." "(Do not include letters or decimals)" -r
    elif [[ -z "$selection" ]] ; then
        bento -g -c "You must enter a number." -r
    elif (( "$selection" < "14" )) ; then
        bento -g -c "Entered value is too small." -r
        select_size
    elif (( "$selection" > "$avaliable_space" )) ; then
        if (( i < 3 )) ; then
            ((i++))
            bento -g -c "Entered value is too large." -r
        else
            bento -g -c "Entered value is too large, trying anyway..." -e
            selected_size="$selection"
            i=0
            select_src
        fi
    else
        : # proceed with this size
        selected_size="$selection"
        i=0
        select_src
    fi
}

mount_target(){
    mkdir -p ~/tmpmount
    sudo mount "$selected_dst" ~/tmpmount
}

unmount_target(){
    # do this twice, just in case , errors here are inconsequential
    sudo umount ~/tmpmount 2> /dev/null
        sudo umount ~/tmpmount 2> /dev/null
}

select_src(){
    if [[ "$toolkit_mode" =~ "brunch" ]] ; then
        prepare_installation # skip getting a src and skip getting brunch files
    elif [[ "$onlineallowed" = "true" ]] ; then
        automatic_chromeos_download
        automatic_brunch_download
        prepare_installation
    else
        advanced_chromeos_select
        advanced_brunch_select
        prepare_installation
    fi
}

automatic_chromeos_download(){
            # Make a working directory to keep toolkit out of sight
                mkdir -p ~/tmp/brunch-workspace
                curdir=$(pwd)
                cd ~/tmp/brunch-workspace
                chrome_url=$(curl -s https://cros.tech/device/$selected_recovery | tr ' ' '\n' | tr '>' '\n' | grep href= | sed 's/"//g' | sed 's/href=//g' | tail -1)
                chrome_url_vers=$(curl -s https://cros.tech/device/$selected_recovery | tr ' ' '\n' | tr '>' '\n' | sed 's/"//g' | sed 's/href=//g' | grep '</span' | sed 's/<\/span//g' | tail -1)
                bento -t "Install Brunch" -c "Downloading the latest ${selected_recovery^} $chrome_url_vers recovery, please wait..."
                curl -L -O --progress-bar "$chrome_url"
                updatefile="$(find *$selected_recovery*bin.zip 2> /dev/null | sort -r | head -1 )"
            # unzip the file
                bento -t "Install Brunch" -c "Now extracting the recovery file, please wait..."
                if [[ "$toolkit_mode" =~ "linux" ]] || [[ "$toolkit_mode" =~ "arch" ]] ; then
                    unzip "$updatefile"
                elif [[ "$toolkit_mode" =~ "brunch" ]] ; then
                    bsdtar -xf "$updatefile"
                fi
                recovery_bin="$(find *$selected_recovery*bin 2> /dev/null | sort -r | head -1 )"
                selected_src="$recovery_bin"
                rm -rf "$updatefile"
                cd "$curdir"
}

advanced_chromeos_select(){
        previous_menu="install_brunch_sub"
        curdir=$(pwd)
        cd "$downloads"
        #brunch_files=($(find *runch*.tar.gz 2> /dev/null | sort -r))
        unset chrome_files
    chrome_files=()
    while IFS=  read -r -d $'\0'; do
        if [[ ! "$REPLY" =~ " " ]] ; then
            chrome_files+=("${REPLY:2}")
        fi
    done < <(find . -name "*hrome*.bin*" -print0)

        if [[ -n "$chrome_files" ]] ; then
        bento -t "Install Brunch" -c "Please select a recovery archive to install with." -m "${chrome_files[@]}" "Back" "Exit" -s "${chrome_files[@]}" "Go back to the previous menu" "Exit without installing." -a
        case "$selection" in
            "Back") cd "$curdir" ;"$previous_menu" ; return ;;
            "Exit") exit 0 ;;
            *) updatefile="$selection" ;;
        esac
        if [[ "${selection: -4}" == ".bin" ]] ; then
            bento -t "Install Brunch" -c "Now extracting the recovery file, please wait..."
            if [[ "$toolkit_mode" =~ "linux" ]] || [[ "$toolkit_mode" =~ "arch" ]] ; then
                unzip "$updatefile"
            elif [[ "$toolkit_mode" =~ "brunch" ]] ; then
                bsdtar -xf "$updatefile"
            fi
            recovery_bin=$(echo "$updatefile" | sed 's/.zip//')
            selected_src="$downloads/$recovery_bin"
        elif  [[ "${selection: -4}" == ".bin" ]] ; then
            recovery_bin="$updatefile"
        fi
        selected_src="$downloads/$recovery_bin"
            cd "$curdir"
        else
            cd "$curdir"
            bento -t "Install Brunch" -c "Unable to find ChromeOS recovery archives in $downloads" "You can manually download the latest release of ${selected_recovery^} here:" "https://cros.tech/device/$selected_recovery" div "Be sure to keep the default filename and extention, and make sure there are no spaces in the filename." -r
        fi
}

automatic_brunch_download(){
    # Make a working directory to keep toolkit out of sight
        mkdir -p ~/tmp/brunch-workspace
        curdir=$(pwd)
        cd ~/tmp/brunch-workspace
        bento -t "Install Brunch" -c "Downloading the latest Brunch release, please wait..."
        curl -L -O --progress-bar "$(curl -s https://api.github.com/repos/sebanc/brunch/releases/latest | grep 'browser_' | cut -d\" -f4)"
        updatefile="$(find *runch*tar.gz 2> /dev/null | sort -r | head -1 )"
    # extract brunch release to the workspace
        bento -t "Install Brunch" -c "Now extracting the Brunch release, please wait..."
        tar zxvf "$updatefile"
        rm -rf "$updatefile"
    # eventually add MBR support here
        cd "$curdir"
}

advanced_brunch_select(){
    previous_menu="advanced_chromeos_select"
    curdir=$(pwd)
    cd "$downloads"
    #brunch_files=($(find *runch*.tar.gz 2> /dev/null | sort -r))
    unset brunch_files
brunch_files=()
while IFS=  read -r -d $'\0'; do
    if [[ ! "$REPLY" =~ " " ]] ; then
        brunch_files+=("${REPLY:2}")
    fi
done < <(find . -name "*runch_r*.tar.gz" -print0)

    if [[ -n "$brunch_files" ]] ; then
    bento -t "Install Brunch" -c "Please select a Brunch archive to install with." -m "${brunch_files[@]}" "Back" "Exit" -s "${brunch_files[@]}" "Go back to the previous menu" "Exit without updating." -a
    case "$selection" in
        "Back") cd "$curdir" ;"$previous_menu" ; return ;;
        "Exit") exit 0 ;;
        *) updatefile="$selection" ;;
    esac
# extract brunch release to the workspace
    bento - "Install Brunch" -c "Now extracting the Brunch release, please wait..."
        mkdir -p ~/tmp/brunch-workspace
    tar zxvf "$updatefile" -c ~/tmp/brunch-workspace
    rm -rf "$updatefile"
# eventually add MBR support here
        cd "$curdir"
    else
        cd "$curdir"
        bento -t "Install Brunch" -c "Unable to find Brunch tar.gz archives in $downloads" "You can manually download the latest release from github here:" "https://github.com/sebanc/brunch/releases" div "Be sure to keep the default filename and extention, and make sure there are no spaces in the filename." -r
    fi

}

prepare_installation(){
    #command -v bento >/dev/null 2>&1 || bento_installed="false"
    bento -t "Install Brunch" -c "Now installing Brunch, please wait..."
    curdir=$(pwd)
    cd ~/tmp/brunch-workspace

    if [[ "$toolkit_mode" =~ "brunch" ]] ; then
        sudo chromeos-install -dst "$selected_dst"

    elif [[ "$toolkit_mode" =~ "wsl" ]] ; then
        sudo bash chromeos-install.sh -dst "$downloads"/chromeos.img -src "$selected_src" -s "$selected_size"
        etcher=$(find $downloads/balenaEtcher*ortable*.exe 2> /dev/null | head -1 )
        etcherlink=$(curl -s https://api.github.com/repos/balena-io/etcher/releases/latest | grep 'browser_' | cut -d\" -f4 | grep 'Portable')
        if [ -z "$etcher" ] ; then
            bento -t "Install Brunch" -c "Now downloading Etcher, please wait..."
            curl -L -O --progress-bar "$etcherlink"
        fi
            bento -t "Install Brunch" -c "The Etcher window should open shortly, please select your chromeos.img and your USB to flash the img to it." "It should be located in: $downloads" -e
            $etcher

    elif [[ "$install_method" =~ "USB" ]] || [[ "$install_method" == "Singleboot" ]] ; then
        sudo bash chromeos-install.sh -dst "$selected_dst" -src "$selected_src"

    elif [[ "$install_method" =~ "IMG" ]] || [[ "$install_method" == "Dualboot" ]] ; then
        mount_target
        sudo bash chromeos-install.sh -dst ~/tmpmount/chromeos.img -src "$selected_src" -s "$selected_size"
        unmount_target
    fi
            cd "$curdir"
finalize_installation
}

finalize_installation(){
    if [[ "$install_method" == "Dualboot" ]] && [[ ! "$toolkit_mode" =~ "wsl" ]] ; then
    # detect grub and offer to add a menu entry for brunch to the user's system
    # This section is still incomplete
      bento -n -c "Brunch IMG created!" "See the messages above to finish the installation manually before continuing." -e
    elif [[ ! "$toolkit_mode" =~ "IMG" ]] ; then
      bento -c "Brunch IMG created!" -e
    else
      bento -c "Brunch install complete!" -e
    fi
    rm -rf ~/tmp/brunch-workspace/*
    main_menu_startup
}

#</>

#<~> Bootscripts

bootscript_menu(){
    curdir=$(pwd)
    cd /var/brunch/bootscripts
    unset bootscript
    unset bootscript_sub
# Use this for menu presentation
bootscript=()
bootscript_sub=()
# Find files and sort by extention
while IFS=  read -r -d $'\0'; do
    if [[ ! "$REPLY" =~ " " ]] ; then
        result_no_prefix="${REPLY:2}"
        if [[ "${REPLY: -3}" == ".sh" ]] ; then
            result_no_suffix="${result_no_prefix%".sh"}"
            bootscript+=("◆ $result_no_suffix")
            bootscript_sub+=("Disable $result_no_suffix")
        elif [[ "${REPLY: -4}" == ".off" ]] ; then
            result_no_suffix="${result_no_prefix%".off"}"
            bootscript+=("◯ $result_no_suffix")
            bootscript_sub+=("Enable $result_no_suffix")
        fi
    fi
done < <(find . -name "*" -print0)
if [[ -n "${bootscript[@]}" ]] ; then
    bootscript+=("div")
    bootscript_sub+=("div")
    bootscript+=("Remove Bootscript")
    bootscript_sub+=("Uninstall script file")
        bootscript+=("Edit Bootscript")
        bootscript_sub+=("Edit script file in $EDITOR")
fi
    bootscript+=("Install Bootscript")
    bootscript_sub+=("Install script file")

cd "$curdir"
    bento -t "Bootscript Menu" -c "Add, remove and toggle bootscripts." -m "${bootscript[@]}" "Back" "Exit" -s "${bootscript_sub[@]}" "Go back to the previous menu" "Exit the toolkit" -x
case "$selection" in
        "Exit") exit 0 ;;
        "Back") main_menu_startup ;;
        "Install Bootscript") install_bootscript ; bootscript_menu ; return ;;
        "Remove Bootscript") remove_bootscript ; bootscript_menu ; return ;;
        "Edit Bootscript") edit_bootscript ; bootscript_menu ; return ;;
        *) toggle_bootscript ; bootscript_menu ; return ;;
esac
}

edit_bootscript(){
    curdir=$(pwd)
    cd /var/brunch/bootscripts
    unset bootscript
    unset bootscript_sub
    # Use this for menu presentation
    bootscript=()
    bootscript_sub=()
# Find files
    while IFS=  read -r -d $'\0'; do
        bootscript_no_prefix="${REPLY:2}"
        if [[ ! "$REPLY" =~ " " ]] ; then
            if [[ "$REPLY" =~ .*\.(sh|off) ]] ; then
                bootscript+=("$bootscript_no_prefix")
                bootscript_sub+=("Remove $bootscript_no_prefix")
            fi
        fi
    done < <(find . -name "*" -print0)
    cd "$curdir"
        if [[ -z "${bootscript[@]}" ]] ; then
            bootscript_menu
        fi
    bento -t "Bootscript Menu" -c "Select a bootscript to edit with $EDITOR" -m "${bootscript[@]}" "Back" "Exit" -s "${bootscript_sub[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    case "$selection" in
            "Exit") exit 0 ;;
            "Back") bootscript_menu ;;
            *) edit_bootscript_sub ; edit_bootscript ; return ;;
    esac
}

edit_bootscript_sub(){
    sudo "$EDITOR" /var/brunch/bootscripts/"$selection"
}

remove_bootscript(){
        curdir=$(pwd)
        cd /var/brunch/bootscripts
        unset bootscript
        unset bootscript_sub
    # Use this for menu presentation
    bootscript=()
    bootscript_sub=()
    # Find files
    while IFS=  read -r -d $'\0'; do
        bootscript_no_prefix="${REPLY:2}"
        if [[ ! "$REPLY" =~ " " ]] ; then
            if [[ "$REPLY" =~ .*\.(sh|off) ]] ; then
                bootscript+=("$bootscript_no_prefix")
                bootscript_sub+=("Remove $bootscript_no_prefix")
            fi
        fi
    done < <(find . -name "*" -print0)
    cd "$curdir"

    if [[ -z "${bootscript[@]}" ]] ; then
        bootscript_menu
    fi
    bento -t "Bootscript Menu" -c "Select a bootscript to remove" "It will be deleted, this cannot be undone." -m "${bootscript[@]}" "Back" "Exit" -s "${bootscript_sub[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    case "$selection" in
            "Exit") exit 0 ;;
            "Back") bootscript_menu ;;
            *) remove_bootscript_sub ; remove_bootscript ; return ;;
    esac
}

remove_bootscript_sub(){
    rm /var/brunch/bootscripts/"$selection"
}

install_bootscript(){
    if [[ "$rerun" == "true" ]] ; then
        ins_boot_box="Select another script to be added as a bootscript."
    else
        ins_boot_box="Select a script, a copy will be added as a bootscript."
    fi
    curdir=$(pwd)
    cd "$downloads"
    unset found_scripts
    unset found_scripts_subs
    found_scripts=()
    # Find files and sort by extention
    while IFS=  read -r -d $'\0'; do
        if [[ ! "$REPLY" =~ " " ]] ; then
            found_scripts+=("${REPLY:2}")
            found_scripts_subs+=("Add ${REPLY:2} to bootscripts")
        fi
    done < <(find . -name "*.sh" -print0)
    cd "$curdir"
    bento -t "Bootscript Menu" -c "$ins_boot_box" -a -m "${found_scripts[@]}" "Back" "Exit" -s "${found_scripts_subs[@]}" "Go back to the previous menu" "Exit the toolkit"

case "$selection" in
        "Exit") exit 0 ;;
        "Back") rerun="false" ; main_menu_startup ;;
        *) install_bootscript_sub ; bootscript_menu ; return ;;
esac
}

install_bootscript_sub(){
    cp "$downloads"/"$selection" /var/brunch/bootscripts/"$selection"
    rerun="true"
}

toggle_bootscript(){
    if [[ "$selection" =~ "◆" ]] ; then
        selection="${selection:4}"
        mv /var/brunch/bootscripts/"$selection".sh /var/brunch/bootscripts/"$selection".off
    elif  [[ "$selection" =~ "◯" ]] ; then
        selection="${selection:4}"
        mv /var/brunch/bootscripts/"$selection".off /var/brunch/bootscripts/"$selection".sh
    fi
}

#</>

#<~> Brioche Menu

brioche_menu(){
    unset brioche_opts
    unset brioche_subs
    toolchain_installed=$(command -v start-toolchain 2>&1)
    brioche_installed=$(command -v brioche 2>&1)
    if [[ -n "$toolchain_installed" ]] ; then
        brioche_opts+=("Update Toolchain")
        tc_ui="update"
        brioche_subs+=("${tc_ui^} the Brunch Toolchain")
    else
        brioche_opts+=("Install Toolchain")
        tc_ui="install"
        brioche_subs+=("${tc_ui^} the Brunch Toolchain")
    fi

    if [[ -n "$toolchain_installed" ]] && [[ -n "$brioche_installed" ]] && [[ "$onlineallowed" == "true" ]] ; then
        brioche_opts+=("Update Brioche")
        br_ui="update"
        brioche_subs+=("${br_ui^} Brioche")
    elif [[ "$onlineallowed" == "true" ]] ; then
        brioche_opts+=("Install Brioche")
        br_ui="install"
        brioche_subs+=("${br_ui^} Brioche")
    fi
    bento -t "Brioche Options" -c "Install and manage Brioche and the Brunch Toolchain." "(More options to be added to this menu later)" -m "${brioche_opts[@]}" "Back" "Exit" -s "${brioche_subs[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    case "$selection" in
        "Exit") exit 0 ;;
        "Back") $previous_menu ;;
        "Install Toolchain") install_toolchain ; brioche_menu ; return ;;
        "Install Brioche") install_brioche ; brioche_menu ; return ;;
        # For now, updating is the same as installing
        "Update Toolchain") install_toolchain ; brioche_menu ; return ;;
        "Update Brioche") install_brioche ; brioche_menu ; return ;;
    esac
}

#</>

#<~> Brioche functions

install_brioche(){
    if [[ "$onlineallowed" == "true" ]] ; then
    mkdir -p ~/tmp/brunch-workspace
    bento -t "${br_ui^} Brioche" -c "Downloading Brioche, please wait..."
    curl -l https://raw.githubusercontent.com/sebanc/brioche/main/brioche -o ~/tmp/brunch-workspace/brioche
    install -Dt /usr/local/bin -m 755 ~/tmp/brunch-workspace/brioche
    bento -t "${br_ui^} Brioche" -c "Brioche has been ${br_ui^}ed." -e
    else
        bento -t "${br_ui^} Brioche" -c "Currently unable to download the latest release of Brioche." -e
    fi
}


#</>

#<~> Toolchain functions
install_toolchain(){
    bento -t "${tc_ui^} Toolchain" -c "This will erase anything in /usr/local and take approximately 2GB of space." "If you previously had Chromebrew or the Brunch Toolchain installed, it will be removed and replaced."
    bento -n -g -c "Do you wish to continue?" -m "Yes" "No" "Exit" -s "Continue" "Go back to the previous menu" "Exit without ${tc_ui}ing"
    case "$selection" in
            "Exit") exit 0 ;;
            "No") brioche_menu ;;
            "Yes") install_toolchain_sub ;;
    esac
}

install_toolchain_adv(){
    bento -t "${tc_ui^} Toolchain" -c "This will erase anything in /usr/local and take approximately 2GB of space." "If you previously had Chromebrew or the Brunch Toolchain installed, it will be removed and replaced."
    bento -n -g -c "Do you wish to continue?" -m "Yes" "No" "Exit" -s "Continue" "Go back to the previous menu" "Exit without ${tc_ui}ing"
    case "$selection" in
            "Exit") exit 0 ;;
            "No") advanced_options_menu ;;
            "Yes") advanced_install_toolchain ;;
    esac
}

install_toolchain_sub(){
    if [[ "$onlineallowed" == "true" ]] ; then
        automatic_install_toolchain
    else
        bento -t "${tc_ui^} Toolchain" -c "Unable to $tc_ui automatically, trying advanced $tc_ui option." -e
        advanced_install_toolchain
    fi
}

automatic_install_toolchain(){
    sudo rm -r /usr/local/*
    sudo chown -R 1000:1000 /usr/local
    mkdir -p ~/tmp/brunch-workspace
    curdir=$(pwd)
    cd ~/tmp/brunch-workspace
    bento -t "${tc_ui^} Toolchain" -c "Downloading the latest Brunch Toolchain, please wait..."
    curl -L -O --progress-bar "$(curl -s https://api.github.com/repos/sebanc/brunch-toolchain/releases/latest | grep 'browser_' | cut -d\" -f4)"
    updatefile="$(find *runch*toolchain*tar.gz 2> /dev/null | sort -r | head -1 )"
    bento -t "${tc_ui^} Toolchain" -c "Now ${tc_ui^}ing Brunch Toolchain, please wait..."
    tar zxf ~/tmp/brunch-workspace/"$updatefile" -C /usr/local
    echo "source /usr/local/bin/start-toolchain" >> ~/.bashrc
    cd "$curdir"
    bento -t "${tc_ui^} Toolchain" -c "${tc_ui^} complete" "Please exit and reopen the terminal to see changes." -e
}

advanced_install_toolchain(){
    curdir=$(pwd)
    cd "$downloads"
    unset toolchain_files
    toolchain_files=()
    while IFS=  read -r -d $'\0'; do
        if [[ ! "$REPLY" =~ " " ]] ; then
            toolchain_files+=("${REPLY:2}")
        fi
    done < <(find . -name "*runch_t*.tar.gz" -print0)

        if [[ -n "$toolchain_files" ]] ; then
        bento -t "${tc_ui^} Toolchain" -c "Please select a Brunch Toolchain archive to $tc_ui with." -m "${toolchain_files[@]}" "Back" "Exit" -s "${toolchain_files[@]}" "Go back to the previous menu" "Exit without updating." -a
        case "$selection" in
            "Back") cd "$curdir" ; brioche_menu ;;
            "Exit") exit 0 ;;
            *) updatefile="$selection" ;;
        esac
        sudo rm -r /usr/local/*
        sudo chown -R 1000:1000 /usr/local
        tar zxf "$downloads/$updatefile" -C /usr/local
        echo "source /usr/local/bin/start-toolchain" >> ~/.bashrc
        cd "$curdir"
        bento -t "${tc_ui^} Toolchain" -c "${tc_ui^} complete" "Please exit and reopen the terminal to see changes." -e
    else

        cd "$curdir"
        bento -t "${tc_ui^} Toolchain" -c "Unable to find Brunch Toolchain tar.gz archives in $downloads" "You can manually download the latest release from github here:" "https://github.com/sebanc/brunch-toolchain/releases" div "Be sure to keep the default filename and extention, and make sure there are no spaces in the filename." -r
    fi

}

#</>

#<~> Update Toolkit
    update_brunch_toolkit(){
        if [[ "$onlineallowed" == "true" ]] ; then
        mkdir -p ~/tmp/brunch-workspace
        bento -t "Update Toolkit" -c "Downloading the latest Brunch Toolkit, please wait..."
    curl -l https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/brunch-toolkit -o ~/tmp/brunch-workspace/brunch-toolkit
    sudo install -Dt /usr/local/bin -m 755 ~/tmp/brunch-workspace/brunch-toolkit
        bento -t "Update Toolkit" -c "Update complete" "Exit and reopen the Toolkit to see changes." -e
        else
            bento -t "Update Toolkit" -c "Currently unable to download the latest Toolkit." -e
        fi
    }
#</>

#<~> Update Brunch
update_brunch(){
    if [[ "$onlineallowed" == "true" ]] ; then
        update_channel="brunch"
        automatic_brunch_update
    else
        bento -t "Update Brunch" -c "Unable to update automatically, trying advanced update option." -e
        advanced_brunch_update
    fi
}

update_brunch_unstable(){
    if [[ "$onlineallowed" == "true" ]] ; then
        update_channel="brunch-unstable"
        automatic_brunch_update
    else
        bento -t "Update Brunch" -c "Unable to update automatically, trying advanced update option." -e
        advanced_brunch_update
    fi
}

advanced_brunch_update(){
    curdir=$(pwd)
    cd "$downloads"
    #brunch_files=($(find *runch*.tar.gz 2> /dev/null | sort -r))
    unset brunch_files
brunch_files=()
while IFS=  read -r -d $'\0'; do
    if [[ ! "$REPLY" =~ " " ]] ; then
        brunch_files+=("${REPLY:2}")
    fi
done < <(find . -name "*runch_r*.tar.gz" -print0)

    if [[ -n "$brunch_files" ]] ; then
    bento -t "Update Brunch" -c "Please select a Brunch archive to update with." -m "${brunch_files[@]}" "Back" "Exit" -s "${brunch_files[@]}" "Go back to the previous menu" "Exit without updating." -a
    case "$selection" in
        "Back") cd "$curdir" ; "$previous_menu" ; return ;;
        "Exit") exit 0 ;;
        *) updatefile="$selection" ;;
    esac
    if (( $latest_brunch_version > 20210620 )) ; then
        bento -t "Update Brunch" -c "Newer releases of brunch have an updated internal Grub, would you like to update the EFI partition?" "This is suggested for most users." -m "Yes" "No" "Back" "Exit" -s "Update Brunch's internal grub" "Continue without updating the internal grub" "Go back to the previous menu" "Exit the toolkit" -a
        case "$selection" in
            "Back") cd "$curdir" ; "$previous_menu" ; return ;;
            "Exit") exit 0 ;;
            "Yes") update_internal_grub="true" ;;
            "No") update_internal_grub="false" ;;
        esac
    fi

    bento -t "Update Brunch" -c "Now applying Brunch update, please wait..."
    # Call built in update command
    if [[ "$update_internal_grub" == "true" ]] ; then
        sudo chromeos-update -f "$downloads/$updatefile" -e
    else
        sudo chromeos-update -f "$downloads/$updatefile"
    fi
        cd "$curdir"
        # clean up
        #sed -i "s/current_brunch_version=.*/current_brunch_version=$latest_brunch_version/" "$config_file"
        #source "$config_file" 2> /dev/null
        update_complete="true"
        bento -t "Update Brunch" -c "Update complete" "Please reboot to see changes." -e
    else

        cd "$curdir"
        bento -t "Update Brunch" -c "Unable to find Brunch tar.gz archives in $downloads" "You can manually download the latest release from github here:" "https://github.com/sebanc/brunch/releases" div "Be sure to keep the default filename and extention, and make sure there are no spaces in the filename." -r
    fi
}

automatic_brunch_update(){
    # Make a working directory to keep toolkit out of sight
        mkdir -p ~/tmp/brunch-workspace
        curdir=$(pwd)
        cd ~/tmp/brunch-workspace
        bento -t "Update Brunch" -c "Downloading the latest Brunch update, please wait..."
        curl -L -O --progress-bar "$(curl -s https://api.github.com/repos/sebanc/$update_channel/releases/latest | grep 'browser_' | cut -d\" -f4)"
        updatefile="$(find *runch*tar.gz 2> /dev/null | sort -r | head -1 )"
    # Call built in update command
        if [[ "$update_channel" == "brunch" ]] ; then
            compare_string=$latest_brunch_version
        else
            compare_string=$latest_brunch_unstable_version
        fi
    if (( $compare_string > 20210620 )) ; then
        bento -t "Update Brunch" -c "Newer releases of brunch have an updated internal Grub, would you like to update the EFI partition?" "This is suggested for most users." -m "Yes" "No" "Back" "Exit" -s "Update Brunch's internal grub" "Continue without updating the internal grub" "Go back to the previous menu" "Exit the toolkit" -a
        case "$selection" in
            "Back") cd "$curdir" ; "main_menu_startup" ; return ;;
            "Exit") exit 0 ;;
            "Yes") update_internal_grub="true" ;;
            "No") update_internal_grub="false" ;;
        esac
    fi

        bento -t "Update Brunch" -c "Now applying Brunch update, please wait..."
        if [[ "$update_internal_grub" == "true" ]] ; then
            sudo chromeos-update -f ~/tmp/brunch-workspace/"$updatefile" -e
        else
            sudo chromeos-update -f ~/tmp/brunch-workspace/"$updatefile"
        fi
        cd "$curdir"
    # clean up
        rm -rf ~/tmp/brunch-workspace/*
        sed -i "s/current_brunch_version=.*/current_brunch_version=$latest_brunch_version/" "$config_file"
        source "$config_file" 2> /dev/null
        update_complete="true"
        bento -t "Update Brunch" -c "Update complete" "Please reboot to see changes." -e
}

#</>

#<~> Updates and Notifications

check_for_updates(){
    if [[ "$onlineallowed" == true ]] && [[ ! "$autocheck" == "disabled" ]] || [[ "$force_update" == "true" ]] ; then
        bento -t "Network Check" -c "Checking for updates, please wait..."
      # Online calls - try to minimize calls
      # Look for announcements
        curl -s -l https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/announcement -o /var/brunch/toolkit/annoucement 2> /dev/null
        source /var/brunch/toolkit/annoucement 2> /dev/null
        if [[ "$announcement_ver" == "0" ]] ; then
            bento -n -cla -c "No Announcements"
        elif [[ -n "$announcement_ver" ]] ; then
            bento -n -cla -c "Found Announcement: $announcement_ver"
        fi
        if [[ "$toolkit_mode" =~ "brunch" ]] ; then
      # check for brunch releases
        latestbrunch=$(curl -s "https://api.github.com/repos/sebanc/brunch/releases/latest" | grep 'name' | cut -d\" -f4 | grep 'tar.gz' )
        # Strip all of the unnecessary bits off, integers only
        lbv1=${latestbrunch/unstable_}
        lbv2=${lbv1/stable_}
        lbv3=${lbv2/testing_}
        latestbrunchversion=$(echo "$lbv3" | cut -d'_' -f3 | cut -d'.' -f1)
        bento -n -cla -c "Found Brunch Version: $latestbrunchversion"


        if [[ "$get_unstable_updates" == "true" ]]; then
            latestbrunchunstable=$(curl -s "https://api.github.com/repos/sebanc/brunch-unstable/releases/latest" | grep 'name' | cut -d\" -f4 | grep 'tar.gz')
            # Strip all of the unnecessary bits off, integers only
            lbuv1=${latestbrunchunstable/unstable_}
            lbuv2=${lbuv1/stable_}
            lbuv3=${lbuv2/testing_}
            latestbrunchunstableversion=$(echo "$lbuv3" | cut -d'_' -f3 | cut -d'.' -f1)
            bento -n -cla -c "Found Brunch Unstable Version: $latestbrunchunstableversion"
        fi


    # get the latest ChromeOS release from cros.tech
        cros_url=$(curl -s https://cros.tech/device/$selected_recovery | tr ' ' '\n' | tr '>' '\n' | grep href= | sed 's/"//g' | sed 's/href=//g' | tail -1)
        #cros_release=$(curl https://cros.tech/device/$RECOVERYTODOWNLOAD | tr ' ' '\n' | tr '>' '\n' | sed 's/"//g' | sed 's/href=//g' | grep '</span' | sed 's/<\/span//g' | tail -1)
        cros_release=$(echo "$cros_url" | cut -d'_' -f2)
        bento -n -cla -c "Found ${selected_recovery^} Version: $cros_release"
        fi

        # Do this one last to measure github's api limit in a later script
        #latesttoolkit=$(curl -s https://api.github.com/repos/WesBosch/brunch-toolkit/releases/latest | grep 'name' | cut -d\" -f4 | grep '.sh' | cut -d'-' -f3 | sed -e s/.sh// )
        latesttoolkiturl=$(curl -s https://api.github.com/repos/WesBosch/brunch-toolkit/releases/latest  | grep 'browser_' | cut -d\" -f4 | grep '.sh')
        latesttoolkit=$(echo "$latesttoolkiturl" | cut -d'v' -f3 | sed 's/.sh//')
        latestsemversion=$(echo "$latesttoolkit" | sed -e "s/^v//" -e "s/b$//")
        bento -n -cla -c "Found Brunch Toolkit Version: $latestsemversion"
        # put a sleep delay here for aesthetic reasons Only
        sleep 1
    # store latest update versions until next check.
    # This lets us continue to notify for updates even without checking each time
        if [[ -n "$latesttoolkit" ]] ; then
            if [[ "$toolkit_mode" =~ "brunch" ]] ; then
            sed -i "s/latest_brunch_version=.*/latest_brunch_version=$latestbrunchversion/" "$config_file"
            sed -i "s/latest_brunch_unstable_version=.*/latest_brunch_unstable_version=$latestbrunchunstableversion/" "$config_file"
            sed -i "s/latest_chromeos_version=.*/latest_chromeos_version=$cros_release/" "$config_file"
            fi
            sed -i "s/latest_toolkit_version=.*/latest_toolkit_version=$latestsemversion/" "$config_file"
        fi
    fi

    # This one doesnt require a network connection and should always run to keep the config file updated
    currentsemversion=$(echo "$toolkitversion" | sed -e "s/^v//" -e "s/b$//")
    sed -i "s/current_toolkit_version=.*/current_toolkit_version=$currentsemversion/" "$config_file"
    source "$config_file" 2> /dev/null


 # Check if toolkit is outdated, strip down to numbers for versioning
    csvint1=$(echo "$current_toolkit_version" | cut -d'.' -f1)
    csvint2=$(echo "$current_toolkit_version" | cut -d'.' -f2)
    csvint3=$(echo "$current_toolkit_version" | cut -d'.' -f3)
    lsvint1=$(echo "$latest_toolkit_version" | cut -d'.' -f1)
    lsvint2=$(echo "$latest_toolkit_version" | cut -d'.' -f2)
    lsvint3=$(echo "$latest_toolkit_version" | cut -d'.' -f3)
    toolkit_update="false"
   if [ -z "$latest_toolkit_version" ] ; then
   :
   elif (( "$csvint1" < "$lsvint1" )) ; then
     toolkit_update="true"
   elif [ "$csvint1" == "$lsvint1" ] && (( "$csvint2" < "$lsvint2" )) ; then
     toolkit_update="true"
   elif [ "$csvint1" == "$lsvint1" ] && [ "$csvint2" == "$lsvint2" ] && (( "$csvint3" < "$lsvint3" )) ; then
     toolkit_update="true"
   else
     toolkit_update="false" # Toolkit version is greater or equal in all aspects, don't notify
   fi

if [[ "$toolkit_mode" =~ "brunch" ]] ; then
# Check if Brunch is outdated
   if [ -z "$latest_brunch_version" ] ; then
       stable_update="false"
   elif (( "$current_brunch_version" < "$latest_brunch_version" )) ; then
       stable_update="true"
   else
    stable_update="false"

   fi
   if [ -z "$latest_brunch_unstable_version" ] ; then
       unstable_update="false"
   elif (( "$current_brunch_version" < "$latest_brunch_unstable_version" )) ; then
       unstable_update="true"
   else
       unstable_update="false"
   fi

   # check if ChromeOS is outdated

 # Check if toolkit is outdated, strip down to numbers for versioning
    ccvint1=$(echo "$current_chromeos_version" | cut -d'.' -f1)
    ccvint2=$(echo "$current_chromeos_version" | cut -d'.' -f2)
    ccvint3=$(echo "$current_chromeos_version" | cut -d'.' -f3)
    lcvint1=$(echo "$latest_chromeos_version" | cut -d'.' -f1)
    lcvint2=$(echo "$latest_chromeos_version" | cut -d'.' -f2)
    lcvint3=$(echo "$latest_chromeos_version" | cut -d'.' -f3)
    chromeos_update="false"
   if [ -z "$latest_chromeos_version" ] ; then
   :
elif (( "$ccvint1" < "$lcvint1" )) ; then
     chromeos_update="true"
 elif [ "$ccvint1" == "$lcvint1" ] && (( "$ccvint2" < "$lcvint2" )) ; then
     chromeos_update="true"
 elif [ "$ccvint1" == "$lcvint1" ] && [ "$ccvint2" == "$lcvint2" ] && (( "$ccvint3" < "$lcvint3" )) ; then
     chromeos_update="true"
   else
     chromeos_update="false" # ChromeOS version is greater or equal in all aspects, don't notify
   fi

fi
sed -i "s/stable_update=.*/stable_update=$stable_update/" "$config_file"
sed -i "s/unstable_update=.*/unstable_update=$unstable_update/" "$config_file"
sed -i "s/chromeos_update=.*/chromeos_update=$chromeos_update/" "$config_file"
sed -i "s/toolkit_update=.*/toolkit_update=$toolkit_update/" "$config_file"
source "$config_file" 2> /dev/null

# Check if github's API limit has been reached or if Github is down
   if [[ $onlineallowed == true ]] && [[ -z "$latesttoolkit" ]] && [[ ! "$autocheck" == "disabled" ]] ||  [[ "$force_update" == "true" ]] && [[ -z "$latesttoolkit" ]] ; then
   bento -t "Network Check" -c "The toolkit is online, but the Github API limit has been reached." "Please wait a little while before trying again." -e
   onlineallowed="false"
   fi


   force_update="false"
}

check_for_notifications(){
    unset notify_content

    if [[ "$onlineallowed" == "false" ]] ; then
    notify_content+=("Currently Offline!")
    fi
    if [[ "$toolkit_update" == "true" ]] ; then
    notify_content+=("Brunch Toolkit update avaliable!")
    fi

    if [[ "$toolkit_mode" =~ "brunch" ]] ; then
    if [[ "$stable_update" == "true" ]] ; then
    notify_content+=("Brunch Stable update avaliable!")
    fi
    #if [[ "$chromeos_update" == "true" ]] ; then
    #notify_content+=("ChromeOS update avaliable!")
    #fi
    if [[ "$unstable_update" == "true" ]] && [[ "$get_unstable_updates" == "true" ]]; then
    notify_content+=("Brunch Unstable update avaliable!")
    fi
    fi
}

#</>

#<~> Compatibility Check/Report

compatibility_report(){
    d1="$(sudo dmidecode -s system-version)"
    d2="$(sudo dmidecode -s system-manufacturer)"
    d3="$(sudo dmidecode -s system-family)"
    d4="$(sudo dmidecode -s system-product-name)"
    model1="$d1"
    model2="$d2 $d3"
    model3="$d2 $d4"
    cpu="$(awk -F '\\s*: | @' \
    	'/model name|Hardware|Processor|^cpu model|chip type|^cpu type/ {
    	cpu=$2; if ($1 == "Hardware") exit } END { print cpu }' "/proc/cpuinfo")"
    echo "< RAM information"
    IFS=":" read -r a b < /proc/meminfo
    ram="${b/kB}"
    ram="$((ram/1024)) MB"
    rootdev="$(rootdev -d)"
    storage_prepare="$(< /sys/block/${rootdev##*/}/queue/rotational)"
    	case "$storage_prepare" in
    		1) storage_type="(HDD)" ;;
    		0) storage_type="(SSD)" ;;
    		*) storage_type="" ;;
    	esac
    storage="$(sudo lsblk -b -n -d -o SIZE $rootdev)"
    storage="$((storage/1024/1024/1024)) GB"
    if [[ "$rootdev" =~ .*"loop".* ]]; then
    	dualboot=1
    	if [ -n "$storage_type" ]; then
    		storage_model="(on ${storage_type//[()]/})"
    		storage="Image file ${storage_model}: $storage"
    	else
    		storage="Image file: $storage"
    	fi
    else
    	dualboot=0
    	storage_model="$(sudo lsblk -b -n -d -o MODEL $rootdev)"
    	if [ -z "$storage_model" ]; then
    		storage_model="Unknown drive ${storage_type} $storage"
    	fi
    	storage="$storage_model $storage"
    fi
    brunch="$(< /etc/brunch_version)"
    lsb_file="$(< /etc/lsb-release)"
    board="$(grep -o "^CHROMEOS_RELEASE_DESCRIPTION=.*" <<<"$lsb_file" | rev | cut -d " " -f 1,2 | rev)"
    board=$board
    board="${board% *}"
    version="$(grep -o "^CHROMEOS_RELEASE_CHROME_MILESTONE=.*" <<<"$lsb_file")"
    version="${version##*=}"
    build="$(grep -o "^CHROMEOS_RELEASE_VERSION=.*" <<<"$lsb_file")"
    build="${build##*=}"
    echo "< Linux information"
    hasorhasnot="$(vmc list)"
    if [[ "$hasorhasnot" =~ "termina".* ]]; then
    	linux_installed=1
    else
    	linux_installed=0
    fi
    menuopts=("Yes" "No" "Not Avaliable" "Back" "Exit")
    menuopts_model=("$model1" "$model2" "$model3" "None of these" "Back" "Exit")
    menuopts_model_sub=("Yes" "No" "Back" "Exit")
    page-android
}


page-android(){
        # navigation variables
        selection=
        previous=
        next="page-linux"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Android" -c "Does the Android Subsystem (Android apps) run?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) android="$selection" ; "$next" ;;
        esac
}

page-linux(){
        #Auto-detect linux if possible
        if [[ "$linux_installed" == 1 ]] ; then
		    linux="Yes"
		    linux_install="Yes"
            skipped="true"
            page-linux_run
        else
        # navigation variables
        selection=
        previous="page-android"
        next="page-linux_install"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Linux" -c "Is Linux container install option available?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) linux="$selection" ; "$next" ;;
        esac
        fi
}

page-linux_install(){
        # navigation variables
        selection=
        previous="page-linux"
        next="page-linux_run"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Linux" -c "Does the Linux container install?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) linux_install="$selection" ; "$next" ;;
        esac
}

page-linux_run(){
        # navigation variables
        selection=
        if [[ "$skipped" == true ]] ; then
            previous="page-android"
            skipped="false"
        else
            previous="page-linux_install"
        fi
        next="page-bluetooth"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Linux" -c "Does the Linux container run?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) linux_run="$selection" ; "$next" ;;
        esac
}

page-bluetooth(){
        # navigation variables
        selection=
        previous="page-linux_run"
        next="page-wifi"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Networking" -c "Is Bluetooth working?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) bluetooth="$selection" ; "$next" ;;
        esac
}

page-wifi(){
        # navigation variables
        selection=
        previous="page-bluetooth"
        next="page-camera"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Networking" -c "Is WiFi working?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) wifi="$selection" ; "$next" ;;
        esac
}

page-camera(){
        # navigation variables
        selection=
        previous="page-wifi"
        next="page-microphone"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Hardware" -c "Is the camera working?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) camera="$selection" ; "$next" ;;
        esac
}

page-microphone(){
        # navigation variables
        selection=
        previous="page-camera"
        next="page-touchscreen"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Hardware" -c "Is the microphone working?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) microphone="$selection" ; "$next" ;;
        esac
}

page-touchscreen(){
        # navigation variables
        selection=
        previous="page-microphone"
        next="page-trackpad"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Hardware" -c "Does the touchscreen work?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) touchscreen="$selection" ; "$next" ;;
        esac
}

page-trackpad(){
        # navigation variables
        selection=
        previous="page-touchscreen"
        next="page-model"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Hardware" -c "Does trackpad and gestures work?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) trackpad="$selection" ; "$next" ;;
        esac
}

page-model(){
        # navigation variables
        selection=
        previous="page-trackpad"
        next="page-results"
        # clear the screen and make a nice textbox"Does trackpad and gestures work?"
        bento -t "Compatibility Report - Model" -c "Which of the options best describes the model of your device?" -m "${menuopts_model[@]}" -a
        case "$selection" in
            "None of these") page-model_sub ;;
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) model="$selection" ; "$next" ;;
        esac
}

page-model_sub(){
        # navigation variables
        modelnumber=
        selection=
        previous_menu="page-model"
        next="page-results"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Model" -c "Enter the model of your device in your own way." -w
        case "$selection" in
            "Back") $previous_menu ;;
            "Exit") exit 0 ;;
            *) model="$selection" ; "$next" ;;
        esac
}

page-results(){
    clear
    echo "------------------------------"
    cat <<EOF | tee "$HOME"/MyFiles/Downloads/brunch-hwcomp.log.txt
$model
CPU: $cpu
RAM: $ram
Storage: $storage
Brunch: $brunch
Recovery: $board $version (build $build)
- Does the Android Subsystem (Android apps) run?
[$android]
- Is Linux container install option available?
[$linux]
- Does Linux container install?
[$linux_install]
- Does Linux terminal run?
[$linux_run]
- Is Bluetooth working?
[$bluetooth]
- Is WiFi working?
[$wifi]
- Is the camera working?
[$camera]
- Is microphone working?
[$microphone]
- Does the touchscreen work?
[$touchscreen]
- Does trackpad and gestures work?
[$trackpad]
EOF
    sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" -i "$HOME"/MyFiles/Downloads/brunch-hwcomp.log.txt
    echo ''
    echo "(Log saved to Downloads folder)"
    comp_repo_results=(
    "$model"
    "CPU: $cpu"
    "RAM: $ram"
    "Storage: $storage"
    "Brunch: $brunch"
    "Recovery: $board $version (build $build)"
    "div"
    "Does the Android Subsystem (Android apps) run?"
    "[$android]"
    "Is Linux container install option available?"
    "[$linux]"
    "Does Linux container install?"
    "[$linux_install]"
    "Does Linux terminal run?"
    "[$linux_run]"
    "Is Bluetooth working?"
    "[$bluetooth]"
    "Is WiFi working?"
    "[$wifi]"
    "Is the camera working?"
    "[$camera]"
    "Is microphone working?"
    "[$microphone]"
    "Does the touchscreen work?"
    "[$touchscreen]"
    "Does trackpad and gestures work?"
    "[$trackpad]"
    "div"
    "(brunch-hwcomp.log.txt saved to Downloads folder)"
    )
    previous_menu="main_menu_startup"
    bento -t "Compatibility Report - Results" -cla -c "${comp_repo_results[@]}" -r
}



loud_compatibility_check(){
    quiet_compatibility_check
    previous_menu="main_menu_startup"
    if [[ "$detected_recovery" == "unsupported" ]] ; then
        bento -t "Compatibility Check" -c "Your detected cpu is: $cputype" "div" "Your CPU is not recognized or is not compatible." -r
    else
        bento -t "Compatibility Check" -c "Your detected cpu is: $cputype" "div" "Your suggested recovery is $detected_recovery." -r
    fi
}

#</>

#<~> Advanced Options
# Some of these are backup options for other functions (such as when internet is disabled)
# Other options are just better suited for here due to complexity to prevent user error
advanced_options_menu(){
    unset advanced_opts
    unset advanced_subs
    if [[ -z "$brunch_editor" ]] ; then
        brunch_editor="nano"
    fi

    if [[ "$toolkit_mode" =~ "brunch" ]] ; then
        advanced_opts+=("Update Brunch from file")
        advanced_subs+=("Select a Brunch archive to update with")
        advanced_opts+=("Install/Update Toolchain from file")
        advanced_subs+=("Select a Brunch Toolchain archive to install/update with")
        advanced_opts+=("Edit Grub Manually")
        advanced_subs+=("Open Brunch's Grub config in $brunch_editor")
    else
        advanced_opts+=("Force Install Dependencies")
        advanced_subs+=("Install dependencies for Linux/Arch")
    fi
        advanced_opts+=("Edit Toolkit Config Manually")
        advanced_subs+=("Open the Brunch Toolkit's config in $brunch_editor")
        advanced_opts+=("Erase Toolkit Config")
        advanced_subs+=("Completely erases the Brunch Toolkit's config file")
        advanced_opts+=("Change editor (Currently $brunch_editor)")
        advanced_subs+=("Toggle which editor you'd like to use")

    bento -t "Advanced Options" -c "Proceed with caution" -m "${advanced_opts[@]}" "Back" "Exit" -s "${advanced_subs[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    case "$selection" in
        "Back")   main_menu_startup ; return ;;
        "Exit")   exit 0 ;;
        "Edit Toolkit Config Manually") edit_config ; advanced_options_menu ; return ;;
        "Edit Grub Manually") edit_grub_config ; advanced_options_menu ; return ;;
        "Erase Toolkit Config") erase_toolkit_config ; advanced_options_menu ; return ;;
        "Force Install Dependencies") dependency_search ; advanced_options_menu ; return ;;
        "Update Brunch from file") advanced_brunch_update ; advanced_options_menu ; return ;;
        "Install/Update Toolchain from file") install_toolchain_adv ; advanced_options_menu ; return ;;
        "Change editor (Currently $brunch_editor)")
                                                if [[ "$brunch_editor" == "nano" ]] ; then
                                                    brunch_editor="vi"
                                                else
                                                    brunch_editor="nano"
                                                fi
                                                sed -i "s/brunch_editor=.*/brunch_editor=$brunch_editor/" "$config_file"
                                                advanced_options_menu ; return ;;
    esac
}

#</>

#<~> Toolkit Settings
toolkit_settings_menu(){
    command -v bento >/dev/null 2>&1 && bento_installed="true" || bento_installed="false"
    previous_menu="main_menu_startup"
    source "$config_file" 2> /dev/null

        if [[ "$first_time_init" == "disabled" ]] ; then
            bs_ft="◯ First Time Init"
        elif [[ "$first_time_init" == "enabled" ]] ; then
            bs_ft="◆ First Time Init"
        else
            bs_ft="? First Time Init"
        fi

        if [[ "$startup_anim" == "disabled" ]] ; then
            bs_sa="◯ Startup Animation"
        elif [[ "$startup_anim" == "enabled" ]] ; then
            bs_sa="◆ Startup Animation"
        else
            bs_sa="? Startup Animatio"
        fi

        if [[ "$bento_boxes" == "disabled" ]] ; then
            bs_bb="◯ Bento"
        elif [[ "$bento_boxes" == "enabled" ]] ; then
            bs_bb="◆ Bento"
        else
            bs_bb="? Bento"
        fi

        if [[ "$tooltips" == "disabled" ]] ; then
            bs_tt="◯ Tooltips"
        elif [[ "$tooltips" == "enabled" ]] ; then
            bs_tt="◆ Tooltips"
        else
            bs_tt="? Tooltips"
        fi

        if [[ "$autocheck" == "disabled" ]] ; then
            bs_au="◯ Autocheck for Updates"
        elif [[ "$autocheck" == "enabled" ]] ; then
            bs_au="◆ Autocheck for Updates"
        else
            bs_au="? Autocheck for Updates"
        fi

        if [[ "$get_unstable_updates" == "false" ]] ; then
            bs_uu="◯ Check Unstable Updates"
        elif [[ "$get_unstable_updates" == "true" ]] ; then
            bs_uu="◆ Check Unstable Updates"
        else
            bs_uu="? Check Unstable Updates"
        fi


        if [[ "$advanced_options" == "disabled" ]] ; then
            bs_ao="◯ Advanced Options Menu"
        elif [[ "$advanced_options" == "enabled" ]] ; then
            bs_ao="◆ Advanced Options Menu"
        else
            bs_ao="? Advanced Options Menu"
        fi

            bs_sr="Selected Recovery:    ${selected_recovery^}"
            bs_tm="Toolkit Mode:         ${toolkit_mode^}"


        if [[ "$scaling" == "fit" ]] ; then
            scaling_tip="Fits the image to the canvas as well as it can. Quality may be lost at the risk of fitting the canvas as well as possible."
        elif [[ "$scaling" == "shrink" ]] ; then
            scaling_tip="Shrinks the image and tries to render a background automatically based on the top-left pixel. This is great for turning large images into centered icons"
        else
            scaling="center"
            scaling_tip="Centers the image and tries to render a background automatically based on the top-left pixel. Select this if your image is the right size already to preserve scale."
        fi

        if [[ "$test_convert" == "disabled" ]] ; then
            bs_tc="◯ Preview Image Conversion"
        elif [[ "$test_convert" == "enabled" ]] ; then
            bs_tc="◆ Preview Image Conversion"
        else
            bs_tc="◯ Preview Image Conversion"
        fi

unset toolkit_settings_opts
unset toolkit_settings_subs

toolkit_settings_opts=("Toggle or set settings for the Brunch Toolkit." -m "$bs_ft" "$bs_sa" "$bs_bb" "$bs_tt" "$bs_au" "$bs_uu" "$bs_ao" "$bs_tc" "Image Scaling Method: ${scaling^}" "$bs_sr" "$bs_tm" "Redo First Run" "Install/Update Bento" "Back" "Exit")
toolkit_settings_subs=("Enable/Disable First Time Init" "Enable/Disable Startup Animation" "Enable/Disable Bento" "Enable/Disable Tooltips" "Enable/Disable Autocheck" "Enable/Disable Checking for Unstable Updates" "Enable/Disable Advanced Menu Options" "Creates a test file called results.png in your Downloads when enabled." "$scaling_tip" "Select Recovery" "Select Toolkit Mode" "Replay the first time init to reset your settings" "Get Bento on the go!" "Replay the first time init to reset your settings" "Go back to the previous menu" "Exit the toolkit")

    bento -t "Toolkit Settings" -c "${toolkit_settings_opts[@]}" -s "${toolkit_settings_subs[@]}" -x

    case "$selection" in
        "$bs_ft")
                    if  [[ "$bs_ft" =~ "◯" ]] ; then
                        sed -i "s/first_time_init=.*/first_time_init=enabled/" "$config_file"
                    else
                        sed -i "s/first_time_init=.*/first_time_init=disabled/" "$config_file"
                    fi
                    ;;
        "$bs_sa")
                    if  [[ "$bs_sa" =~ "◯" ]] ; then
                        sed -i "s/startup_anim=.*/startup_anim=enabled/" "$config_file"
                    else
                        sed -i "s/startup_anim=.*/startup_anim=disabled/" "$config_file"
                    fi
                    ;;
        "$bs_bb")
                    if [[ "$bs_bb" =~ "◆" ]] ; then
                        sed -i "s/bento_boxes=.*/bento_boxes=disabled/" "$config_file"
                    else
                        sed -i "s/bento_boxes=.*/bento_boxes=enabled/" "$config_file"
                    fi
                    ;;
        "$bs_tt")
                    if [[ "$bs_tt" =~ "◆" ]] ; then
                        sed -i "s/tooltips=.*/tooltips=disabled/" "$config_file"
                    else
                        sed -i "s/tooltips=.*/tooltips=enabled/" "$config_file"
                    fi
                    ;;
        "$bs_au")
                    if [[ "$bs_au" =~ "◯" ]] ; then
                        sed -i "s/autocheck=.*/autocheck=enabled/" "$config_file"
                    else
                        sed -i "s/autocheck=.*/autocheck=disabled/" "$config_file"
                    fi
                    ;;
        "$bs_ao")
                    if [[ "$bs_ao" =~ "◆" ]] ; then
                        sed -i "s/advanced_options=.*/advanced_options=disabled/" "$config_file"
                    else
                        sed -i "s/advanced_options=.*/advanced_options=enabled/" "$config_file"
                    fi
                    ;;
        "$bs_uu")
                    if [[ "$bs_uu" =~ "◯" ]] ; then
                        sed -i "s/get_unstable_updates=.*/get_unstable_updates=true/" "$config_file"
                    else
                        sed -i "s/get_unstable_updates=.*/get_unstable_updates=false/" "$config_file"
                    fi
                    ;;
        "$bs_sr")
                    previous_menu="toolkit_settings_menu"
                    select_a_recovery
                    sed -i "s/selected_recovery=.*/selected_recovery=$selected_recovery/" "$config_file"
                    ;;
        "$bs_tc")
                    if [[ "$test_convert" == "enabled" ]] ; then
                        test_convert="disabled"
                    else
                        test_convert="enabled"
                    fi
                    ;;
        "Image Scaling Method: ${scaling^}")
                        if [[ "$scaling" == "fit" ]] ; then
                            scaling="shrink"
                        elif [[ "$scaling" == "shrink" ]] ; then
                            scaling="center"
                        else
                            scaling="fit"
                        fi
                            sed -i "s/scaling=.*/scaling=$scaling/" "$config_file"
                        ;;

        "$bs_tm") previous_menu="toolkit_settings_menu" ; select_toolkit_mode ;;
        "Redo First Run") second_run_init ; return ;;
        "Install/Update Bento") install_bento_tk ; return ;;
        "Back")   "$previous_menu" ; return ;;
        "Exit")   exit 0 ;;
    esac

    # loop this menu until the user specifically exits or goes back
    toolkit_settings_menu
}

select_toolkit_mode(){
    previous_menu="toolkit_settings_menu"
    source "$config_file" 2> /dev/null
    toolkit_modes=(
    "brunch"
    "brunch_usb"
    "brunch_dualboot"
    "linux"
    "linux_usb"
    "linux_wsl"
    "arch"
    "arch_usb"
    "arch_wsl"
    )

    unset toolkit_mode_options
    for elem in "${toolkit_modes[@]}" ; do
    if [[ "$elem" == "$toolkit_mode" ]] ; then
        toolkit_mode_options+=("◆ $elem")
    else
        toolkit_mode_options+=("◯ $elem")
    fi
    done

    toolkit_mode_subs=(
    "Brunch (Singleboot)"
    "Brunch (USB)"
    "Brunch (Dualboot)"
    "Ubuntu/Debian/Mint based distro"
    "Ubuntu/Debian/Mint based distro"
    "Ubuntu/Debian/Mint based distro"
    "Arch based distro"
    "Arch based distro"
    "Arch based distro"
    )

    bento -t "Select Toolkit Mode" -c "This setting changes which options are avaliable in the toolkit." "div" "Currently running in $toolkit_mode mode." -m "${toolkit_mode_options[@]}" "Back" "Exit"
    if [[ "$selection" =~ (◆|◯) ]] ; then
        selection=${selection:4}
    fi
    case "$selection" in
        "Back") "$previous_menu" ; return ;;
        "Exit") exit 0 ;;
        *) sed -i "s/toolkit_mode=.*/toolkit_mode=$selection/" "$config_file" ;;
    esac

    # loop this menu until the user specifically exits or goes back
    select_toolkit_mode
}

second_run_init(){
    rm "$config_file"
    bento -c "Preparing to replay first time init, please wait..."
    first_time_init="enabled"
    sleep 1
    check_for_config
    startup_anim
    first_time_init_startup
    main_menu_startup
}

erase_toolkit_config(){
    previous_menu="toolkit_settings_menu"
    rm "$config_file"
}

edit_config(){
    previous_menu="toolkit_settings_menu"
    "$brunch_editor" "$config_file"
}


edit_grub_config(){
check_for_dualboot
# Look for the new flavor of grub, and adjust these variables as needed
brunch_config="$HOME/tmp/brunch-workspace/efi/boot/settings.cfg"
mount_grub
if [[ ! -e "$brunch_config" ]] ; then
    brunch_config="$HOME/tmp/brunch-workspace/efi/boot/grub.cfg"
fi
    previous_menu="toolkit_settings_menu"
    sudo "$brunch_editor" "$brunch_config"
    unmount_grub
}

install_bento_tk(){
        if [[ "$onlineallowed" == "true" ]] ; then
        mkdir -p ~/tmp/brunch-workspace
        bento -t "Install Bento" -c "Downloading the latest Bento release, please wait..."
    curl -l https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/bento -o ~/tmp/brunch-workspace/bento
    sudo install -Dt /usr/local/bin -m 755 ~/tmp/brunch-workspace/bento
        bento -t "Install Bento" -c "Install complete" "Exit and run the command 'bento' to see how it works!." -e
        else
        bento -t "Install Bento" -c "Unable to install Bento!" "Make sure your internet connection is stable and try again." "You can also install manually by downloading Bento from:" "https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/bento" "then run: bash ~/Downloads/bento --install" -e
            # Install it from here?
        fi
}
#</>

#<~> Announcements

# Use this to display important annoucements about brunch, updates, etc..
check_for_announcements(){
    if [[ "$onlineallowed" == "true" ]] && [[ "$autocheck" == "enabled" ]] ; then
        curl -l https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/announcement -o /var/brunch/toolkit/annoucement
        source /var/brunch/toolkit/annoucement 2> /dev/null
    fi

    if [[ -z "$saved_announcement_ver" ]] ; then
        saved_announcement_ver="0"
    fi

    if (( $announcement_ver > $saved_announcement_ver )) ; then
        sed -i "s/saved_announcement_ver=.*/saved_announcement_ver=$announcement_ver/" "$config_file"
        bento -t "Announcement" -c "${announcement[@]}" -e
    fi
}

#</>

#<~> Debug functions go here
# Currently working on:

toolkit_debug(){
 function test_unicode {
  echo -ne "\xe2\x88\xb4\033[6n\033[1K\r"
  read -d R foo
  echo -ne "\033[1K\r"
  echo -e "${foo}" | cut -d \[ -f 2 | cut -d";" -f 2 | (
    read UNICODE
    [ $UNICODE -eq 2 ] && return 0
    [ $UNICODE -ne 2 ] && return 1
  )
}

test_unicode
RC=$?
export UNICODE_SUPPORT=`[ $RC -eq 0 ] && echo "Unicode Supported" || echo "Unicode is not supported"`
echo "$UNICODE_SUPPORT"
echo "Examples: ↑ ↓ ⏎ ◆ ◯ ➤"
unset test_unicode#!/bin/bash
readonly toolkitversion="v2.9.1"
readonly discordinvite="https://discord.gg/x2EgK2M"

#<~> Brunch Config Variables (Kernels, Framework options, etc)
# All currently known framework options. Update this list as necessary (any order)
readonly fwo_page1=(
"acpi_power_button"
"advanced_als"
"alt_touchpad_config"
"alt_touchpad_config2"
"android_init_fix"
"asus_c302"
"baytrail_chromebook"
"disable_intel_hda"
"enable_updates"
"force_tablet_mode"
"More Options"
)

readonly fwo_page2=(
"goodix"
"internal_mic_fix"
"invert_camera_order"
"ipts"
"mount_internal_drives"
"no_camera_config"
"oled_display"
"pwa"
"suspend_s3"
"sysfs_tablet_mode"
"rtbth"
"Wifi Options"
)

readonly fwo_wifi=(
"broadcom_wl"
"iwlwifi_backport"
"rtl8188eu"
"rtl8188fu"
"rtl8192eu"
"rtl8723bu"
"rtl8723de"
"rtl8723du"
"rtl8812au"
"rtl8814au"
"rtl8821ce"
"rtl8821cu"
"rtl88x2bu"
"Other Options"
)

# All currently known descriptions. Mind string length
readonly fwo_page1_subs=(
"Patches support for the power button menu on some hardware"
"Patches in more auto-brightness levels on supported hardware"
"Useful for debugging touchpad issues"
"Useful for debugging touchpad issues"
"Patch the android config on ChromeOS 91 and higher"
"Hardware specific patches for the Asus c302"
"Hardware specific patches for Baytrail Chromebooks"
"Blacklists the snd_hda_intel module"
"Enable updating natively from the settings menu"
"Allows control of tablet mode from sysfs"
"Display More Options"
)

readonly fwo_page2_subs=(
"Patches to support Goodix touchscreens"
"Forcefull enable the microphone on some hardware"
"Swap default camera order"
"Enable support for some Surface touchscreens"
"Automatically mount internal drive partitions on login"
"Disables the camera config"
"Patch for OLED displays (use with Kernel 5.10)"
"Enable support for the Brunch PWA"
"Disable suspend to idle (S0ix) and use S3 suspend instead"
"Allows control of tablet mode from sysfs"
"Patches for RT3290/RT3298LE bluetooth devices"
"Display Wifi Options"
)

readonly fwo_wifi_subs=(
"Patch in support for some Broadcom wifi cards"
"Patch in support for some Intel wifi cards"
"Patch in support for rtl8188eu wifi cards"
"Patch in support for rtl8188fu wifi cards"
"Patch in support for rtl8192eu wifi cards"
"Patch in support for rtl8723bu wifi cards"
"Patch in support for rtl8723de wifi cards"
"Patch in support for rtl8723du wifi cards"
"Patch in support for rtl8812au wifi cards"
"Patch in support for rtl8814au wifi cards"
"Patch in support for rtl8821ce wifi cards"
"Patch in support for rtl8821cu wifi cards"
"Patch in support for rtl88x2bu wifi cards"
"Display Other Options"
)

# Currently avaliable kernels
readonly avaliablekernels=(kernel-4.19 kernel-5.4 kernel-5.10 kernel-chromebook)

#</>

#<~> Brunch Toolkit intro
#
# Welcome to the brunch toolkit. I've tried my best to make this code legible,
# send any bug reports to Wisteria on the brunch discord. https://discord.gg/x2EgK2M
#
# This is a near-complete rewrite of my original toolkit. Expect bugs
#
#</>

#<~> Bento boxes - Brunch's ENhanced Text Options
#
# This is the code that makes boxes possible,
# When 'bento_boxes=disabled' then the script will not draw boxes.
#
bento_version="1.0.8"
bento_usage(){

# Set variables to use in the menu
  bento_help_menu_title=("Bento $bento_version - Help Menu")
  bento_help_menu_contents=("Welcome to Bento." "Brunch's ENhanced Text Options")
  bento_help_menu_options=("Usage" "Examples" "Support" "Exit")
  bento_help_menu_tooltips=("How to use Bento" "How this menu was made" "Where to get support" "Exit")

# Use bento to generate a textbox and menu from the above variables
  bento -g -t "$bento_help_menu_title" -c "${bento_help_menu_contents[@]}" -m "${bento_help_menu_options[@]}" -s "${bento_help_menu_tooltips[@]}"

# Set a return point using function names, then parse selection.
  previous_menu="bento_usage"
  case "$selection" in
    "Usage") bento_usage_sub1 ; return ;;
    "Examples") bento_usage_sub2 ; return ;;
    "Support") bento_usage_sub3 ; return ;;
    "Exit") exit 0 ;;
  esac
 }

bento_usage_sub3(){
    clear
# make a textbox with a link to discord and some minor info about this script
    bento -t "Bento - Further Support" -c "This whole project was made by a beginner, and has been modified greatly over time as they learned more." "If you'd like to know anything specific, you can find Wisteria in the Brunch discord group." " " "https://discord.gg/x2EgK2M" -r
}

bento_usage_sub2(){
    clear
# make a textbox to describe the content of this page
    bento -t "Bento - Examples" -c "Here is how the previous menu was made:"

# output the main help menu's code as an example
echo 'bento_usage(){

# Set variables to use in the menu
  bento_help_menu_title=("Bento - Help Menu")
  bento_help_menu_contents=("Welcome to Bento." "Brunchs ENhanced Text Options")
  bento_help_menu_options=("Usage" "Examples" "Support" "Exit")
  bento_help_menu_tooltips=("How to use Bento" "How this menu was made" "Where to get support" "Exit")

# Use bento to generate a textbox and menu from the above variables
  bento -g -t "$bento_help_menu_title" -c "${bento_help_menu_contents[@]}" -m "${bento_help_menu_options[@]}" -s "${bento_help_menu_tooltips[@]}"

# Set a return point using function names, then parse selection.
  previous_menu="bento_usage"
  case "$selection" in
    "Usage") bento_usage_sub1 ; return ;;
    "Examples") bento_usage_sub2 ; return ;;
    "Support") bento_usage_sub3 ; return ;;
    "Exit") exit 0 ;;
  esac
 }'

# make another textbox with the -n (noclear) flag to have multiple textboxes on screen
    bento -c "As you can see, the main command is bento with a handful of flags and arrays afterwards. Then we use something like case to parse the selection made in the menu, and send users off to their destinations." -r -n
}

bento_usage_sub1(){
    clear
# One very large formatted array. It's split by line between elements to more easily align content
    bento_usage_contents=(
    "Basic Usage - Flags accepting options"
    ""
    "These flags are all meant to be used with options afterwards to generate content."
    'Options can be strings, $variables or ${arrays[@]}. The format is: -flag $option'
    ""
    "(-c|--content)     The following options will make up the textbox. (like this one!) "
    "(-m|--menu)        The options listed here will become selectable options for the user."
    "(-mm|--multimenu)  The options here can be toggled and multiselected together"
    "(-s|--subtitles)   These options act as on screen tooltips for the menu options."
    "(-t|--title)       This will define the titlebar displayed at the top of the box."
    "div"
    "Advanced Usage - Special flags"
    ""
    "The following flags do not accept options, and can be used to modify your boxes."
    ""
    "(-b|--boxless)     This option will disable box drawing and just display plain text."
    "(-g|--glyph)       This option turns on doublelined boxes, like what this menu uses."
    "(-n|--noclear)     Prevent Bento clearing the screen before and after making boxes."
    '(-w|--write)       User input is directed into the $selection variable'
    ""
    "(-a|--arrows)      Displays a small usage tip for selecting items in the menu. "
    "(-e|--exit)        Displays a small usage tip for exiting the script."
    '(-r|--return)      Displays a small usage tip for returning to the $previous_menu.'
    "(-x|--toggle)      Displays a small useage tip for toggling options on or off."
    "                   (This also will switch menu selection to toggle mode.)"
    "div"
    "Other useful features"
    ""
    "Array elements matching 'div' or ' ' (empty) will create dividers and spaces."
    "Array elements matching 'lid' or 'btm' will create seperate box tops and bottoms."
    "Textboxes will attempt to size themselves according to the user's terminal."
    "If a user's screen is too small, bento will not draw boxes to keep things simple."
    "If content does not fit on one line in a textbox, it will attempt to wordwrap."
    "div"
    "Alignment"
    ""
    "Elements can be aligned with a wide degree of customization."
    ""
    "(-ra|--rightaligned) (-la|--leftaligned)                   Align all text"
    "(-tra|--titlerightaligned) (-tla|--titleleftaligned)       Align title text"
    "(-cra|--contentrightaligned) (-cla|--contentrightaligned)  Align content text"
    "(-sra|--subrightaligned) (-sla|--subleftaligned)           Align tooltip text"
    "(-mra|--menurightaligned) (-mca|--menucenteraligned)       Align menu text"
    "(note that menu text defaults to be left aligned, all other text is centered)"
    )

# Make a simple box based on the above array.
    bento -t "Bento - Usage" -cla -c "${bento_usage_contents[@]}" -r
}

#<~> Bento funtions
bento(){
    if [[ -z "$*" ]] ; then
        bento_usage
    fi
    # preset variable defaults to keep menus from acidentally merging into eachother
    terminal_width=$(tput cols)             # query the Terminfo database: number of columns
    box_width=$(( terminal_width - 8 ))     # set the width of the box with a buffer
    if [[ "$bento_boxes" == "disabled" ]] ; then
        boxless="true"
    elif (( terminal_width < 50 )) ; then
      boxless="true"
    else
      boxless="false"
    fi
    glyph="─"
    noclear="false"
    keys_opt_arrows="Arrow Keys Up/Down (↑/↓)  Press Enter (⏎) to select."
    keys_opt_return="Press Enter (⏎) to return to the previous menu."
    keys_opt_exit="Press Enter (⏎) to continue."
    keys_opt_input="Type your selection, then press Enter (⏎) to continue."
    keys_opt_toggle="Arrow Keys Up/Down (↑/↓)  Press Enter (⏎) to toggle."
    toggle_hint="Options marked with ◯ are disabled, ◆ are enabled.  "
    arrows="false"
    return="false"
    toggle="false"
    rightaligned="false"
    leftaligned="false"
    crightaligned="false"
    cleftaligned="false"
    trightaligned="false"
    tleftaligned="false"
    srightaligned="false"
    sleftaligned="false"
    mrightaligned="false"
    mcenteraligned="false"
    multiselection="false"
    exit="false"
    input="false"
    # parse bento flags here
    PARAMS=""
while (( "$#" )); do
  case "$1" in
    -w|--write)
    # set $selection to a written in input with read
      input="true"
      shift
      ;;
    -ra|--rightaligned)
    # Align all text to the right
      rightaligned="true"
      shift
      ;;
    -la|--leftaligned)
    # Align all text to the left
      leftaligned="true"
      shift
      ;;
    -cra|--contentrightaligned)
    # Align all -c content to the right
      crightaligned="true"
      shift
      ;;
    -cla|--contentleftaligned)
    # Align all -c content to the left
      cleftaligned="true"
      shift
      ;;
    -tra|--titlerightaligned)
    # Align -t title to the right
      trightaligned="true"
      shift
      ;;
    -tla|--titleleftaligned)
    # Align -t title to the left
      tleftaligned="true"
      shift
      ;;
    -sra|--subrightaligned)
    # Align -s subtitle/tooltips to the right
      srightaligned="true"
      shift
      ;;
    -sla|--subleftaligned)
    # Align -s subtitle/tooltips to the right
      sleftaligned="true"
      shift
      ;;
    -mra|--menurightaligned)
    # Align -m menu options to the right
      mrightaligned="true"
      shift
      ;;
    -mca|--menucenteraligned)
    # Align -m menu options to the left
      mcenteraligned="true"
      shift
      ;;
    -b|--boxless)
    # Dont draw boxes (sets all box components to "")
      boxless="true"
      shift
      ;;
    -u|--update)
    # Display bento help menu
      bento_update
      exit 0
      ;;
    -i|--install)
    # Display bento help menu
      bento_install
      exit 0
    ;;
    -h|--help)
    # Display bento help menu
      bento_usage
      exit 0
      ;;
    -d|--debug)
    # Display bento debug menu
      bento_debug
      exit 0
      ;;
    -a|--arrows)
    # displays: "Arrow Keys Up/Down (↑/↓)  Press Enter (⏎) to select." under content
      arrows="true"
      shift
      ;;
    -r|--return)
    # displays: "Press Enter (⏎) to return to the previous menu." under content
    # waits for input then returns to $previous_menu
      return="true"
      shift
      ;;
    -e|--exit)
    # displays: "Press Enter (⏎) to continue." under content
    # waits for input, does not set a $selection and continues to next function
      exit="true"
      shift
      ;;
    -x|--toggle)
    # Work in progress
    # displays: "Arrow Keys Up/Down (↑/↓)  Press Enter (⏎) to toggle." "Options marked with ◯ are disabled, ◆ are enabled." under content
      toggle="true"
      shift
      ;;
    -g|--glyph)
    # Sets textbox borders to doublelined bars
      glyph="true"
      shift
      ;;
    -n|--noclear)
    # does not 'clear' when starting a textbox
      noclear="true"
      shift
      ;;
    -t|--title)
    # displays all options until the next -flag as a title, supports multiple lines
      if [ -n "$2" ] ; then
          # shift to next variable, the -flag is not included
          shift 1
          array=("$@")
          for ((i = 0; i < ${#array[@]}; ++i)); do
          # keep looping for every option to add them to our array
          if [[ "${array[$i]}" == -* ]] ; then
              break # end loop at next flag
          else
              title+=("${array[$i]}")
          fi
          done
      else
        echo "Error: Argument for $1 is missing" >&2
        exit 1
      fi
      ;;
    -c|--content)
    # displays all options until the next -flag as content, supports multiple lines
      if [ -n "$2" ] ; then
          # shift to next variable, the -flag is not included
          shift 1
          array=("$@")
          for ((i = 0; i < ${#array[@]}; ++i)); do
          # keep looping for every option to add them to our array
          if [[ "${array[$i]}" == -* ]] ; then
              break # end loop at next flag
          else
              content+=("${array[$i]}")
          fi
          done
      else
        echo "Error: Argument for $1 is missing" >&2
        exit 1
      fi
      ;;
    -m|--menu)
    # displays all options until the next -flag as menu options, supports multiple lines
      if [ -n "$2" ] ; then
          # shift to next variable, the -flag is not included
          shift 1
          array=("$@")
          for ((i = 0; i < ${#array[@]}; ++i)); do
          # keep looping for every option to add them to our array
          if [[ "${array[$i]}" == -* ]] ; then
              break # end loop at next flag
          else
              menu+=("${array[$i]}")
          fi
          done
      else
        echo "Error: Argument for $1 is missing" >&2
        exit 1
      fi
      ;;
  -mm|--multimenu)
  # displays all options until the next -flag as menu options, supports multiple lines
    if [ -n "$2" ] ; then
        # shift to next variable, the -flag is not included
        shift 1
        array=("$@")
        for ((i = 0; i < ${#array[@]}; ++i)); do
        # keep looping for every option to add them to our array
        if [[ "${array[$i]}" == -* ]] ; then
            break # end loop at next flag
        else
            multimenu+=("${array[$i]}")
        fi
        done
        # to allow for multiple selections, add a confirmation option at the end and set a var
            multimenu+=("Confirm Selection")
            # let the script know we're doing something complicated here
            multiselection="true"
    else
      echo "Error: Argument for $1 is missing" >&2
      exit 1
    fi
    ;;
    -s|--subtitles)
    # displays all options until the next -flag as tooltip text, supports multiple lines
      if [ -n "$2" ] ; then
          # shift to next variable, the -flag is not included
          shift 1
          array=("$@")
          for ((i = 0; i < ${#array[@]}; ++i)); do
          # keep looping for every option to add them to our array
          if [[ "${array[$i]}" == -* ]] ; then
              break # end loop at next flag
          else
              submenu+=("${array[$i]}")
          fi
          done
      else
        echo "Error: Argument for $1 is missing" >&2
        exit 1
      fi
      ;;
    --*=|-*) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
    *) # preserve positional arguments
      PARAMS="$PARAMS $1"
      shift
      ;;
  esac
done
# set positional arguments in their proper place
eval set -- "$PARAMS"

    if [[ "$noclear" == false ]] ; then
    clear
    fi

# generate the title
    if [[ -n "$title" ]] ; then
        # set alignment
        if [[ "$trightaligned" == "true" ]] ; then
            rightaligned="true"
        elif [[ "$tleftaligned" == "true" ]] ; then
            leftaligned="true"
        fi
        # if boxes are disabled, dont bother with formattting
        if [[ "$boxless" == "false" ]] ; then
            echo ""
            # make top of the box
            bento_vars
            printf "  ${top_left_corner}${left_bar}${topbar}${right_bar}${top_right_corner}\n"
        fi
        # loop for each line in the box
        for line in "${title[@]}"; do
            bento_vars
            # if the text is too long, split it into another line
            if (( (text_width + 8) > terminal_width )) ; then
                long_title="$(echo "$line" | fold -w $box_width -s)"
                IFS=$'\n'
                multi_array=($long_title)
                unset IFS
                multititle "${multi_array[@]}"
            else
                printf "  ${left_wall}\033[7m${title_left_border}${filler}${line}${filler}${title_right_border}\033[27m${right_wall}\n"
            fi
        done
        # if theres no content, make a box bottom instead of a divider
        if [[ -z "$content" ]] && [[ "$boxless" == "false" ]] ; then
            printf "  ${btm_left_corner}${left_bar}${topbar}${right_bar}${btm_right_corner}\n"
        elif [[ -n "$content" ]] && [[ "$boxless" == "false" ]] ; then
            printf "  ${left_div_wall}${left_bar}${topbar}${right_bar}${right_div_wall}\n"
        fi
    else
        # if theres no title, just make the top of the box
        echo ""
        bento_vars
        printf "  ${top_left_corner}${left_bar}${topbar}${right_bar}${top_right_corner}\n"
    fi
        # unset alignment if it was only for this section
        if [[ "$trightaligned" == "true" ]] || [[ "$tleftaligned" == "true" ]] ; then
            rightaligned="false"
            leftaligned="false"
        fi

    # generate the content
    if [[ -n "$content" ]] ; then
        # set alignment
        if [[ "$crightaligned" == "true" ]] ; then
            rightaligned="true"
        elif [[ "$cleftaligned" == "true" ]] ; then
            leftaligned="true"
        fi
        # loop for each line in the box
        for line in "${content[@]}"; do
            bento_vars
            # if the text is too long, split it into another line
            if (( (text_width + 8) > terminal_width )) ; then
            long_content="$(echo "$line" | fold -w $box_width -s)"
            IFS=$'\n'
            multi_array=($long_content)
            unset IFS
            multibox "${multi_array[@]}"
            else
            printf "  ${left_wall}${left_border}${filler}${line}${filler}${right_border}${right_wall}\n"
            fi
        done
        if [[ "$boxless" == "false" ]] ; then
            printf "  ${btm_left_corner}${left_bar}${topbar}${right_bar}${btm_right_corner}\n"
        fi
    fi

# display optional guides
    if [[ "$arrows" == "true" ]] || [[ "$return" == "true" ]] || [[ "$exit" == "true" ]] || [[ "$toggle" == "true" ]] ; then
        if [[ "$arrows" == "true" ]] ; then
            line="${keys_opt_arrows}"
        elif [[ "$return" == "true" ]] ; then
            menu="previous_menu"
            line="${keys_opt_return}"
        elif [[ "$exit" == "true" ]] ; then
            menu="continue"
            line="${keys_opt_exit}"
        elif [[ "$input" == "true" ]] ; then
            line="${keys_opt_input}"
        elif [[ "$toggle" == "true" ]] ; then
            line="${keys_opt_toggle}"
        fi
        bento_vars
        if (( (text_width + 8) > terminal_width )) ; then
            long_content="$(echo "$line" | fold -w $box_width -s)"
            IFS=$'\n'
            multi_array=($long_content)
            unset IFS
            multistep "${multi_array[@]}"
        else
            printf "     ${left_border}${line}${right_border} \n"
        fi
    fi
    if [[ "$toggle" == "true" ]] ; then
        line="$toggle_hint"
        bento_vars
        if (( (text_width + 8) > terminal_width )) ; then
            long_content="$(echo "$line" | fold -w $box_width -s)"
            IFS=$'\n'
            multi_array=($long_content)
            unset IFS
            multistep "${multi_array[@]}"
        else
            printf "     ${left_border}${line}${right_border} \n"
        fi
    fi
    # unset alignment if it was only for this section
    if [[ "$crightaligned" == "true" ]] || [[ "$cleftaligned" == "true" ]] ; then
        rightaligned="false"
        leftaligned="false"
    fi

    # generate the menu
    if [[ -n "$menu" ]] || [[ -n "$multimenu" ]]; then
            echo ""
            menumaker
    fi

    # if using a user-generated input...
    if [[ "$input" == "true" ]] ; then
        echo ""
        input_reader
        selection="$input_selection"
    fi

    bento_cleanup
}

input_reader(){
    input_selection=""
    if [[ "$boxless" == "true" ]] ; then
        b="-b"
    fi
    read -rp ' >> ' input_selection
    bento_cleanup
    if [[ -z "$input_selection" ]] ; then
    bento $b -t "Confirm" -c "Continue without entering anything?" -m "Yes" "No" "Back" "Exit" -s "Confirm entry" "Try again" "Go back to the previous menu" "Exit without saving"
    else
    bento $b -t "Confirm" -c "Is this correct?" "$input_selection" -m "Yes" "No" "Back" "Exit" -s "Confirm entry" "Try again" "Go back to the previous menu" "Exit without saving"
    fi
    case "$selection" in
        "Yes") return ;;
        "No") input_reader ; return ;;
        "Back") $previous_menu ; return ;;
        "Exit") exit 0 ;;
    esac

}

menumaker(){
    unset selection
    if [[ "$multiselection" == "true" ]] ; then
        if [[ -n "${menu[*]}" ]] ; then
            for ((i = 0; i < ${#menu[@]}; ++i)); do
                # keep looping for every option to add them to our array
                multimenu+=("${menu[$i]}")
            done
            unset menu
        fi
        for ((i = 0; i < ${#multimenu[@]}; ++i)); do
            # keep looping for every option to add them to our array
            menu+=("${multimenu[$i]}")
        done
        unset multimenu
    fi
    select_opt "${menu[@]}"
        # parse selection
        if [[ "$selection" == "previous_menu" ]] ; then
            bento_cleanup
            unset selection
            $previous_menu
        elif [[ "$selection" == "continue" ]] ; then
                bento_cleanup
                unset selection
                : # continue to the next part of script logically
        elif [[ -n "$selection" ]] ; then
        echo ""
        echo ""
                echo "[o] User selected: ${selection[*]}"
        fi
        bento_cleanup
}

bento_cleanup(){
    # cleanup arrays for next box
    unset title
    unset content
    unset menu
    unset multimenu
    unset submenu
    unset line
    unset long_title
    unset long_content
    unset multi_array
    unset array
    unset multi
}

bento_vars(){
    padding="2"
    text_width=${#line}
    size_limit=$(( text_width + 8 ))
    if (( size_limit < 40 )) ; then
      size_limit="40"
    fi
    title_text_width=${#line}
    title_size_limit=$(( title_text_width + 8 ))
    if (( title_size_limit < 40 )) ; then
      title_size_limit="40"
    fi
    # Glyph settings
    filler=" "                              # box filler, just use spaces
    title_filler="░"                        # title box filler
    # make matching corners and walls as necessary
      possible_bars=(─ ═)
     left_div_walls=(├ ╠)
    right_div_walls=(┤ ╣)
   top_left_corners=(┌ ╔)
   btm_left_corners=(└ ╚)
  top_right_corners=(┐ ╗)
  btm_right_corners=(┘ ╝)
              walls=(│ ║)
  if [[ "$glyph" == "true" ]] ; then
      top_left_corner="╔"
      top_right_corner="╗"
      btm_left_corner="╚"
      btm_right_corner="╝"
      left_wall="║"
      right_wall="║"
      left_div_wall="╠"
      right_div_wall="╣"
      topbar="═"
  else
      top_left_corner="┌"
      top_right_corner="┐"
      btm_left_corner="└"
      btm_right_corner="┘"
      left_wall="│"
      right_wall="│"
      left_div_wall="├"
      right_div_wall="┤"
      topbar="─"
  fi
    # some bars are a bit short, align them appropriately
    short_bars=(─━┄┅┈┉╌╍═░▒▓)
    if [[ "${short_bars[@]}" =~ "$topbar" ]] && [[ "${short_bars[@]}" != "" ]]; then
    bar_width=$(( ((terminal_width - (padding * 2) - 1) / 2) - 1 ))
    else
    bar_width=$(( ((terminal_width - (padding * 2) - 1) / 2) - 2 ))
    fi
    border_width=$(( ((terminal_width - (padding * 2) - text_width) / 2) - 2 ))
    title_border_width=$(( ((terminal_width - (padding * 2) - title_text_width) / 2) - 2 ))
    border=                         # shape of the border
    title_border=                         # shape of the border
    bar=

    # special search/replace for making dividers

    # special search/replace for making dividers
    if [[ "$line" == "div" ]] ; then
        line="$topbar$topbar$topbar"
        filler="$topbar"
        title_filler="$topbar"
        left_wall="$left_div_wall"
        right_wall="$right_div_wall"

    elif [[ "$line" == "lid" ]] ; then
        line="$topbar$topbar$topbar"
        filler="$topbar"
        title_filler="$topbar"
        left_wall="$top_left_corner"
        right_wall="$top_right_corner"

    elif [[ "$line" == "btm" ]] ; then
        line="$topbar$topbar$topbar"
        filler="$topbar"
        title_filler="$topbar"
        left_wall="$btm_left_corner"
        right_wall="$btm_right_corner"

    fi
    # create the border (left side or right side)
    for ((i=0; i<border_width; i++))
    do
        border+="${filler}"
    done
    for ((i=0; i<title_border_width; i++))
    do
        title_border+="${title_filler}"
    done
    # create the topbar (left side or right side)
    for ((i=0; i<bar_width; i++))
    do
        bar+="${topbar}"
    done
    # a side of the border may be longer (e.g. the right border)
    if (( ( terminal_width - ( padding * 2 ) - text_width ) % 2 == 0 ))
    then
        # the left and right borders have the same width
        left_border="$border"
        right_border="$left_border"
    else
        # the right border has one more character than the left border
        # the text is aligned leftmost
        left_border="$border"
        right_border="$left_border$filler"
    fi
    # a side of the border may be longer (e.g. the right border)
    if (( ( terminal_width - ( padding * 2 ) - title_text_width ) % 2 == 0 ))
    then
        # the left and right borders have the same width
        title_left_border="$title_border"
        title_right_border="$title_left_border"
    else
        # the right border has one more character than the left border
        # the text is aligned leftmost
        title_left_border="$title_border"
        title_right_border="$title_left_border$title_filler"
    fi
    # set alignments by combining variables then clearing one of them.
    if [[ "$rightaligned" == "true" ]] ; then
        left_border="$left_border""$right_border"
        right_border=""
        title_left_border="$title_left_border""$title_right_border"
        title_right_border=""
    elif [[ "$leftaligned" == "true" ]] ; then
        right_border="$left_border""$right_border"
        left_border=""
        title_right_border="$title_left_border""$title_right_border"
        title_left_border=""
    fi
    # a side of the topbar may be longer (e.g. the right border)
    if (( ( terminal_width - ( padding * 2 ) - 1 ) % 2 == 0 ))
    then
        # the left and right bars have the same width
        left_bar=$bar
        right_bar=$left_bar
    else
        # the right bar has one more character than the left bar
        # the text is aligned leftmost
        left_bar=$bar
        right_bar="${bar}${topbar}"
    fi
    # undo all of this if we arent making boxes
    if [[ "$boxless" == "true" ]] ; then
        top_left_corner=""
        top_right_corner=""
        btm_left_corner=""
        btm_right_corner=""
        left_wall=""
        right_wall=""
        left_div_wall=""
        right_div_wall=""
        topbar=""
        title_filler=""
        filler=""
        left_bar=""
        right_bar=""
        left_border=""
        right_border=""
        title_left_border=""
        title_right_border=""
      fi
}

multibox(){
  local multi=("$@")
  for line in "${multi[@]}" ; do
      bento_vars
  printf "  ${left_wall}${left_border}${filler}${line}${filler}${right_border}${right_wall}\n"
  done
}

multititle(){
  local multi=("$@")
  for line in "${multi[@]}" ; do
      bento_vars
  printf "  ${left_wall}\033[7m${title_left_border}${title_filler}${line}${title_filler}${title_right_border}\033[27m${right_wall}\n"
  done
}

multisub(){
  local multi=("$@")
  for line in "${multi[@]}" ; do
      bento_vars
          echo ""
          printf "\33[A\33[2K\r%s"
      printf "\r%s  ${left_wall}${left_border}${filler}${line}${filler}${right_border}${right_wall}\n"
  done
}

multistep(){
  local multi=("$@")
  for line in "${multi[@]}" ; do
      bento_vars
      printf "     ${left_border}${filler}${line}${filler}${right_border} \n"
  done
}

# This is the code that makes the nice selection UI
# When 'tooltips=disabled' then tooltips won't be avaliable.
# Modified from https://unix.stackexchange.com/questions/146570/arrow-key-enter-menu/415155#415155
# Renders a text based list of options that can be selected by the
# user using up, down and enter keys and returns the chosen option.
#
#   Arguments   : list of options, maximum of 256
#                 "opt1" "opt2" ...
#   Return value: selected index (0 for opt1, 1 for opt2 ...)

#<~> Menu Maker functions

function select_option {

toggle_selection(){
    # search already selected item to see if this option was already selected and deselect it
    # use the found variable to confirm if it was an exact match
    found="false"
    if [[ "${selection[*]}" =~ "${menu[$selected]}" ]] ; then
        for selectopt in "${selection[@]}" ; do
            if [[ "${selection[$selectopt]}" == "${menu[$selected]}" ]] ; then
                unset "selection[$selectopt]"
                found="true"
            fi
        done
    fi
    # If the option was not found in the selection
    if [[ "$found" == "false" ]] ; then
        selection+=("${menu[$selected]}")
    else # If it was found, clean up the arrays
        for i in "${selection[*]}" ; do
            temparr+=("${selection[@]}")
        done
        unset selection
        for i in "${temparr[*]}" ; do
            selection+=("${temparr[@]}")
        done
        unset temparr
    fi
}



echo""
    local menuopts=("$@")
    local terminal_height=$(tput lines)     # query the Terminfo database: number of lines
    local box_height=$(( terminal_height - 13 ))
    local terminal_width=$(tput cols)     # query the Terminfo database: number of columns
    local box_width=$(( terminal_width - 8 ))
    # little helpers for terminal print control and key input
    ESC=$( printf "\033")
    cursor_blink_on()  { printf "$ESC[?25h"; }
    cursor_blink_off() { printf "$ESC[?25l"; }
    cursor_to()        { printf "$ESC[$1;${2:-1}H"; }

#   control display of non-highlighted options
#   print_option()     { printf "\33[A\33[2K\r%s    $1 "; }
print_option()     {
    # check if option is among selections
    if [[ ${selection[@]} =~ "$1" ]]
    then
            hilite="$ESC[7m" && end_hilite="$ESC[27m"
        else
            hilite="" && end_hilite=""
    fi


    # set alignment
    if [[ "$1" == "div" ]] ; then
        printf "   "
    elif [[ "$mrightaligned" == "true" ]] ; then
                line="$1"
                bento_vars
                printf "\33[A\33[2K\r   $hilite $line $end_hilite${left_border}${right_border}"
    elif [[ "$mcenteraligned" == "true" ]] ; then
                line="$1"
                bento_vars
                printf "\33[A\33[2K\r  $hilite ${left_border}${right_border}$line $end_hilite"
    else
                printf "\33[A\33[2K\r%s   $hilite $1 $end_hilite"
    fi
    # turn highlights back off
        hilite="" && end_hilite=""
}

#   control display of currently-highlighted options
#   print_selected()   { printf "\33[A\33[2K\r%s ⮞ $ESC[7m $1 $ESC[27m";
print_selected()   {
    if [[ "$return" == "true" ]] || [[ "$exit" == "true" ]] ; then
        # dont bother displaying an option with these enabled
        printf " "
    elif [[ "$1" == "div*" ]] ; then
        printf "   "
    else
    if [[ "$mrightaligned" == "true" ]] ; then
            line="$1"
            bento_vars
            printf "\33[A\33[2K\r ➤ ${left_border}${right_border}$ESC[7m $line $ESC[27m"
    elif [[ "$mcenteraligned" == "true" ]] ; then
            line="$1"
            bento_vars
            printf "\33[A\33[2K\r ➤ $ESC[7m $line $ESC[27m${left_border}${right_border}"
    else
            printf "\33[A\33[2K\r%s ➤ $ESC[7m $1 $ESC[27m"
    fi fi
}

    get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
    key_input()        { read -s -n3 key 2>/dev/null >&2
                         if [[ $key = $ESC[A ]]; then echo up;     fi
                         if [[ $key = $ESC[B ]]; then echo down;   fi
                         if [[ $key = ""     ]]; then echo enter;  fi; }

    get_menuopts_total(){
      menuopts_length=0
        for x in "${menuopts[@]}" ; do
          ((menuopts_length++))
        done
      if [ $menuopts_length -gt $box_height ] ; then
         : # do nothing for now, this may be useful again later
      fi
    }


    # initially print empty new lines (scroll down if at bottom of screen)
    for opt ; do
    printf "\n"; done

    # determine current screen position for overwriting the options
    lastrow=`get_cursor_row`
    #local lastrow="$terminal_height"
    startrow=$(($lastrow - $#))

    # ensure cursor and input echoing back on upon a ctrl+c during read -s
    trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
    cursor_blink_off


    get_subtitle_max_size(){
      subtitle_length=-1
        for x in "${submenu[@]}" ; do
          if [[ ${#x} -gt $subtitle_length ]] ; then
            subtitle_length=$(( ${#x} + 0 ))
          fi
        done
    }

    make_subtitles(){
      get_menuopts_total
      get_subtitle_max_size
      if [[ ! "$tooltips" == "disabled" ]] ; then
        cursor_to $lastrow
        printf "\33[A\33[2K\r%s\n"
        bento_subs
        printf "\33[2K\r%s\n"
        printf "\33[2K\r%s\n"
      fi
    }

    bento_subs(){
    if [[ -n "${submenu[$idx]}" ]] ; then
                if [[ "$srightaligned" == "true" ]] ; then
                    rightaligned="true"
                elif [[ "$sleftaligned" == "true" ]] ; then
                    leftaligned="true"
                fi
        line="${submenu[$idx]}"
        glyph="true"
        bento_vars
            printf "\r%s  ${top_left_corner}${left_bar}${topbar}${right_bar}${top_right_corner}\n"
            if (( (text_width + 8) > terminal_width )) ; then
            long_content="$(echo "$line" | fold -w $box_width -s)"
            IFS=$'\n'
            multi_array=($long_content)
            unset IFS
            multisub "${multi_array[@]}"
            else
                echo ""
                printf "\33[A\33[2K\r%s"
            printf "\r%s  ${left_wall}${left_border} $line ${right_border}${right_wall}\n"
            fi
        echo ""
        printf "\33[A\33[2K\r%s"
        printf "\r%s  ${btm_left_corner}${left_bar}${topbar}${right_bar}${btm_right_corner}\n"
        printf "\r%s"

                if [[ "$srightaligned" == "true" ]] || [[ "$sleftaligned" == "true" ]] ; then
                    rightaligned="false"
                    leftaligned="false"
                fi
    fi
    }

    local selected=0
    while true; do
        # print options by overwriting the last lines
        local idx=0
        for opt; do
            cursor_to $(($startrow + $idx))
            if [ $idx -eq $selected ]; then
                print_selected "$opt"
                make_subtitles
            else
                print_option "$opt"
            fi

            ((idx++))
        done

        # user key control
        case `key_input` in
            enter)
		if [[ "$multiselection" == "true" ]] ; then
            	for ((i = 0; i < ${#menu[@]}; ++i)); do
                # keep looping for every option to add them to our array
                if [[ "${menu[$i]}" == "Confirm Selection" ]] ; then
                	break # end loop at "Confirm Selection" dont let it or others after it be add>
                else
                	multimenu+=("${menu[$i]}")
                fi
           	done
        	fi
        	if  [[ "$multiselection" == "true" ]] && [[ "${menu[$selected]}" == "Confirm Selection" ]] ; then
            		break
        	elif [[ "$multiselection" == "true" ]] && [[ "${multimenu[$selected]}" == "${menu[$selected]}" ]] ; then
            		# toggle selection on or off
            		toggle_selection
        	else
            		# standard menu function down here
            		selection=("${menu[$selected]}")
            		break
        	fi
		;;
            up)    ((selected--))
                   if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi
                    until [[ ! "${menu[$selected]}" == "div" ]] ; do
                        ((selected--));
                        if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi
                    done ;;

                   #if [[ "${menu[$selected]}" == "div" ]]; then
                   #((selected--))
                   #if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi ; fi ;;
            down)  ((selected++));
                   if [ $selected -ge $# ]; then selected=0; fi
                   until [[ ! "${menu[$selected]}" == "div" ]] ; do
                       ((selected++));
                       if [ $selected -ge $# ]; then selected=0; fi
                   done
                   #if [[ "${menu[$selected]}" == "div" ]]; then
                   #((selected++));
                   #if [ $selected -ge $# ]; then selected=0; fi ; fi ;;
        esac
    done

    # cursor position back to normal
    cursor_to $lastrow
    printf "\n"
    cursor_blink_on
    return $selected
}


function select_opt {
    select_option "$@" 1>&2
    local result=$?
    #echo $result
    return $result
}
#</>
#</>

bento_update(){
      update_failed="false"
      sudo mkdir -p /var/brunch/toolkit
      sudo chown -R $USER /var/brunch
      bento -t "Update" -c "Updating Bento, please wait..."
      curl -l https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/bento -o /var/brunch/toolkit/bento || update_failed="true"
      sudo install -Dt /usr/local/bin -m 755 /var/brunch/toolkit/bento || update_failed="true"
      rm /var/brunch/toolkit/bento
      if [[ "$update_failed" == "true" ]] ; then
      bento -t "Update" -c "Unable to update Bento!" "Make sure your internet connection is stable and try again." "You can also update manually by downloading Bento from:" "https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/bento" "then run: bash ~/Downloads/bento --install" -e
      else
          bento -t "Update" -c "Update succesful!" -e
      fi
}

bento_install(){
    install_failed="false"
    bento -t "Update" -c "Installing Bento $bento_version, please wait..."
    sudo install -Dt /usr/local/bin -m 755 "$0" || install_failed="true"
    if [[ "$update_failed" == "true" ]] ; then
    bento -t "Update" -c "Unable to update Bento!" 'Try moving Bento to /usr/local/bin manually, or to somewhere else in your $PATH' -e
    else
        bento -t "Update" -c "Install succesful!" -e
    fi
}

bento_debug(){
    bento -t "Test" -c "Testing multi select menu" -mm "one" "two" "three" "four" "five" "six" -m "seven" "eight" "Exit" -a
    case "$selection" in
        "Exit") exit 0 ;;
    esac
    bento -t "Results" -c "Here are the results" 'Array "${selection[@]}" returns the following:' "div" "${selection[@]}" "btm" "lid" "Test again?" -m "Restart" "Exit"
    case "$selection" in
        "Restart") bento -d ; return ;;
        "Exit") exit 0 ;;
    esac
}

#</>

#<~> Startup Utilities

preset_vars(){
    readonly userid=`id -u $USERNAME`
    onlineallowed="true"
    current_brunch_version=$(cat /etc/brunch_version 2>/dev/null |  cut -d' ' -f3 )
    path_to_downloads
}

path_to_downloads(){
if [[ -n "$DOWNLOADS" ]] ; then
    downloads="$DOWNLOADS"
elif [[ "$toolkit_mode" =~ "wsl" ]] ; then
    downloads=$(wslpath $(cmd.exe /C "echo %USERPROFILE%/Downloads"))
else
    downloads="$HOME/Downloads"
fi

}

check_for_options(){
    if [[ -z "$*" ]] ; then
        : # Do nothing, continue as normal
    fi
    # parse flags here
    PARAMS=""
while (( "$#" )); do
  case "$1" in
  -o|--offline)
  # Disable online functions
    onlineallowed="false"
    shift
    ;;
  -d|--debug)
  # Do debug functions
    toolkit_debug
    exit 0
    ;;
  --*=|-*) # unsupported flags
    echo "Error: Unsupported flag $1" >&2
    exit 1
    ;;
  *) # preserve positional arguments
    PARAMS="$PARAMS $1"
    shift
    ;;
esac
done
# set positional arguments in their proper place
eval set -- "$PARAMS"
}

check_for_shell(){
    if [ "$SHELL" == "/bin/bash" ] ; then
    echo ""
    echo ""
      bento -t "Shell Authorization" -c "This toolkit is only compatible with the default sh shell, please do not run it in the developer console or with alternative shells" -e
      exit 0
    fi
}

# Toolkit behaves badly if ran as root, check to avoid that
check_for_root(){
    if [ $userid -eq 0 ] ; then
        bento -t "User Authorization" -c "Do not run this toolkit as root or with sudo" -e
        exit 0
    fi
}

# Checks for an internet connection and disables unnecessary options when no connection is present
check_for_network() {
    if [[ $onlineallowed == "true" ]] ; then
        bento -t "Network Check" -c "Checking network status, please wait..." " " "To run the toolkit offline, use the -o flag"
        case "$(curl -s --max-time 2 -I http://google.com | sed 's/^[^ ]*  *\([0-9]\).*/\1/; 1q')" in
            [23]) : ;; # do nothing and continue quietly
               5) bento -t "Network Check" -c "The network is blocked, unable to use online features." "Check your firewall settings and try again later." -e ; onlineallowed="false" ;;
               *) bento -t "Network Check" -c "The network is down or very slow, unable to use online features." "Check your firewall settings and try again later." -e ; onlineallowed="false" ;;
        esac
    else
        bento -t "Network Check" -c "Networking has been disabled" -e
        onlineallowed="false"
    fi
}

quick_network_check(){
    # Check for a stable internet connection #
    case "$(curl -s --max-time 2 -I http://google.com | sed 's/^[^ ]*  *\([0-9]\).*/\1/; 1q')" in
    # If connection is good, do nothing and proceed quietly
        [23]) : ;;
    # Error on weak or empty connection
        *) bento -t "Network Check" -c "The network is down or very slow, unable to continue." "Check your connection and try again later." -r ; $previous_menu ;;
    esac
}


get_os_ver() {
      source /etc/os-release 2>/dev/null
      if [ -z "$GOOGLE_CRASH_ID" ]; then
          current_chromeos_version=$"$ID $VERSION $BUILD_ID"
      else
          current_chromeos_version=$"$BUILD_ID"
      fi
      }



check_for_dualboot(){
    source=$(rootdev -d)
    if (expr match "$source" ".*[0-9]$" >/dev/null); then
        partsource="$source"p
    else
        partsource="$source"
    fi
    if [[ "$source" =~ .*"loop".* ]] ; then
      dualboot="true"
    else
      dualboot="false"
    fi
}

check_install_type(){
    # options: toolkit_mode=[brunch|brunch_dualboot|brunch_usb|linux|linux_usb|wsl|arch|arch_usb|arch_wsl]
    # Checks the user's system for keywords and adjusts the functions of the script accordingly
        if [ -z "$current_brunch_version" ] && [[ $(grep icrosoft /proc/version 2> /dev/null) ]] && [[ -f "/etc/arch-release" ]] ; then
            toolkit_mode="arch_wsl"
        elif [ -z "$current_brunch_version" ] && [[ $(grep icrosoft /proc/version 2> /dev/null) ]] ; then
            toolkit_mode="wsl"
        elif [ -z "$current_brunch_version" ] && [[ -f "/etc/arch-release" ]] ; then
            toolkit_mode="arch"
        elif [ -z "$current_brunch_version" ] && [[ -z $(grep icrosoft /proc/version 2> /dev/null) ]] ; then
            toolkit_mode="linux"
        else
            #assume the user is using brunch at this point
            get_os_ver
            check_for_dualboot
            if [[ "$dualboot" == "true" ]] ; then
                    toolkit_mode="brunch_dualboot"
            else
                    toolkit_mode="brunch"
            fi
        fi
}

#</>

#<~> Toolkit Config
#
# Source config info for brunch. If they don't exist, make them.
# Use this to set special settings that don't need to be asked or prompted very often.
# For normal usage, save this config file in /var/brunch/toolkit as toolkit.cfg
check_for_config(){
config_file="/var/brunch/toolkit/toolkit.cfg"
if [[ -f "$config_file" ]] ; then
    # Config exists, update a couple things
    get_os_ver
    sed -i "s/current_brunch_version=.*/current_brunch_version=$current_brunch_version/" "$config_file"
    currentsemversion=$(echo "$toolkitversion" | sed -e "s/^v//" -e "s/b$//")
    sed -i "s/current_toolkit_version=.*/current_toolkit_version=$currentsemversion/" "$config_file"
    sed -i "s/current_chromeos_version=.*/current_chromeos_version=$current_chromeos_version/" "$config_file"
    source "$config_file" 2> /dev/null
    clear
else
    # Config does not exist yet
    create_config_file
fi
}

create_config_file(){
    sudo mkdir -p /var/brunch/toolkit
    sudo chown -R $USER /var/brunch
    touch "$config_file"
    tee > "$config_file" <<EOF

#      ___                  _      _____         _ _   _ _
#     | _ )_ _ _  _ _ _  __| |_   |_   _|__  ___| | |_(_) |_
#     | _ \ '_| || | ' \/ _|  _ \   | |/ _ \/ _ \ | / / |  _|
#     |___/_|  \_,_|_||_\__|_||_|   |_|\___/\___/_|_\_\_|\__|
#

# Looking for help? Find me on discord: https://discord.gg/x2EgK2M


# This is the configuration file for the Brunch Toolkit,
# and is automatically generated by the toolkit.
# These settings should be managed directly with the toolkit,
# but I will attempt to document them here just in case.

# First time init
# If this is not set or set to enabled, the toolkit will run
# first time init hen it is opened next time. This init is used
# to set all of the following variables in this config file.
# Usage: [enabled|disabled]
first_time_init=

# App Splash Screen
# This value will show an ascii splash screen when launching
# the toolkit if enabled. Typically this animation is only seen
# on first launch and is disabled by default afterwards.
# Usage: [enabled|disabled]
startup_anim=

# Use Bento Boxes
# This value will determine the style of the toolkit's UI,
# specifically whether or not the toolkit will use the new
# textbox UI called "Bento" which is enabled by default.
# Usage: [enabled|disabled]
bento_boxes=
bento_version=

# Display Tooltips
# The following value will set the avaliability of tooltips,
# which are enabled by default. These are dynamic boxes
# displayed at the bottom of the terminal when making selections.
# If bento is disabled, these tooltips will be plain as well.
# Some menus do not have tooltips.
# Usage: [enabled|disabled]
tooltips=

# Detected Install Type
# This setting is based on the user's installation, and can
# only be changed directly from this file. This setting changes
# core functions of the toolkit, do not change it unless you're
# sure of what you are doing.
# Usage: [brunch|brunch_dualboot|brunch_usb|linux|linux_usb|linux_wsl|arch|arch_usb|arch_wsl]
toolkit_mode=

# Chosen Recovery
# This sets which recovery the toolkit will download. By
# default, it is set based on the user's CPU compatibility.
# Use common sense when changing this setting, refer to the
# brunch github or the toolkit's compatibility checker for
# valid recoveries.
# Usage: selected_recovery= "string"
selected_recovery=

# Dependencies installed
# Only important on non-brunch devices, if set to false
# certain options will prompt for the dependencies to be
# installed before they will work properly.
# Usage: [true|false]
dependencies_installed=

# Advanced Options
# This allows the user to access extra options in the toolkit
# This is disabled by default to help prevent user error
# Usage: [enabled|disabled]
advanced_options=

# Brunch Editor
# This setting lets you choose which text editor to use
# In the advanced settings page you can toggle between
# nano or vi, but you can declare anything from here
# Usage: [program]
brunch_editor=

# Downloads location
# Allows setting a specific location for new downloads
# This is most useful for WSL users.
# Usage: [path/to/downloads]
downloads=

# ImageMagick settings
# Preset variables used by ImageMagick when converting images
# to be used as grub themes, bootsplash or boot animation frames
# Height and Width of the user's screen, tries to fetch automatically
height=
width=

# Scaling used for converted images
# Usage: [centered|fit|iconify] defaults to centered when unset
scaling=

# Prefered color for the canvas/borders when cropping (Currently Unused)
usercolor=

# Check for updates at startup
# Prompts the toolkit to check for updates when it's launched.
# Default is disabled to avoid issues with github's limiting.
# The toolkit will keep track of various options here.
# Usage: [enabled|disabled]
autocheck=

latest_brunch_version=
current_brunch_version=
stable_update=

get_unstable_updates=
latest_brunch_unstable_version=
unstable_update=

latest_chromeos_version=
current_chromeos_version=
chromeos_update=

latest_toolkit_version=
current_toolkit_version=
toolkit_update=

saved_announcement_ver=

EOF

}
#</>

#<~> Toolkit Startup Animation
startup_anim(){
frame=("1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15" "16" "17" "18" "19" "20" "21" "22" "23")
frame1=("◜                " "◝ B              " "◞ Br             " "◟ Bru            " "◜ Brun           " "◝ Brunc          " "◞ Brunch         " "◟ Brunch         " "◜ Brunch T       " "◝ Brunch To      " "◞ Brunch Too     " "◟ Brunch Tool    " "◜ Brunch Toolk   " "◝ Brunch Toolki  " "◞ Brunch Toolkit " "◟ Brunch Toolkit " "◜ Brunch Toolkit " "◝ Brunch Toolkit " "◞ Brunch Toolkit " "◟ Brunch Toolkit " "◜ Brunch Toolkit " "◝ Brunch Toolkit " "◞ Brunch Toolkit " "◟ Brunch Toolkit ")
if [[ ! $startup_anim == "disabled" ]] ; then
clear
terminal_height=$(tput lines)     # query the Terminfo database: number of lines
center_height=$(( terminal_height / 2 - 1 ))
terminal_width=$(tput cols)

draw_frame(){
printf "%*s\r" $(((20+$terminal_width)/2)) "$layer1"
sleep .04
}

x="$center_height"
while [ "$x" -gt 0 ] ; do
    printf "\n"
    x=$(($x-1))
done
for i in "${frame[@]}" ; do
    layer1="${frame1[$i]}"
    draw_frame
done
clear
fi
}
#</>

#<~> First Time init
# Set some important variables for the toolkit
# Only do this on the first boot or if prompted
#

first_time_init_startup(){
    if [[ ! "$first_time_init" == "disabled" ]] ; then
    first_time_init_page1
    fi
}

first_time_init_page1(){
if [[ "$first_time_init" == "enabled" ]] ; then
    fti_startup_screen=("Welcome back to the Brunch Toolkit" "It looks like you're resetting some options, lets get started!")
elif [[ -z "${first_time_init}" ]]  ; then
        fti_startup_screen=("Welcome to the Brunch Toolkit." "It looks like this may be the first time you've used this version of the toolkit." "Please be patient as we set up some options." "All options can be changed later.")
fi
    bento -t "Brunch Toolkit - Startup" -c "${fti_startup_screen[@]}" -m "Start" "Exit" -a -s "Start the setup process" "Close the toolkit"
      case "$selection" in
        "Start") first_time_init_page2 ; return ;;
        "Exit") exit 0 ;;
      esac
}

first_time_init_page2(){
    bento -t "Loading Animation" -c " " "Display the loading animation when launching the Brunch Toolkit?" " " -m "No" "Yes" "Exit" -a -s "Do not display the loading animation" "Display the loading animation" "Exit without saving"
    case "$selection" in
        "No") startup_anim="disabled" ;;
        "Yes") startup_anim="enabled" ;;
        "Exit") exit 0 ;;
    esac
first_time_init_page3
}

first_time_init_page3(){
    bento -t "Bento" -c "This script is built with Bento." "Bento is a custom made textbox and menu interface for Brunch." "If you dont like textboxes, you can disable them on this page." "Use Bento to make textboxes?" -m "Yes" "No" "Back" "Exit" -s "Keep Bento enabled" "Disable textboxes" "Go back to the previous page" "Exit without saving" -a
    case "$selection" in
        "Yes") bento_boxes="enabled" ;;
        "No") bento_boxes="disabled" ; export bento_boxes ;;
        "Back") first_time_init_page2 ; return ;;
        "Exit") exit 0 ;;
    esac
first_time_init_page4
}

first_time_init_page4(){
    bento -t "Tooltips" -c "Keep tooltips enabled at the bottom of the terminal?" "(When enabled, they might not be avalible on every menu)" -m "Yes" "No" "Back" "Exit" -s "Keep tooltips enabled" "Disabled tooltips" "Go back to the previous page" "Exit without saving" -a
    case "$selection" in
        "Yes") tooltips="enabled" ;;
        "No") tooltips="disabled" ; export tooltips ;;
        "Back") first_time_init_page3 ; return ;;
        "Exit") exit 0 ;;
    esac
    selection_made="false"
first_time_init_page5
}


first_time_init_page5(){
    if [[ "$selection_made" == "true" ]] ; then
        first_time_init_page6
    else
    check_install_type
    if [[ "$toolkit_mode" == "arch" ]] || [[ "$toolkit_mode" == "linux" ]] ; then
        bento -t "Installation Details" -c "Are you currently running $toolkit_mode from a live USB?" -m "No" "Yes" "Back" "Exit" -s "This is not a live USB" "This is a live USB" "Go back to the previous page" "Exit without saving" -a
        case "$selection" in
            "No") : ;; #do nothing and continue
            "Yes") toolkit_mode="$toolkit_mode"_usb ;;
            "Back") first_time_init_page4 ; return ;;
            "Exit") exit 0 ;;
        esac
        quiet_compatibility_check
        if [[ "$detected_recovery" == "unsupported" ]] ; then
            compatible="no"
        bento -t "Installation Details" -c "Your currently detected CPU is not compatible with Brunch" "If you want to continue, please select which recovery you want to use." "" "If you believe this is an error, please contact Wisteria on the Brunch Discord Server." -m "Select a Recovery" "Back" "Exit" -s "Select your preferred recovery" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Select a Recovery") previous_page="first_time_init_page5" ; select_a_recovery ; return ;;
            "Back") first_time_init_page4 ; return ;;
            "Exit") exit 0 ;;
        esac
        else
            compatible="yes"
        bento -t "Installation Details" -c "Your currently detected CPU is compatible with $detected_recovery" "Save this as your preferred recovery?" -m "Yes" "No" "Back" "Exit" -s "Use suggested recovery" "Select something else" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Yes") selected_recovery="$detected_recovery" ;;
            "No")  previous_page="first_time_init_page5" ; select_a_recovery ; return ;;
            "Back") first_time_init_page4 ; return ;;
            "Exit") exit 0 ;;
        esac
        fi
    elif [[ "$toolkit_mode" =~ "brunch" ]] ; then
        detected_recovery=$(printenv | grep CHROMEOS_RELEASE_BOARD | cut -d"=" -f2 | cut -d"-" -f1)
        bento -t "Installation Details" -c "Your currently detected recovery is $detected_recovery" "Save this as your preferred recovery?" -m "Yes" "No" "Back" "Exit" -s "This is my recovery" "Select something else" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Yes") selected_recovery="$detected_recovery" ;;
            "No")  previous_page="first_time_init_page5" ; select_a_recovery ; return ;;
            "Back") first_time_init_page4 ; return ;;
            "Exit") exit 0 ;;
        esac
    else
        previous_page="first_time_init_page4"
    fi
first_time_init_page6
fi
}

first_time_init_page6(){
    bento -t "Check for Updates" -c "Would you like the toolkit to check for updates automatically when it is launched?" "(You can still check for updates from the main menu when this is disabled.)" -m "No" "Yes" "Back" "Exit" -a -s "Do not check for updates automatically" "Check for updates automatically" "Go back to the previous page" "Exit without saving"
    case "$selection" in
        "Yes") autocheck="enabled" ;;
        "No")  autocheck="disabled" ;;
        "Back") first_time_init_page5 ; return ;;
        "Exit") exit 0 ;;
    esac
first_time_init_page7
}

first_time_init_page7(){
    if [[ ! "$toolkit_mode" =~ "brunch" ]] && [[ ! "$dependencies_installed" == "true" ]]; then
        previous_menu="first_time_init_page7"
        dependency_search
    elif [[ "$toolkit_mode" =~ "brunch" ]] ; then
        dependencies_installed="true"
    fi
    first_time_init_page8
}


first_time_init_page8(){
# Compile the results of all of the init pages so far into one and write them to the config file
fti_finalize=(
"Thank you for your patience."
"The following settings have been written to your config file,"
"They can be changed later from the main menu if needed."
""
"div"
"Loading Animation          $startup_anim"
"Bento                      $bento_boxes"
"Tooltips                   $tooltips"
"Check for Updates          $autocheck"
"Installation Details       $toolkit_mode"
)
if [[ "$toolkit_mode" =~ "brunch" ]] ; then
fti_finalize+=(
"Selected Recovery          $selected_recovery"
"Current Brunch release     $current_brunch_version")
else
fti_finalize+=(
"Dependencies Installed     $dependencies_installed"
"Selected Recovery          $selected_recovery")
    if [[ "$compatible" == "yes" ]] ; then
    fti_finalize+=("This CPU is compatible with Brunch" "$cputype")
elif [[ "$compatible" == "no" ]] ; then
    fti_finalize+=("This CPU is not compatible with Brunch" "$cputype")
    fi
fi
path_to_downloads
update_config_file
bento -t "Startup - Summary" -cla -c "${fti_finalize[@]}" -m "Continue to Main Menu"
case "$selection" in
    *) main_menu_startup ; return ;;
esac
}

update_config_file(){
    sed -i "s/startup_anim=.*/startup_anim=$startup_anim/" "$config_file"
    sed -i "s/bento_boxes=.*/bento_boxes=$bento_boxes/" "$config_file"
    sed -i "s/bento_version=.*/bento_version=$bento_version/" "$config_file"
    sed -i "s/tooltips=.*/tooltips=$tooltips/" "$config_file"
    sed -i "s/toolkit_mode=.*/toolkit_mode=$toolkit_mode/" "$config_file"
    sed -i "s/selected_recovery=.*/selected_recovery=$selected_recovery/" "$config_file"
    sed -i "s/compatible=.*/compatible=$compatible/" "$config_file"
    sed -i "s/dependencies_installed=.*/dependencies_installed=$dependencies_installed/" "$config_file"
    sed -i "s/downloads=.*/downloads=$downloads/" "$config_file"
    sed -i "s/autocheck=.*/autocheck=$autocheck/" "$config_file"
    sed -i "s/current_brunch_version=.*/current_brunch_version=$current_brunch_version/" "$config_file"
    currentsemversion=$(echo "$toolkitversion" | sed -e "s/^v//" -e "s/b$//")
    sed -i "s/current_toolkit_version=.*/current_toolkit_version=$currentsemversion/" "$config_file"
    sed -i "s/current_chromeos_version=.*/current_chromeos_version=$current_chromeos_version/" "$config_file"
    # Some of these get set automatically to a predetermined default
    sed -i "s/first_time_init=.*/first_time_init=disabled/" "$config_file"
    sed -i "s/brunch_editor=.*/brunch_editor=nano/" "$config_file"
    sed -i "s/advanced_options=.*/advanced_options=disabled/" "$config_file"
    sed -i "s/get_unstable_updates=.*/get_unstable_updates=false/" "$config_file"
    sed -i "s|downloads=.*|downloads=$downloads|" "$config_file"
    sed -i "s/scaling=.*/scaling=fit/" "$config_file"
}

#</>

#<~> Dependency installer

dependency_search(){
    command -v pv >/dev/null 2>&1 || needed_programs+=("pv")
    command -v unzip >/dev/null 2>&1 || needed_programs+=("unzip")
    command -v tar >/dev/null 2>&1 || needed_programs+=("tar")
    command -v cgpt >/dev/null 2>&1 || needed_programs+=("cgpt")
    command -v git >/dev/null 2>&1 || needed_programs+=("git")
    if [[ -n "${needed_programs[*]}" ]] ; then
    bento -t "Additional Dependencies" -c "Brunch has a few additional requirements on linux systems." "Needed programs: ${needed_programs[*]}" "The brunch toolkit can attempt to install them for you now." -m "Install now" "Install later" "Back" "Exit" -s "Attempt to install programs automatically" "Install later (Some functions will be disabled)" "Go back to the previous page" "Exit without saving" -a
    case "$selection" in
        "Install now") dependency_installer ; return ;;
        "Install Later") dependencies_installed="false" ; return ;;
        "Back") "$previous_menu" ; return ;;
        "Exit") exit 0 ;;
    esac
    else
        dependencies_installed="true"
        bento -t "Additional Dependencies" -c "All required dependencies are installed!" -r
    fi
}

dependency_installer(){
    if [[ "$toolkit_mode" =~ "linux" ]] ; then
        bento -t "Additional Dependencies" -c "Please wait while the toolkit installs dependencies." "Your password may be required for sudo."
        sudo apt update
        sudo apt install -y "${needed_programs[*]}" || dep_installation_failed="true"
    elif [[ "$toolkit_mode" =~ "arch" ]] ; then
        # find all arch dependencies seperately
            command -v pv >/dev/null 2>&1 || needed_programs_arch+=("pv")
            command -v unzip >/dev/null 2>&1 || needed_programs_arch+=("unzip")
            command -v tar >/dev/null 2>&1 || needed_programs_arch+=("tar")
            command -v git >/dev/null 2>&1 || needed_programs_arch+=("git")
            command -v sed >/dev/null 2>&1 || needed_programs_arch+=("sed")
            command -v patch >/dev/null 2>&1 || needed_programs_arch+=("patch")
            command -v gcc >/dev/null 2>&1 || needed_programs_arch+=("base-devel")
            command -v cgpt >/dev/null 2>&1 || need_vboot_utils="true"

        bento -t "Additional Dependencies" -c "Please wait while the toolkit installs dependencies." "Your password may be required for sudo."

        # use pacman for most of these, set a failed var if something goes wrong.
        sudo pacman -Syu "${needed_programs_arch[*]}" || dep_installation_failed="true"
        # build trousers and vboot-utils for cgpt, including workaround from Sebanc
            if [[ "$need_vboot_utils" == "true" ]] ; then
                git clone https://aur.archlinux.org/trousers.git
                cd trousers
                yes | makepkg -si
                cd ..
                git clone https://aur.archlinux.org/vboot-utils.git
                cd vboot-utils
                sed -i "s@cd vboot_reference@cd vboot_reference\n  sed -i 's/-Werror//g' Makefile@g" PKGBUILD
                yes | makepkg -si
                cd ..
            fi
    fi
    if [[ "$dep_installation_failed" == "true" ]] ; then
    dep_results=("There was an issue installing dependencies." "Please install them manually.")
    dependencies_installed="false"
    else
    dep_results=("Installation succesful!")
    dependencies_installed="true"
    fi
    bento -t "Additional Dependencies" -c "$dep_results" -r
}

#</>

#<~> Recovery Selection menu

select_a_recovery(){
    previous_menu="$previous_page"
    quick_network_check
    unset allrecoveries
    unset allrecoveries_page1
    unset allrecoveries_page2
    unset allrecoveries_page3
    unset allrecoveries_page4
    clear
    bento -n -t "Select a Recovery" -c "Fetching recoveries,  please wait..."
    if [[ "$detected_recovery" == "unsupported" ]] ; then
    suggested_recoveries=("Rammus" "Volteer" "Grunt" "Zork")
    else
    get_chrome_recoveries=($(curl https://cros-updates-serving.appspot.com/ | grep 'id="' | cut -d\" -f2 | sed -e s/cros-updates/remove-this/))
    fi
    ignored_recoveries='"hana" "daisy" "jaq" "minnie" "speedy" "peach" "trogdor" "elm" "kitty" "jacuzzi" "kukui" "skate" "kevin" "bob" "scarlet" "mickey" "falco" "mario" "alex" "ZGB" "Lumpy" "Stumpy" "parrot" "butterfly" "link" "stout" "snow" "beltino" "slippy" "rambi" "nyan" "banjo" "candy" "auron"'
    if [[ -n "$get_chrome_recoveries" ]] ; then
        for ((i = 0; i < ${#get_chrome_recoveries[@]}; ++i)); do
        if [[ "${get_chrome_recoveries[$i]}" == "remove-this" ]] ; then
            : # do nothing
        elif [[ "$ignored_recoveries" =~ "${get_chrome_recoveries[$i]}" ]] ; then
            : # do nothing
        elif [[ "${get_chrome_recoveries[$i]}" == "zork" ]]  ; then
            allrecoveries+=("${get_chrome_recoveries[$i]}")
            break # dont bother with outdated recoveries at the end of the list (starting after zork)
        else
            allrecoveries+=("${get_chrome_recoveries[$i]}")
        fi
        done
        for ((i = 0; i < ${#allrecoveries[@]}; ++i)); do
        if (( i < 15)) ; then
            allrecoveries_page1+=("${allrecoveries[$i]}")
        elif (( i < 30)) ; then
            allrecoveries_page2+=("${allrecoveries[$i]}")
        elif (( i < 45)) ; then
            allrecoveries_page3+=("${allrecoveries[$i]}")
        elif (( i > 44)) ; then
            allrecoveries_page4+=("${allrecoveries[$i]}")
        fi
    done
            current_page="1"
        long_recovery_menu
    else
         allrecoveries=("Rammus" "Volteer" "Grunt" "Zork")
         clear
         bento -t "Select a Recovery" -c "Please select which option you'd like to save as your preferred recovery." -m "${allrecoveries[@]}" div "Back" "Exit" -a -s "${allrecoveries[@]}" div "Go back to the previous page" "Exit without saving"
         case "$selection" in
             "Back") $previous_page ; return ;;
             "Exit") exit 0 ;;
             *) selected_recovery="$selection" ; selection_made="true" ; $previous_page ; return ;;
         esac
    fi
}

long_recovery_menu(){
    if [[ "$current_page" == "1" ]] ; then
        clear
        bento -t "Select a Recovery" -c "Please select which option you'd like to save as your preferred recovery." -m "${allrecoveries_page1[@]}" div "Next Page" "Previous Page" "Back" "Exit" -a -s "${allrecoveries_page1[@]}" div "See next set of recoveries" "See previous set of recoveries" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Back") $previous_page ; return ;;
            "Exit") exit 0 ;;
            "Next Page") current_page="2" ; long_recovery_menu ;;
            "Previous Page")  current_page="4" ; long_recovery_menu ;;
            *) selected_recovery="$selection" ; selection_made="true" ; $previous_page ; return ;;
        esac
    elif [[ "$current_page" == "2" ]] ; then
        clear
        bento -t "Select a Recovery" -c "Please select which option you'd like to save as your preferred recovery." -m "${allrecoveries_page2[@]}" div "Next Page" "Previous Page" "Back" "Exit" -a -s "${allrecoveries_page2[@]}" div "See next set of recoveries" "See previous set of recoveries" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Back") $previous_page ; return ;;
            "Exit") exit 0 ;;
            "Next Page") current_page="3" ; long_recovery_menu ;;
            "Previous Page")  current_page="1" ; long_recovery_menu ;;
            *) selected_recovery="$selection" ; selection_made="true" ; $previous_page ; return ;;
        esac
    elif [[ "$current_page" == "3" ]] ; then
        clear
        bento -t "Select a Recovery" -c "Please select which option you'd like to save as your preferred recovery." -m "${allrecoveries_page3[@]}" div "Next Page" "Previous Page" "Back" "Exit" -a -s "${allrecoveries_page3[@]}" div "See next set of recoveries" "See previous set of recoveries" "Go back to the previous page" "Exit without saving"
        case "$selection" in
            "Back") $previous_page ; return ;;
            "Exit") exit 0 ;;
            "Next Page") current_page="1" ; long_recovery_menu ;;
            "Previous Page")  current_page="2" ; long_recovery_menu ;;
            *) selected_recovery="$selection" ; selection_made="true" ; $previous_page ; return ;;
        esac
    fi
}
#</>

#<~> Compatibility Check

# Define function to determine brunch compatibility & suggested recoveries
# Ideally this entire code can be safely incorperated into other scripts

quiet_compatibility_check(){
        cputype=$(cat /proc/cpuinfo | grep "model name" | head -1 | awk -F '[:]' '{print $2}')
        if [[ ! "$cputype" =~ .*"AMD".* ]] && [[ ! "$cputype" =~ .*"Intel".* ]]   ; then
            detected_recovery="unsupported"
        elif [[ "$cputype" =~ .*"AMD".* ]] ; then
            quietamdcpu
        elif [[ "$cputype" =~ .*"Intel".* ]] ; then
            quietintelcpu
        else
            detected_recovery="unsupported"
            bento -t "ERROR" -c "Something seems to have gone wrong, your cpu support could not be determined." "If you're seeing this error, please contact Wisteria on the Brunch Discord Server." -r
        fi
    }

quietamdcpu(){
        oldcpu=$(grep -Ewo 'sse4_2' /proc/cpuinfo  | sort | uniq)
        amdtype=$(cat /proc/cpuinfo | grep "[a|e][0-9]-9" | head -1 | awk -F '[:]' '{print $2}')
        if [[ "$cputype" =~ .*"yzen".* ]] ; then
            detected_recovery="zork"
        elif [[ "$cputype" =~ .*"$amdtype".* ]] ; then
            detected_recovery="grunt"
        elif [[ -z "$amdtype" ]] ; then
            detected_recovery="unsupported"
        else
            detected_recovery="unsupported"
            bento -t "ERROR" -c "Something seems to have gone wrong, your cpu support could not be determined." "If you're seeing this error, please contact Wisteria on the Brunch Discord Server." -r
        fi
    }

quietintelcpu(){
        newcpu=$(cat /proc/cpuinfo  | sed -e "s/G//g" | grep "i[3|5|7|9]-1[0-1][0-9][0-9][0-9]")
        oldcpu=$(grep -Ewo 'sse4_2' /proc/cpuinfo  | sort | uniq | sed -e 's/sse4_2/Rammus is suggested./g')
        if [ -z "$oldcpu" ] ; then
            detected_recovery="unsupported"
        elif [ -n "$oldcpu" ] && [ -z "$newcpu" ] ; then
            echo "$oldcpu"
            detected_recovery="rammus"
        elif [ -n "$newcpu" ] ; then
            detected_recovery="volteer"
        else
            detected_recovery="unsupported"
            bento -t "ERROR" -c "Something seems to have gone wrong, your cpu support could not be determined." "If you're seeing this error, please contact Wisteria on the Brunch Discord Server." -r
        fi
    }

#</>

#<~> Main Menu

main_menu_startup(){
    check_for_updates
    check_for_notifications
    set_main_menu_options
    check_for_announcements
    # Only display notifications if there are actually notifications.
    if [[ -n "$notify_content" ]] ; then
        header=("Brunch Toolkit $toolkitversion" -c "Need help? Found a bug? Find me in the Brunch Discord! --Wisteria" "$discordinvite" div "${notify_content[@]}")
    else
        header=("Brunch Toolkit $toolkitversion" -c "Need help? Found a bug? Find me in the Brunch Discord! --Wisteria" "$discordinvite")
    fi
    bento -g -t "${header[@]}"
    # bento -g -t "Brunch Toolkit" -c "${notify_content[@]}"
    bento -n -c "Main Menu" -m "${main_menu_options[@]}" -s "${main_menu_options_subs[@]}" -a
    previous_menu="main_menu_startup"
    case "$selection" in
        "Exit") exit 0 ;;
        "Install Dependencies") dependency_search ; main_menu_startup ; return;;
        "Check for Updates") force_update="true" ; check_for_updates ; main_menu_startup ; return ;;
        "Update Toolkit") update_brunch_toolkit ; main_menu_startup ; return ;;
        "Brioche Options") brioche_menu ; return ;;
        "Bootscripts") bootscript_menu ; return ;;
        "Update Brunch") update_brunch ; main_menu_startup ; return ;;
        "Toolkit Settings") toolkit_settings_menu ; return ;;
        "Compatibility Check") loud_compatibility_check ; main_menu_startup ; return ;;
        "Compatibility Report") compatibility_report ; main_menu_startup ; return ;;
        "Advanced Options") advanced_options_menu ; main_menu_startup ; return ;;
        "Install Brunch") install_brunch ; main_menu_startup ; return ;;
        "Framework Options") framework_options ; main_menu_startup ; return ;;
        "Grub Options") grub_options_menu ; main_menu_startup ; return ;;
    esac
}

set_main_menu_options(){
    unset main_menu_options
    #Set according to the user's system and avaliability

    # Allow checking for updates manually if autocheck is disabled. if network is disabled, dont show any option
    if [[ "$onlineallowed" == "true" ]] && [[ ! "$autocheck" == "enabled" ]] ; then
        main_menu_options+=("Check for Updates")
        main_menu_options_subs+=("Check for Updates to Brunch or the Toolkit")
    fi
    # only show update option if an update is actually avaliable
    if [[ "$toolkit_mode" =~ "brunch" ]] && [[ "$stable_update" == "true" ]] && [[ ! "$update_complete" == "true" ]] ; then
        main_menu_options+=("Update Brunch")
        main_menu_options_subs+=("Update Brunch to the latest release")
    fi
    if [[ "$onlineallowed" == "true" ]] && [[ "$toolkit_update" == "true" ]] ; then
        main_menu_options+=("Update Toolkit")
        main_menu_options_subs+=("Update the Toolkit to the latest release")
    fi
    # prompt user to install dependencies if they havent been installed yet
    if [[ "$dependencies_installed" == "false" ]] ; then
        main_menu_options+=("Install Dependencies")
        main_menu_options_subs+=("Install required dependencies for Brunch")
    else
        main_menu_options+=("Install Brunch")
        main_menu_options_subs+=("Install Brunch to another disk")
    fi
    if [[ "$toolkit_mode" =~ "brunch" ]] ; then
        main_menu_options+=("Grub Options")
        main_menu_options_subs+=("Edit Grub Themes")
        main_menu_options+=("Bootscripts")
        main_menu_options_subs+=("Add Bootscripts to Brunch")
        main_menu_options+=("Brioche Options")
        main_menu_options_subs+=("Explore Brioche settings")
        compatibility_option="Compatibility Report"
    else
        compatibility_option="Compatibility Check"
    fi
        main_menu_options+=("$compatibility_option")
        main_menu_options_subs+=("Open the $compatibility_option tool")
        if [[ "$advanced_options" == "enabled" ]] ; then
        main_menu_options+=("Advanced Options")
        main_menu_options_subs+=("Open Advanced Options")
        fi
        main_menu_options+=("Toolkit Settings")
        main_menu_options_subs+=("Open the Brunch Toolkit Settings")
        main_menu_options+=("Exit")
        main_menu_options_subs+=("Exit the Toolkit")
}
#</>

#<~> Grub Options
check_grub_format(){
    mount_grub
        # Look for the new flavor of grub, and adjust these variables as needed
        brunch_config="$HOME/tmp/brunch-workspace/efi/boot/settings.cfg"
        new_grub="true"
        if [[ ! -e "$brunch_config" ]] ; then
            brunch_config="$HOME/tmp/brunch-workspace/efi/boot/grub.cfg"
            new_grub="false"
        fi
          if (( $current_brunch_version < 20210620 )) && [[ "$toolkit_mode" == "brunch_dualboot" ]] ; then
            grub_editable="false"
        elif (( $current_brunch_version > 20210619 )) && [[ "$toolkit_mode" == "brunch_dualboot" ]] && [[ "$new_grub" == "false" ]] ; then
            grub_editable="false"
        elif (( $current_brunch_version > 20210619 )) && [[ "$toolkit_mode" == "brunch_dualboot" ]] && [[ "$new_grub" == "true" ]] ; then
            grub_editable="true"
        else
            grub_editable="true"
        fi
    unset brunch_framework_options
    unset brunch_brunch_bootsplash
    unset brunch_chromeos_bootsplash
    unset brunch_kernel_options
    unset brunch_cmdline_options
    unset avaliable_themes
    unset current_theme

    brunch_framework_options=($(cat "$brunch_config" | grep -m 1 "options=" | sed "s/.*options=//g" | cut -d' ' -f1 | sed "s/,/ /g"))
    brunch_framework_options_unfiltered=$(cat "$brunch_config" | grep -m 1 "options=" | sed "s/.*options=//g" | cut -d' ' -f1)
    brunch_brunch_bootsplash=$(cat "$brunch_config" | grep -m 1 "brunch_bootsplash=" | sed "s/.*brunch_bootsplash=//g" | cut -d' ' -f1)
    brunch_chromeos_bootsplash=$(cat "$brunch_config" | grep -m 1 "chromeos_bootsplash=" | sed "s/.*chromeos_bootsplash=//g" | cut -d' ' -f1)
    if [[ "$brunch_config" =~ "grub" ]] ; then
    brunch_kernel_option=$(cat "$brunch_config" | grep -m 1 "kernel" | sed "s/.*kernel/kernel/g" | cut -d' ' -f1)
    brunch_cmdline_options="Not Avaliable"
    elif [[ "$brunch_config" =~ "settings" ]] ; then
    brunch_kernel_option=$(cat "$brunch_config" | grep -m 1 "kernel=" | sed "s|.*kernel=||g" | cut -d' ' -f1)
    brunch_cmdline_options=$(cat "$brunch_config" | grep -m 1 "cmdline_params=" | sed "s/.*cmdline_params=//g" | cut -d' ' -f1)
    fi
    if [[ "$brunch_kernel_option" == "kernel" ]] ; then
        brunch_kernel_option="kernel-5.4"
    fi
    unmount_grub
}

    grub_options_menu(){
        previous_menu="main_menu_startup"
    check_for_dualboot
    check_grub_format
if [[ -z "$brunch_editor" ]] ; then
    brunch_editor="nano"
fi
    unset grub_opts
    grub_opts=(
        "Framework Options"
        "Brunch Bootsplash"
        "ChromeOS Boot Animation"
    )

    grub_subs=(
        "Toggle Framework Options"
        "Change Brunch bootsplash"
        "Change ChromeOS boot Animation"
    )
    if [[ ! "$toolkit_mode" =~ "dualboot" ]] ; then
        grub_opts+=(
        "Grub Themes")
        grub_subs+=("Change grub themes")
    fi
    #if [[ "$new_grub" == "true" ]] ; then
    #    grub_opts+=(
    #    "Commandline Parameters      [Coming Soon!]")
    #    grub_subs+=("Add commandline parameters")
    #fi
    if (( $current_brunch_version > 20201215 )) ; then
        grub_opts+=("Kernel Options")
        grub_subs+=("Swap between kernels")
    fi
    if [[ "$advanced_options" == "enabled" ]] ; then
        grub_opts+=("Edit Grub Manually")
        grub_subs+=("Open Brunch's Grub config in $brunch_editor")
        grub_opts+=("Change editor (Currently $brunch_editor)")
        grub_subs+=("Toggle which editor you'd like to use")
    fi

    if [[ "$grub_editable" == "false" ]] ; then
        bento -t "Grub Options" -c "Grub options are not currently avaliable to your install." "Edit grub from the other OS you're dualbooting with." -r
    else
        bento -t "Grub Options" -c "Modify grub related options." -a -m "${grub_opts[@]}" "Back" "Exit" -s "${grub_subs[@]}"  "Go back to the previous menu" "Exit the toolkit"
    fi
        case "$selection" in
            "Exit") exit 0 ;;
            "Back") $previous_menu ;;
            "Framework Options") framework_options ; grub_options_menu ; return ;;
            "Kernel Options") kernel_options ; grub_options_menu ; return ;;
            "Brunch Bootsplash") bootsplash_engine ; grub_options_menu ; return ;;
            "Grub Themes") theme_engine ; grub_options_menu ; return ;;
            "ChromeOS Boot Animation") boot_anim_engine ; grub_options_menu ; return ;;
            "Edit Grub Manually") edit_grub_config ; grub_options_menu ; return ;;
            "Change editor (Currently $brunch_editor)")
                                                    if [[ "$brunch_editor" == "nano" ]] ; then
                                                        brunch_editor="vi"
                                                    else
                                                        brunch_editor="nano"
                                                    fi
                                                    sed -i "s/brunch_editor=.*/brunch_editor=$brunch_editor/" "$config_file"
                                                    grub_options_menu ; return ;;
        esac
    }
#</>

#<~> Brunch Bootsplash
bootsplash_engine(){
        previous_menu="grub_options_menu"
        check_grub_format
        unpack_initramfs
        dont_include_default="false"
        get_bbs_from_initramfs
        unmount_grub
        remove_initramfs
        bento -t "Brunch Bootsplash" -c "Current Bootsplash: $brunch_brunch_bootsplash" -m "${bbs_options[@]}" div "Install Bootsplash" "Remove Bootsplash" "Back" "Exit" -s "${bbs_options_sub[@]}" div "Install a new bootsplash" "Remove an installed bootsplash" "Go back to the previous menu" "Exit the toolkit" -a
        if [[ "$selection" =~ (◆|◯) ]] ; then
            selection=${selection:4}
        fi
            case "$selection" in
                "Exit")  exit 0 ;;
                "Back")  $previous_menu ;;
                "Install Bootsplash") zip_mode="bbs" ; find_images zip ; bootsplash_installer ; bootsplash_engine ;;
                "Remove Bootsplash") bootsplash_remover ; bootsplash_engine ;;
                *) bootsplash_changer ; bootsplash_engine ;;
            esac
}

bootsplash_installer(){
    previous_menu="bootsplash_engine"
            if [[ "$scaling" == "fit" ]] ; then
                    scaling_tip="Fits the image to the canvas as well as it can. Quality may be lost at the risk of fitting the canvas as well as possible."
            elif [[ "$scaling" == "shrink" ]] ; then
                scaling_tip="Shrinks the image and tries to render a background automatically based on the top-left pixel. This is great for turning large images into centered icons"
            else
                scaling="center"
                scaling_tip="Centers the image and tries to render a background automatically based on the top-left pixel. Select this if your image is the right size already to preserve scale."
            fi
            if [[ -z "$test_convert" ]] ; then
                test_convert="disabled"
            fi
    if (( $page_number == 5 )) ; then
        bento -t "Brunch Bootsplash" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split" "This is the maximum number of images the toolkit can show currently." -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page5[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs5[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 4 )) ; then
        bento -t "Brunch Bootsplash" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page4[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs4[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 3 )) ; then
        bento -t "Brunch Bootsplash" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page3[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled."  div "${found_images_subs3[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 2 )) ; then
        bento -t "Brunch Bootsplash" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page2[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs2[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    else
        page_number=1
        bento -t "Brunch Bootsplash" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page1[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs1[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    fi
        case "$selection" in
            "Exit") exit 0 ;;
            "Back") $previous_menu ;;
            "Image Scaling Method: ${scaling^}") toggle_scaling_method ; bootsplash_installer ;;
            "Preview Image Conversion: ${test_convert^}") toggle_test_convert ; bootsplash_installer ;;
            "Next Page") page_number=$(( page_number + 1 )) ; bootsplash_installer ;;
            "First Page") page_number=1 ; bootsplash_installer ;;
            "Last Page") page_number=$(( page_number - 1 )) ; bootsplash_installer ;;
            *)
                if [[ "$test_convert" == "enabled" ]] ; then
                    bootsplash_installer_sub_debug
                    bootsplash_installer
                else
                    bootsplash_installer_sub
                    bootsplash_engine
                fi ;;
        esac

}


bootsplash_installer_sub_debug(){
    target_img="main.png"
    image_converter
    sudo cp -r ~/tmp/brunch-image_converter/$target_img "$downloads"/results.png
}

bootsplash_installer_sub(){
    target_img="main.png"
    image_converter
    get_bootsplash_name
    check_grub_format
    unpack_initramfs
    # Make a folder for the new theme
    sudo mkdir -p "$HOME/tmp/brunch-initramfs/bootsplash/$bootsplash_name"
    # Copy the new bootsplash images over
    if [[ "$file_is_zip" == "true" ]] ; then
        sudo cp -r ~/tmp/brunch-image_converter/*.png "$HOME/tmp/brunch-initramfs/bootsplash/$bootsplash_name/"
    else
        bbs_outputs=("main.png" "rebuilding.png" "patching.png" "incompatible.png")
        for elem in "${bbs_outputs[@]}" ; do
            sudo cp -r ~/tmp/brunch-image_converter/main.png "$HOME/tmp/brunch-initramfs/bootsplash/$bootsplash_name/$elem"
        done
    fi
    repack_initramfs
    unmount_grub
    rm -rf ~/tmp/brunch-image_converter
    mount_grub
    sudo sed -i "s/brunch_bootsplash=$brunch_brunch_bootsplash/brunch_bootsplash=$bootsplash_name/" "$brunch_config"
    unmount_grub
}


get_bootsplash_name(){
    if [[ "$name_warning" == "true" ]] ; then
    bento -t "Brunch Bootsplash" -c "Selected image: $source_img" " " "Input a name for this bootsplash, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed."
    bento -n -c "Previous input: $selection" "Input contains a disallowed character, try again." -w
    else
    bento -t "Brunch Bootsplash" -c "Selected image: $source_img" " " "Input a name for this bootsplash, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed." -w
    fi
    if [[ "$selection" =~ ['!@#$%^&*()+'] ]] || [[ "$selection" == *" "* ]] ; then
        name_warning="true"
        get_boot_anim_name
    else
        name_warning="false"
        bootsplash_name="$selection"
    fi
}

bootsplash_remover(){
    previous_menu="bootsplash_engine"
    check_grub_format
    unpack_initramfs
    dont_include_default="true"
    get_bbs_from_initramfs
    unmount_grub
    remove_initramfs
    if [[ -z "$bbs_options" ]] ; then
        bootsplash_engine
    else
        bento -t "Brunch Bootsplash" -c "Current Bootsplash: $brunch_brunch_bootsplash" -m "${bbs_options[@]}" div "Back" "Exit" -s "${bbs_options_sub[@]}" div "Go back to the previous menu" "Exit the toolkit" -a
    fi
            if [[ "$selection" =~ (◆|◯) ]] ; then
                selection=${selection:4}
            fi
                case "$selection" in
                    "Exit") exit 0 ;;
                    "Back") $previous_menu ;;
                    *) bootsplash_remover_sub ; bootsplash_remover ;;
                esac
}

bootsplash_remover_sub(){
    check_grub_format
    unpack_initramfs
    sudo rm -rf "$HOME/tmp/brunch-initramfs/bootsplash/$selection"
    bento -c "Repacking initramfs, please wait..."
    repack_initramfs
    unmount_grub
    remove_initramfs
    if [[ "$selection" == "$brunch_brunch_bootsplash" ]] ; then
        mount_grub
        sudo sed -i "s/brunch_bootsplash=$brunch_brunch_bootsplash/brunch_bootsplash=default/" "$brunch_config"
        unmount_grub
    fi
}

bootsplash_changer(){
    mount_grub
    sudo sed -i "s/brunch_bootsplash=$brunch_brunch_bootsplash/brunch_bootsplash=$selection/" "$brunch_config"
    unmount_grub
}

unpack_initramfs(){
    if [[ ! "$initramfs_unpacked" == "true" ]] ; then
        mkdir -p ~/tmp/brunch-workspace
        mkdir -p ~/tmp/brunch-initramfs
        sudo mount "$partsource"7 ~/tmp/brunch-workspace
        curdir=$(pwd)
        bento -c "Unpacking initramfs, please wait..."
        cd ~/tmp/brunch-initramfs && zcat ~/tmp/brunch-workspace/initramfs.img | cpio -i
        cd "$curdir"
        initramfs_unpacked="true"
    fi
}

get_bbs_from_initramfs(){
    curdir=$(pwd)
    cd ~/tmp/brunch-initramfs/bootsplash
    unset bbs_options
    unset bbs_options_sub
    if [[ -z "$dont_include_default" ]] || [[ "$dont_include_default" == "false" ]]  ; then
        dont_include_default="false"
    else
        dont_include_default="true"
    fi
    while IFS=  read -r -d $'\0'; do
        if [[ ! "$REPLY" =~ " " ]] ; then
            REPLY="${REPLY:2}"
            if [[ "$dont_include_default" == "false" ]] ; then
                if [[ "$REPLY" == "$brunch_brunch_bootsplash" ]] ; then
                    bbs_options+=("◆ $REPLY")
                else
                    bbs_options+=("◯ $REPLY")
                fi
                    bbs_options_sub+=("Switch to $REPLY")
            elif [[ "$dont_include_default" == "true" ]] && [[ ! "$REPLY" == "default" ]] && [[ ! "$REPLY" == "default_notext" ]] ; then
                if [[ "$REPLY" == "$brunch_brunch_bootsplash" ]] ; then
                    bbs_options+=("◆ $REPLY")
                else
                    bbs_options+=("◯ $REPLY")
                fi
                    bbs_options_sub+=("Switch to $REPLY")
            fi
        fi
    done < <(find . -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
    cd "$curdir"
}

repack_initramfs(){
    curdir=$(pwd)
    cd ~/tmp/brunch-initramfs && find . | cpio -o -H newc | gzip | sudo tee ~/tmp/brunch-workspace/initramfs.img > /dev/null
    cd "$curdir"
    unmount_grub
    remove_initramfs
}

remove_initramfs(){
    # this just cleans the local directory, might do other things later
    initramfs_unpacked="false"
    sudo rm -rf ~/tmp/brunch-initramfs/*
}
#</>

#<~> ChromeOS Boot Animation
boot_anim_engine(){
    previous_menu="grub_options_menu"
    check_grub_format
    # Make this directory if it doesnt already exist
    sudo mkdir -p /mnt/stateful_partition/unencrypted/bootsplash/
    # Look inside to see if boot animations exist
    unset cba_options
    unset cba_options_sub
    curdir=$(pwd)
    cd /mnt/stateful_partition/unencrypted/bootsplash/
    while IFS=  read -r -d $'\0'; do
        if [[ ! "$REPLY" =~ " " ]] ; then
            REPLY="${REPLY:2}"
            if [[ "$REPLY" == "$brunch_chromeos_bootsplash" ]] && [[ ! -z "$brunch_chromeos_bootsplash" ]] ; then
            cba_options+=("◆ $REPLY")
            else
            cba_options+=("◯ $REPLY")
            fi
            cba_options_sub+=("Switch to $REPLY")
        fi
    done < <(find . -mindepth 1 -maxdepth 1 -type d -print0)
    cd "$curdir"
    if [[ -z "$cba_options" ]] ; then
        bento -t "ChromeOS Boot Animation" -c "No boot animation detected!" -m "Install Boot Animation" "Back" "Exit" -s "Install a new boot animation" "Go back to the previous menu" "Exit the toolkit" -a

    else
        bento -t "ChromeOS Boot Animation" -c "Current Boot Animation: $brunch_chromeos_bootsplash" -m "${cba_options[@]}" div "Install Boot Animation" "Remove Boot Animation" "Back" "Exit" -s "${cba_options_sub[@]}" div "Install a new boot animation" "Remove an installed boot animation" "Go back to the previous menu" "Exit the toolkit" -a
    fi
    if [[ "$selection" =~ (◆|◯) ]] ; then
        selection=${selection:4}
    fi
        case "$selection" in
            "Exit") unmount_grub ; exit 0 ;;
            "Back") $previous_menu ;;
            "Install Boot Animation") zip_mode="cba" ; find_images zip ; boot_anim_installer ; boot_anim_engine ;;
            "Remove Boot Animation") boot_anim_remover ; boot_anim_engine ;;
            *) boot_anim_changer ; boot_anim_engine ;;
        esac
}

boot_anim_installer(){
        previous_menu="boot_anim_engine"
        if [[ "$scaling" == "fit" ]] ; then
                scaling_tip="Fits the image to the canvas as well as it can. Quality may be lost at the risk of fitting the canvas as well as possible."
        elif [[ "$scaling" == "shrink" ]] ; then
            scaling_tip="Shrinks the image and tries to render a background automatically based on the top-left pixel. This is great for turning large images into centered icons"
        else
            scaling="center"
            scaling_tip="Centers the image and tries to render a background automatically based on the top-left pixel. Select this if your image is the right size already to preserve scale."
        fi
        if [[ -z "$test_convert" ]] ; then
            test_convert="disabled"
        fi
if (( $page_number == 5 )) ; then
    bento -t "ChromeOS Boot Animation" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split" "This is the maximum number of images the toolkit can show currently." -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page5[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs5[@]}" "Go back to the previous menu" "Exit the toolkit" -a
elif (( $page_number == 4 )) ; then
    bento -t "ChromeOS Boot Animation" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page4[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs4[@]}" "Go back to the previous menu" "Exit the toolkit" -a
elif (( $page_number == 3 )) ; then
    bento -t "ChromeOS Boot Animation" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page3[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled."  div "${found_images_subs3[@]}" "Go back to the previous menu" "Exit the toolkit" -a
elif (( $page_number == 2 )) ; then
    bento -t "ChromeOS Boot Animation" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page2[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs2[@]}" "Go back to the previous menu" "Exit the toolkit" -a
else
    page_number=1
    bento -t "ChromeOS Boot Animation" -c "Select an image to use as a boot animation" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page1[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs1[@]}" "Go back to the previous menu" "Exit the toolkit" -a
fi
    case "$selection" in
        "Exit") unmount_grub ; exit 0 ;;
        "Back") unmount_grub ; $previous_menu ;;
        "Image Scaling Method: ${scaling^}") toggle_scaling_method ; boot_anim_installer ;;
        "Preview Image Conversion: ${test_convert^}") toggle_test_convert ; boot_anim_installer ;;
        "Next Page") page_number=$(( page_number + 1 )) ; boot_anim_installer ;;
        "First Page") page_number=1 ; boot_anim_installer ;;
        "Last Page") page_number=$(( page_number - 1 )) ; boot_anim_installer ;;
        *)
            if [[ "$test_convert" == "enabled" ]] ; then
                boot_anim_installer_sub_debug
                boot_anim_installer
            else
                boot_anim_installer_sub
                boot_anim_engine
            fi ;;
    esac
}


boot_anim_installer_sub_debug(){
    target_img="boot_splash_frame01.png"
    image_converter
    sudo cp -r ~/tmp/brunch-image_converter/boot_splash_frame01.png "$downloads"/results.png
    rm -rf ~/tmp/brunch-image_converter
}

boot_anim_installer_sub(){
    target_img="boot_splash_frame01.png"
    image_converter
    # Check if the selection was a zip or not
    # If the selection was not a zip, split t into frames
    if [[ "$file_is_zip" == "false" ]] ; then
    bento -c "Building Boot Animation, please wait..."
        for i in {2..9} ; do
            cp boot_splash_frame01.png boot_splash_frame0$i.png
        done
        for i in {10..13} ; do
            cp boot_splash_frame01.png boot_splash_frame$i.png
        done
    fi
    get_boot_anim_name
    mount_grub
    # Make a folder for the new animation
    sudo mkdir -p /mnt/stateful_partition/unencrypted/bootsplash/"$boot_anim_name"/images_100_percent
    sudo mkdir -p /mnt/stateful_partition/unencrypted/bootsplash/"$boot_anim_name"/images_200_percent
    # Copy the new animation over
    sudo cp -r ~/tmp/brunch-image_converter/boot_splash_frame*.png /mnt/stateful_partition/unencrypted/bootsplash/"$boot_anim_name"/images_100_percent
    sudo cp -r ~/tmp/brunch-image_converter/boot_splash_frame*.png /mnt/stateful_partition/unencrypted/bootsplash/"$boot_anim_name"/images_200_percent
    # clean up
    rm -rf ~/tmp/brunch-image_converter
    # set the grub variable
    sudo sed -i "s/chromeos_bootsplash=$brunch_chromeos_bootsplash/chromeos_bootsplash=$boot_anim_name/" "$brunch_config"
    unmount_grub
}


get_boot_anim_name(){
    if [[ "$name_warning" == "true" ]] ; then
    bento -t "ChromeOS Boot Animation" -c "Input a name for this boot animation, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed."
    bento -n -c "Previous input: $selection" "Input contains a disallowed character, try again." -w
    else
    bento -t "ChromeOS Boot Animation" -c "Input a name for this boot animation, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed." -w
    fi
    if [[ "$selection" =~ ['!@#$%^&*()+'] ]] || [[ "$selection" == *" "* ]] ; then
        name_warning="true"
        get_boot_anim_name
    else
        name_warning="false"
        boot_anim_name="$selection"
    fi
}

boot_anim_remover(){
        previous_menu="boot_anim_engine"
        check_grub_format
        # Make this directory if it doesnt already exist
        sudo mkdir -p /mnt/stateful_partition/unencrypted/bootsplash/
        # Look inside to see if boot animations exist
        unset cba_options
        unset cba_options_sub
        curdir=$(pwd)
        cd /mnt/stateful_partition/unencrypted/bootsplash/
        while IFS=  read -r -d $'\0'; do
            if [[ ! "$REPLY" =~ " " ]] ; then
                REPLY="${REPLY:2}"
                if [[ "$REPLY" == "$brunch_chromeos_bootsplash" ]] && [[ ! -z "$brunch_chromeos_bootsplash" ]] ; then
                cba_options+=("◆ $REPLY")
                else
                cba_options+=("◯ $REPLY")
                fi
                cba_options_sub+=("Remove $REPLY")
            fi
        done < <(find . -mindepth 1 -maxdepth 1 -type d -print0)
        cd "$curdir"
        if [[ -z "$cba_options" ]] || [[ -z "$brunch_chromeos_bootsplash" ]] ; then
            boot_anim_engine
        else
            bento -t "ChromeOS Boot Animation" -c "Current Boot Animation: $brunch_chromeos_bootsplash" -m "${cba_options[@]}" div "Back" "Exit" -s "${cba_options_sub[@]}" div "Go back to the previous menu" "Exit the toolkit" -a
        fi
                if [[ "$selection" =~ (◆|◯) ]] ; then
                    selection=${selection:4}
                fi
                    case "$selection" in
                        "Exit") unmount_grub ; exit 0 ;;
                        "Back") $previous_menu ;;
                        *) boot_anim_remover_sub ; boot_anim_remover ;;
                    esac
}

boot_anim_remover_sub(){
    mount_grub
    sudo rm -rf "/mnt/stateful_partition/unencrypted/bootsplash/$selection"
    if [[ "$selection" == "$brunch_chromeos_bootsplash" ]] ; then
        sudo sed -i "s/chromeos_bootsplash=$brunch_chromeos_bootsplash/chromeos_bootsplash=/" "$brunch_config"
    fi
    unmount_grub
}

boot_anim_changer(){
    mount_grub
    sudo sed -i "s/chromeos_bootsplash=$brunch_chromeos_bootsplash/chromeos_bootsplash=$selection/" "$brunch_config"
    unmount_grub
}
#</>

#<~> Grub Themes
    theme_engine(){
        previous_menu="grub_options_menu"
        mount_grub
            theme_config="$HOME/tmp/brunch-workspace/efi/boot/theme.cfg"
            curdir=$(pwd)
            cd "$HOME/tmp/brunch-workspace/efi/boot/themes"
            current_theme=$(cat "$theme_config" | grep -m 1 "grub_theme=" | sed "s/.*grub_theme=//g")
            unset avaliable_themes
            unset avaliable_themes_subs
            while IFS=  read -r -d $'\0'; do
                if [[ ! "$REPLY" =~ " " ]] ; then
                    REPLY="${REPLY:2}"
                if [[ ! "$REPLY" == "default" ]] ; then
                    if [[ "$REPLY" == "$current_theme" ]] ; then
                    avaliable_themes+=("◆ $REPLY")
                    else
                    avaliable_themes+=("◯ $REPLY")
                    fi
                    avaliable_themes_subs+=("Switch to $REPLY")
                fi
                fi
            done < <(find . -mindepth 1 -maxdepth 1 -type d -print0)
            cd "$curdir"
        unmount_grub

        bento -t "Grub Themes" -c "Current theme: $current_theme" -m "${avaliable_themes[@]}" div "Install New Theme" "Remove a Theme" "Back" "Exit" -s "${avaliable_themes_subs[@]}" div "Add a new theme to choose from" "Remove a theme from the selection" "Go back to the previous menu" "Exit the toolkit" -a
        if [[ "$selection" =~ (◆|◯) ]] ; then
            selection=${selection:4}
        fi
            case "$selection" in
                "Exit") unmount_grub ; exit 0 ;;
                "Back") unmount_grub ; $previous_menu ;;
                "Install New Theme") find_images ; theme_installer ; theme_engine ;;
                "Remove a Theme") theme_remover ; theme_engine ;;
                *) theme_changer ; theme_engine ;;
            esac
    }

theme_changer(){
    mount_grub
    sudo sed -i "s/grub_theme=$current_theme/grub_theme=$selection/" "$theme_config"
    unmount_grub
}


theme_remover(){
        previous_menu="theme_engine"
        mount_grub
            theme_config="$HOME/tmp/brunch-workspace/efi/boot/theme.cfg"
            curdir=$(pwd)
            cd "$HOME/tmp/brunch-workspace/efi/boot/themes"
            current_theme=$(cat "$theme_config" | grep -m 1 "grub_theme=" | sed "s/.*grub_theme=//g")
            unset avaliable_themes
            unset avaliable_themes_subs
            while IFS=  read -r -d $'\0'; do
                if [[ ! "$REPLY" =~ " " ]] ; then
                    REPLY="${REPLY:2}"
                    if [[ ! "$REPLY" == "default" ]] ; then
                        if [[ "$REPLY" == "$current_theme" ]] ; then
                            avaliable_themes+=("◆ $REPLY")
                        else
                            avaliable_themes+=("◯ $REPLY")
                        fi
                    avaliable_themes_subs+=("Remove $REPLY from avaliable themes")
                    fi
                fi
            done < <(find . -mindepth 1 -maxdepth 1 -type d -print0)
            cd "$curdir"
        unmount_grub

        bento -t "Grub Themes" -c "Select a theme to remove" "" "Current theme: $current_theme" -m "${avaliable_themes[@]}" div "Back" "Exit" -s "${avaliable_themes_subs[@]}" div "Go back to the previous menu" "Exit the toolkit" -a
        if [[ "$selection" =~ (◆|◯) ]] ; then
            selection=${selection:4}
        fi
            case "$selection" in
                "Exit") unmount_grub ; exit 0 ;;
                "Back") $previous_menu ;;
                *) theme_remover_sub ; theme_remover ;;
            esac
}

theme_remover_sub(){
    mount_grub
    sudo rm -rf "$HOME/tmp/brunch-workspace/efi/boot/themes/$selection"
    if [[ "$selection" == "$current_theme" ]] ; then
        sudo sed -i "s/grub_theme=$current_theme/grub_theme=default/" "$theme_config"
    fi
    unmount_grub
}

theme_installer(){
    previous_menu="theme_engine"
    if [[ "$scaling" == "fit" ]] ; then
            scaling_tip="Fits the image to the canvas as well as it can. Quality may be lost at the risk of fitting the canvas as well as possible."
    elif [[ "$scaling" == "shrink" ]] ; then
        scaling_tip="Shrinks the image and tries to render a background automatically based on the top-left pixel. This is great for turning large images into centered icons"
    else
        scaling="center"
        scaling_tip="Centers the image and tries to render a background automatically based on the top-left pixel. Select this if your image is the right size already to preserve scale."
    fi
    if [[ -z "$test_convert" ]] ; then
        test_convert="disabled"
    fi

    if (( $page_number == 5 )) ; then
        bento -t "Grub Themes" -c "Select an image to use for Grub" div "Page $page_number of $total_images_split" "This is the maximum number of images the toolkit can show currently." -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page5[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs5[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 4 )) ; then
        bento -t "Grub Themes" -c "Select an image to use for Grub" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page4[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs4[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 3 )) ; then
        bento -t "Grub Themes" -c "Select an image to use for Grub" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page3[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled."  div "${found_images_subs3[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    elif (( $page_number == 2 )) ; then
        bento -t "Grub Themes" -c "Select an image to use for Grub" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page2[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs2[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    else
        page_number=1
        bento -t "Grub Themes" -c "Select an image to use for Grub" div "Page $page_number of $total_images_split"  -m "Image Scaling Method: ${scaling^}" "Preview Image Conversion: ${test_convert^}" div "${found_images_page1[@]}" "Back" "Exit" -s "Change how the image is scaled: $scaling_tip" "Creates a test file called results.png in your Downloads when enabled." div "${found_images_subs1[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    fi
        case "$selection" in
            "Exit") unmount_grub ; exit 0 ;;
            "Back") $previous_menu ;;
            "Image Scaling Method: ${scaling^}") toggle_scaling_method ; theme_installer ;;
            "Preview Image Conversion: ${test_convert^}") toggle_test_convert ; theme_installer ;;
            "Next Page") page_number=$(( page_number + 1 )) ; theme_installer ;;
            "First Page") page_number=1 ; theme_installer ;;
            "Last Page") page_number=$(( page_number - 1 )) ; theme_installer ;;
            *)
                if [[ "$test_convert" == "enabled" ]] ; then
                    theme_installer_sub_debug
                    theme_installer
                else
                    theme_installer_sub
                    theme_engine
                fi ;;
        esac
}

toggle_scaling_method(){
    if [[ "$scaling" == "fit" ]] ; then
        scaling="shrink"
    elif [[ "$scaling" == "shrink" ]] ; then
        scaling="center"
    else
        scaling="fit"
    fi
        sed -i "s/scaling=.*/scaling=$scaling/" "$config_file"
}

toggle_test_convert(){
    if [[ "$test_convert" == "enabled" ]] ; then
        test_convert="disabled"
    else
        test_convert="enabled"
    fi
}

theme_installer_sub_debug(){
    target_img="background.png"
    image_converter
    sudo cp -r ~/tmp/brunch-image_converter/$target_img "$downloads"/results.png
}

theme_installer_sub(){
    target_img="background.png"
    image_converter
    get_theme_name
    mount_grub
    # Make a folder for the new theme
    sudo mkdir -p "$HOME/tmp/brunch-workspace/efi/boot/themes/$theme_name"
    # Copy over the default theme's assets
    sudo cp -r "$HOME/tmp/brunch-workspace/efi/boot/themes/default/." "$HOME/tmp/brunch-workspace/efi/boot/themes/$theme_name"
    # Copy the new background image over
    sudo cp -r ~/tmp/brunch-image_converter/$target_img "$HOME/tmp/brunch-workspace/efi/boot/themes/$theme_name/$target_img"
    rm -rf ~/tmp/brunch-image_converter
    sudo sed -i "s/grub_theme=$current_theme/grub_theme=$theme_name/" "$theme_config"
    unmount_grub
}

get_theme_name(){
    if [[ "$name_warning" == "true" ]] ; then
    bento -t "Grub Themes" -c "Selected image: $source_img" " " "Input a name for this theme, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed."
    bento -n -c "Previous input: $selection" "Input contains a disallowed character, try again." -w
    else
    bento -t "Grub Themes" -c "Selected image: $source_img" " " "Input a name for this theme, do not use any special characters, periods or spaces." "Underscore _ and hyphen - characters are allowed." -w
    fi
    if [[ "$selection" =~ ['!@#$%^&*()+'] ]] || [[ "$selection" == *" "* ]] ; then
        name_warning="true"
        get_theme_name
    else
        name_warning="false"
        theme_name="$selection"
    fi
}
#</>

#<~> ImageMagick Functions

#<~> Image finder
find_images(){
        curdir=$(pwd)
        cd "$downloads"
        page_number=1
        unset found_images
        unset found_images_subs
        unset found_images_page1
        unset found_images_subs1
        unset found_images_page2
        unset found_images_subs2
        unset found_images_page3
        unset found_images_subs3
        unset found_images_page4
        unset found_images_subs4
        unset found_images_page5
        unset found_images_subs5
        # Find files and sort by extention
    if [[ "$1" == "zip" ]] ; then
        while IFS=  read -r -d $'\0'; do
            prefix="${REPLY:2:2}"
            if [[ ! "$REPLY" =~ " " ]] && [[ ! "$prefix" == '._' ]] && [[ ! "$prefix" == '--' ]]; then
                found_images+=("${REPLY:2}")
                found_images_subs+=("Select ${REPLY:2}")
            fi
        done < <(find . -mindepth 1 -maxdepth 1 -regex '.*\.\(zip\|png\|jpg\|jpeg\)' -print0 | sort -z)
    else
        while IFS=  read -r -d $'\0'; do
            prefix="${REPLY:2:2}"
            if [[ ! "$REPLY" =~ " " ]] && [[ ! "$prefix" == '._' ]] && [[ ! "$prefix" == '--' ]]; then
                found_images+=("${REPLY:2}")
                found_images_subs+=("Select ${REPLY:2}")
            fi
        done < <(find . -mindepth 1 -maxdepth 1 -regex '.*\.\(png\|jpg\|jpeg\)' -print0)
    fi
        cd "$curdir"
        #theme_installer_sub
        total_images="${#found_images[@]}"
        if (( "$total_images" > 10 )) ; then
            total_images_split=$((( total_images / 10 ) + ( total_images % 10 > 0 )))
            i=1
            while (($i <= $total_images_split)) ; do
                # only do 5 loops max for a total of 50 images
                if (( $i == 1 )) ; then
                    for x in {1..10} ; do
                        if [[ ! -z "${found_images[$x]}" ]] ; then
                        found_images_page1+=("${found_images[$x]}")
                        found_images_subs1+=("${found_images_subs[$x]}")
                        fi
                    done
                        found_images_page1+=('div')
                        found_images_subs1+=('div')
                    if [[ ! -z "${found_images[11]}" ]] ; then
                        found_images_page1+=('Next Page')
                        found_images_subs1+=('Go to the next page')
                    fi
                fi
                if (( $i == 2 )) ; then
                    for x in {11..20} ; do
                        if [[ ! -z "${found_images[$x]}" ]] ; then
                        found_images_page2+=("${found_images[$x]}")
                        found_images_subs2+=("${found_images_subs[$x]}")
                    fi
                    done
                        found_images_page2+=('div')
                        found_images_subs2+=('div')
                    if [[ ! -z "${found_images[21]}" ]] ; then
                        found_images_page2+=('Next Page')
                        found_images_subs2+=('Go to the next page')
                        found_images_page2+=('Last Page')
                        found_images_subs2+=('Go to the last page')
                    else
                        found_images_page2+=('First Page')
                        found_images_subs2+=('Go to the first page')
                    fi
                fi
                if (( $i == 3 )) ; then
                    for x in {21..30} ; do
                        if [[ ! -z "${found_images[$x]}" ]] ; then
                        found_images_page3+=("${found_images[$x]}")
                        found_images_subs3+=("${found_images_subs[$x]}")
                    fi
                    done
                        found_images_page3+=('div')
                        found_images_subs3+=('div')
                    if [[ ! -z "${found_images[31]}" ]] ; then
                        found_images_page3+=('Next Page')
                        found_images_subs3+=('Go to the next page')
                    else
                        found_images_page3+=('First Page')
                        found_images_subs3+=('Go to the first page')
                    fi
                        found_images_page3+=('Last Page')
                        found_images_subs3+=('Go to the last page')
                fi
                if (( $i == 4 )) ; then
                    for x in {31..40} ; do
                        if [[ ! -z "${found_images[$x]}" ]] ; then
                        found_images_page4+=("${found_images[$x]}")
                        found_images_subs4+=("${found_images_subs[$x]}")
                    fi
                    done
                        found_images_page4+=('div')
                        found_images_subs4+=('div')
                    if [[ ! -z "${found_images[41]}" ]] ; then
                        found_images_page4+=('Next Page')
                        found_images_subs4+=('Go to the next page')
                    else
                        found_images_page4+=('First Page')
                        found_images_subs4+=('Go to the first page')
                    fi
                        found_images_page4+=('Last Page')
                        found_images_subs4+=('Go to the last page')
                fi
                if (( $i == 5 )) ; then
                    for x in {41..50} ; do
                        if [[ ! -z "${found_images[$x]}" ]] ; then
                        found_images_page5+=("${found_images[$x]}")
                        found_images_subs5+=("${found_images_subs[$x]}")
                    fi
                    done
                        found_images_page5+=('div')
                        found_images_subs5+=('div')
                        found_images_page5+=('First Page')
                        found_images_subs5+=('Go to the first page')
                        found_images_page5+=('Last Page')
                        found_images_subs5+=('Go to the last page')
                fi
                i=$((i + 1))
            done
        else
            for elem in "${found_images[@]}" ; do
                found_images_page1+=("$elem")
            done
            for elem in "${found_images_subs[@]}" ; do
                found_images_subs1+=("$elem")
            done
                found_images_page1+=('div')
                found_images_subs1+=('div')
            total_images_split=1
        fi
        if (( "$total_images_split" > 5 )) ; then
            total_images_split=5
        fi
}
#</>

get_screen_size(){
    previous_menu="theme_installer"
    gsc_width
    previous_menu="gsc_width"
    gsc_height
    previous_menu="theme_installer"
    bento -t "Grub Themes" -c "Your screen's dimensions are $width x $height" "Is this correct?" -m "Yes - Save as default" "Yes - Don't save as default" "No" "Back" "Exit" -s "Confirm screen size" "Reinput screen size" "Go back to the theme menu" "Exit the toolkit" -a
    case "$selection" in
        "Exit") exit 0 ;;
        "Back") $previous_menu ;;
        "No")   get_screen_size ;;
        "Yes - Save as default")  save_screen_size ;; #Continue to the rest of the imagemagick script
        "Yes - Don't save as default")  : ;; #Continue to the rest of the imagemagick script
    esac
}

save_screen_size(){
    sed -i "s/height=.*/height=$height/" "$config_file"
    sed -i "s/width=.*/width=$width/" "$config_file"
}

gsc_width(){
    if [[ -z "$retry_value" ]] ; then
        bento -t "Grub Themes" -c "Unable to determine your screen size." "Please enter your screen's exact width in pixels." -w
    else
        bento -t "Grub Themes" -c "Unable to determine your screen size." "Please enter your screen's exact width in pixels."
        bento -c "A numeric value is required" -w
    fi
width=$(echo "$selection" | tr -d -c 0-9 )
if [[ -z "$width" ]] ; then
    gsc_width
fi
retry_value=
}

gsc_height(){
    if [[ -z "$retry_value" ]] ; then
        bento -t "Grub Themes" -c "Unable to determine your screen size." "Please enter your screen's exact height in pixels." -w
    else
        bento -t "Grub Themes" -c "Unable to determine your screen size." "Please enter your screen's exact height in pixels."
        bento -c "A numeric value is required" -w
    fi
height=$(echo "$selection" | tr -d -c 0-9 )
if [[ -z "$height" ]] ; then
    gsc_height
fi
retry_value=
}

check_for_all_cba(){
    bento -c "Checking zip contents, please wait..."
    valid_cba=
    for i in {1..9} ; do
        if [[ ! "$valid_cba" == "false" ]] ; then
            ls ~/tmp/brunch-image_converter/boot_splash_frame0$i.png 2> /dev/null || valid_cba="false"
        fi
    done
    for i in {10..13} ; do
        if [[ ! "$valid_cba" == "false" ]] ; then
        ls ~/tmp/brunch-image_converter/boot_splash_frame$i.png 2> /dev/null || valid_cba="false"
        fi
    done
    if [[ "$valid_cba" == "false" ]] ; then
        bento -c "This zip archive does not contain a valid ChromeOS Boot Animation" "A valid ChromeOS Boot Animation should contain 13 pngs named as follows:" "" "boot_splash_frame01.png through boot_splash-frame13.png" -e
        cd "$curdir"
        rm -rf ~/tmp/brunch-image_converter/*
        boot_anim_installer
    else
        source_img=$(ls ~/tmp/brunch-image_converter/boot_splash_frame01.png 2> /dev/null)
    fi
}

check_for_all_bbs(){
    bento -c "Checking zip contents, please wait..."
    valid_bbs=
        ls ~/tmp/brunch-image_converter/main.png 2> /dev/null || valid_bbs="false"
        ls ~/tmp/brunch-image_converter/rebuilding.png 2> /dev/null || valid_bbs="false"
        ls ~/tmp/brunch-image_converter/patching.png 2> /dev/null || valid_bbs="false"
        ls ~/tmp/brunch-image_converter/incompatible.png 2> /dev/null || valid_bbs="false"

        if [[ "$valid_bbs" == "false" ]] ; then
            bento -c "This zip archive does not contain a valid Brunch Bootsplash" "A valid Brunch Bootsplash should contain 4 pngs named as follows:" "" "main.png" "rebuilding.png" "patching.png" "incompatible.png" -e
            cd "$curdir"
            rm -rf ~/tmp/brunch-image_converter/*
            bootsplash_installer
        else
            source_img=$(ls ~/tmp/brunch-image_converter/main.png 2> /dev/null)
        fi
}

image_converter(){
    #grub should not be mounted here, make absolutely sure that it isn't
    unmount_grub
    # We're making a different directory here than usual, this is because we may need access to these files when grub is mounted later so we do not want to mount over them
    mkdir -p ~/tmp/brunch-image_converter
    # we don't want any stray files in there if it already exists
    rm -rf ~/tmp/brunch-image_converter/*
    cp "$downloads/$selection" ~/tmp/brunch-image_converter
    curdir="$pwd"
    cd ~/tmp/brunch-image_converter
    source_img="$selection"
    file_is_zip="false"
    # if the source_img is a zip file, unzip the file directly first
    if [[ "${source_img##*.}" == "zip" ]] ; then
        file_is_zip="true"
        # Unzip the file and parse contents accordingly
        bsdtar -xvf "$source_img" --exclude "*_MACOSX*" | pv -s $(du -sb ~/tmp/brunch-image_converter/ | awk '{print $1}')
        if [[ "$zip_mode" == "cba" ]] ; then
            # Check if zip is a valid ChromeOS Boot Animation based on contents
            check_for_all_cba
        elif [[ "$zip_mode" == "bbs" ]] ; then
            # Check if zip is a valid Brunch Bootsplash based on contents
            check_for_all_bbs
        fi
    fi
# Get height and width of the user's screen for setting final image size
    if [[ -z "$width" ]] || [[ -z "$height" ]] ; then
        width=$(dmesg | grep -i drm_get_panel | tail -1 | cut -d" " -f8 | sed "s#width=##g")
        height=$(dmesg | grep -i drm_get_panel | tail -1 | cut -d" " -f9 | sed "s#height=##g")
        # If these can't be autodetected, prompt the user to set the values.
            if [[ -z "$width" ]] || [[ -z "$height" ]] ; then
                get_screen_size
            else
                save_screen_size
            fi
    fi
# Define a usercolor from the top left pixel color in the selection
# This color will be used as padding in case the image has borders/letterboxing
    usercolor=$(convert $source_img -format "%[pixel:p{0,0}]" info:)
# assume black  if color cannot be retrieved from selection
    if [ -z "$usercolor" ] || [ "$usercolor" == "srgba(0,0,0,0)" ] ; then
        usercolor="black"
    fi
# Get the height and width of the selected image
    img_width=$(identify $source_img | cut -f 3 -d " " | sed s/x.*//)
    img_height=$(identify $source_img | cut -f 3 -d " " | sed s/.*x//)
# set scaling
    if [[ "$scaling" == "center" ]] || [[ -z "$scaling" ]] ; then
            # Center image on canvas
            canvas_width=$(( $width + $img_width ))
            canvas_height=$(( $height + $img_height ))
            scale_height="$canvas_height"
            scale_width="$canvas_width"
    elif [[ "$scaling" == "fit" ]] ; then
            # fit image to canvas
        if (( $img_height > $img_width )) ; then
                padding=$(( $img_height - $img_width ))
                canvas_width=$(( $img_width + $padding ))
                canvas_height="$img_height"
        else
                canvas_width="$img_width"
                canvas_height="$img_height"
        fi
            scale_height="$height"
            scale_width="$width"
    elif [[ "$scaling" == "shrink" ]] ; then
                    # Center image on canvas as an icon
                    canvas_width=$(( ( $width * 4 ) + $img_width ))
                    canvas_height=$(( ( $height * 4) + $img_height ))
                    scale_height="$height"
                    scale_width="$width"
    fi

    if [[ "$file_is_zip" == "true" ]] ; then
        if [[ "$zip_mode" == "cba" ]] ; then
        bento -c "Converting images to fit your screen, please wait..."
            for i in {1..9} ; do
                convert boot_splash_frame0$i.png -gravity center -background "$usercolor" -flatten -extent "$canvas_width"x"$canvas_height" -geometry "$scale_width"x"$scale_height"^ -crop "$width"x"$height"+0+0 boot_splash_frame0$i.png
            done
            for i in {10..13} ; do
                convert boot_splash_frame$i.png -gravity center -background "$usercolor" -flatten -extent "$canvas_width"x"$canvas_height" -geometry "$scale_width"x"$scale_height"^ -crop "$width"x"$height"+0+0 boot_splash_frame0$i.png
            done
        elif [[ "$zip_mode" == "bbs" ]] ; then
            bento -c "Converting images to fit your screen, please wait..."
            bbs_outputs=("main.png" "rebuilding.png" "patching.png" "incompatible.png")
            for elem in "${bbs_outputs[@]}" ; do
                convert "$elem" -gravity center -background "$usercolor" -flatten -extent "$canvas_width"x"$canvas_height" -geometry "$scale_width"x"$scale_height"^ -crop "$width"x"$height"+0+0 "$elem"
            done
        fi
    else
        bento -c "Converting image to fit your screen, please wait..."
        convert $source_img -gravity center -background "$usercolor" -flatten -extent "$canvas_width"x"$canvas_height" -geometry "$scale_width"x"$scale_height"^ -crop "$width"x"$height"+0+0 "$target_img"
    fi
    cd "$curdir"
}

#</>

#<~> Change Kernels
    kernel_options(){
        check_for_dualboot
        check_grub_format
            previous_menu="grub_options_menu"
        get_possible_kernels
        previous_menu="grub_options_menu"
        bento -t "Kernel Options" -c "Quickly swap between avaliable Brunch Kernels" "" "WARNING! Changing kernels can prevent users from logging in to their ChromeOS account, in which case a powerwash is the only solution (CTRL + ALT + SHIFT + R at the login screen)." "Before switching to a different kernel, make sure there is a backup of all user data!" div "Current Kernel: $brunch_kernel_option" -m "${avaliable_kernels[@]}" div "Back" "Exit" -s "${avaliable_kernels_subs[@]}" div "Go back to the previous menu" "Exit the toolkit" -a
            case "$selection" in
                "Exit") exit 0 ;;
                "Back") $previous_menu ;;
                *) select_kernel ; kernel_options ;;
            esac
    }

    select_kernel(){
        if [[ "$selection" == "kernel-5.4" ]] ; then
            selection="kernel"
        fi
        if [[ "$brunch_kernel_option" == "kernel-5.4" ]] ; then
            brunch_kernel_option="kernel"
        fi
        mount_grub
        if [[ "$new_grub" == "true" ]] ; then
        sudo sed -i "s|kernel=$brunch_kernel_option|kernel=/$selection|" "$brunch_config"
        else
        sudo sed -i "s/$brunch_kernel_option/$selection/" "$brunch_config"
        unmount_grub
        fi

    }

    get_possible_kernels(){
        if (( $current_brunch_version > 20201226 )) ; then
            avaliable_kernels=("kernel-4.19" "kernel-5.4" "kernel-5.10")
            avaliable_kernels_subs=("Swap to kernel-4.19" "Swap to kernel-5.4" "Swap to kernel-5.10")
        else
            avaliable_kernels=("kernel-4.19" "kernel-5.4")
            avaliable_kernels_subs=("Swap to kernel-4.19" "Swap to kernel-5.4")
        fi
    }
#</>

#<~> Framework Options

mount_grub(){
    mkdir -p ~/tmp/brunch-workspace
    sudo mount "$partsource"12 ~/tmp/brunch-workspace
}

unmount_grub(){
    # do this twice to be sure
    sudo umount ~/tmp/brunch-workspace 2> /dev/null
        sudo umount ~/tmp/brunch-workspace 2> /dev/null
}

framework_options(){
    previous_menu="grub_options_menu"
    check_grub_format
    build_framework_menu
    fwo_menu=(-t "Framework Options" -c "Select Framework Options to toggle them on or off, changes are saved automatically." -x -m )
    if [[ "$current_page" == "page1" ]] ; then
        bento "${fwo_menu[@]}" "${menu_fwo_page1[@]}" div "Back" "Exit" -s "${fwo_page1_subs[@]}" div "Go back to the previous menu" "Exit the toolkit"
    elif [[ "$current_page" == "page2" ]] ; then
        bento "${fwo_menu[@]}" "${menu_fwo_page2[@]}" div "Back" "Exit" -s "${fwo_page2_subs[@]}" div "Go back to the previous menu" "Exit the toolkit"
    elif [[ "$current_page" == "wifi" ]] ; then
        bento "${fwo_menu[@]}" "${menu_fwo_wifi[@]}" div "Back" "Exit" -s "${fwo_wifi_subs[@]}" div "Go back to the previous menu" "Exit the toolkit"
    fi
    case "$selection" in
            "Exit") exit 0 ;;
            "Back") current_page= ; $previous_menu ;;
            "More Options") current_page="page2" ;;
            "Wifi Options") current_page="wifi" ;;
            "Other Options") current_page="page1" ;;
            *) toggle_fwo ;;
    esac
    # reloop this menu for the aesthetic
    framework_options
}

toggle_fwo(){
    unset temp_fwo
    if [[ "$selection" =~ "◆" ]] ; then
    selection="${selection:4}"
        #remove this option from the array
        #for (( i=0; i < "${#brunch_framework_options[@]}"; i++ )) ; do
        for elem in "${brunch_framework_options[@]}" ; do
            if [[ ! "$elem" == "$selection" ]] ; then
                temp_fwo+=" $elem"
            fi
        done
    elif [[ "$selection" =~ "◯" ]] ; then
    selection="${selection:4}"
        #add this option to the array
        for (( i=0; i < "${#brunch_framework_options[@]}"; i++ )) ; do
            temp_fwo+=" ${brunch_framework_options[$i]}"
        done
        temp_fwo+=" $selection"
    fi
    # return array to the original format, opt1,opt2,opt3
    temp_fwo_unfiltered=$(echo "${temp_fwo[@]}" | xargs | sed "s/ /,/g")
    # swap the original unfiltered options with the new unfiltered option
    mount_grub
    sudo sed -i "s/options=$brunch_framework_options_unfiltered/options=$temp_fwo_unfiltered/" "$brunch_config"
    unmount_grub
}

build_framework_menu(){
    unset menu_fwo_page1
    unset menu_fwo_page2
    unset menu_fwo_wifi
    #compare user options to arrays and mark ◆ or ◯ as needed
        for (( i=0; i < "${#fwo_page1[@]}"; i++ )) ; do
            if [[ "${fwo_page1[$i]}" =~ "Options" ]] ; then
                menu_fwo_page1+=("${fwo_page1[$i]}")
            elif [[ "${brunch_framework_options[@]}" =~ "${fwo_page1[$i]}" ]] ; then
                # if theres a match
                menu_fwo_page1+=("◆ ${fwo_page1[$i]}")
            else # if theres NO match
                menu_fwo_page1+=("◯ ${fwo_page1[$i]}")
            fi
        done
        for (( i=0; i < "${#fwo_page2[@]}"; i++ )) ; do
            if [[ "${fwo_page2[$i]}" =~ "Options" ]] ; then
                menu_fwo_page2+=("${fwo_page2[$i]}")
            elif [[ "${brunch_framework_options[@]}" =~ "${fwo_page2[$i]}" ]] ; then
                # if theres a match
                menu_fwo_page2+=("◆ ${fwo_page2[$i]}")
            else # if theres NO match
                menu_fwo_page2+=("◯ ${fwo_page2[$i]}")
            fi
        done
        for (( i=0; i < "${#fwo_wifi[@]}"; i++ )) ; do
            if [[ "${fwo_wifi[$i]}" =~ "Options" ]] ; then
                menu_fwo_wifi+=("${fwo_wifi[$i]}")
            elif [[ "${brunch_framework_options[@]}" =~ "${fwo_wifi[$i]}" ]] ; then
                # if theres a match
                menu_fwo_wifi+=("◆ ${fwo_wifi[$i]}")
            else # if theres NO match
                menu_fwo_wifi+=("◯ ${fwo_wifi[$i]}")
            fi
        done
    if [[ -z "$current_page" ]] ; then current_page="page1" ; fi
}
#</>

#<~> Install Brunch

install_brunch(){
    unset boot_opts
    unset boot_opts_subs
    if [[ "$toolkit_mode" =~ "usb" ]] ; then
        boot_opts=("Singleboot" "Generate IMG" "Back" "Exit")
            boot_opts_subs=("Install Brunch to a single disk" "Create an IMG file" "Go back to the previous menu" "Exit the toolkit without installing")
    elif [[ "$toolkit_mode" =~ "wsl" ]] ; then
        boot_opts=("Generate IMG" "Back" "Exit")
            boot_opts_subs=("Create an IMG file" "Go back to the previous menu" "Exit the toolkit without installing")
    else
        boot_opts=("Install to USB" "Singleboot" "Dualboot" "Generate IMG" "Back" "Exit")
            boot_opts_subs=("Install Brunch to a USB" "Install Brunch to a single disk" "Install Brunch to a single partition" "Create an IMG file" "Go back to the previous menu" "Exit the toolkit without installing")
    fi
    bento -t "Install Brunch" -c "Select installation type." -m "${boot_opts[@]}" -s "${boot_opts_subs[@]}" -a
    # Currently USB and singleboot are the same
    # Generate IMG is the same as dualboot until the grub section. If in WSL dont mount a dst
    case "$selection" in
            "Exit") exit 0 ;;
            "Back") main_menu_startup ;;
            *) install_method="$selection" ; install_brunch_sub ; main_menu_startup ; return ;;
    esac
}

install_brunch_sub(){
    if [[ "$toolkit_mode" =~ "wsl" ]] ; then
        # if using WSL, don't bother selecting a dst since it's always a chromeos.img
        selected_dst="chromeos.img"
        selected_size="14"
        select_src
        else
    unset possible_outs
        unset possible_outs_subs
    data=($(lsblk -b -io KNAME,TYPE,SIZE | grep "[smn][dmv]" | grep -Ev "part" | sed 's/.*dev//'  | awk '$3 > 16*2^30 {print $1"="$3/1073741824"G"}'))
    for elem in "${data[@]}" ; do
        seperate_parts=$(echo "$elem" | sed 's/=/    /')
        possible_outs+=("$seperate_parts")
        possible_outs_subs+=("Select $seperate_parts")
    done
    bento -t "Install Brunch" -c "Please select which of these disks you would like to install Brunch to." div "Only disks large enough for Brunch are shown. (16GB or larger)" -m "${possible_outs[@]}" "Back" "Exit" -s "${possible_outs_subs[@]}" "Go back to the previous menu" "Exit the toolkit without installing" -a
    case "$selection" in
            "Exit") exit 0 ;;
            "Back") install_brunch ; return ;;
            *) selected_dst=$(echo "$selection" | awk '{print $1}') ; select_dst ; return ;;
    esac
fi
    }

select_dst(){
    unset possible_outs
        unset possible_outs_subs
    if [[ "$install_method" =~ "USB" ]] || [[ "$install_method" = "Singleboot" ]] ; then
        selected_dst="/dev/$selected_dst"
        select_src
    elif [[ "$install_method" = "Dualboot" ]] ||  [[ "$install_method" =~ "IMG" ]] ; then
        data=($(lsblk -b -io KNAME,TYPE,SIZE | grep "$selected_dst" | grep -Ev "disk" | sed 's/.*dev//'  | awk '$3 > 16*2^30 {print $1"="$3/1073741824"G"}'))
        for elem in "${data[@]}" ; do
            seperate_parts=$(echo "$elem" | sed 's/=/    /')
            possible_outs+=("$seperate_parts")
            possible_outs_subs+=("Select $seperate_parts")
        done
        bento -t "Install Brunch" -c "Please select which of these partitions you would like to install Brunch to." div "Only partitions large enough for Brunch are shown. (16GB or larger)" -m "${possible_outs[@]}" "Back" "Exit" -s "${possible_outs_subs[@]}" "Go back to the previous menu" "Exit the toolkit without installing" -a
        case "$selection" in
                "Exit") exit 0 ;;
                "Back") install_brunch_sub ; return ;;
                *) selected_dst=$(echo "$selection" | awk '{print $1}') ; select_size ; return ;;
        esac
    fi
}

select_size(){
    previous_menu="install_brunch_sub"
    unmount_target
    mount_target
    avaliable_space=$(df -BG ~/tmpmount | awk 'NR==2 {print $4}')
    unmount_target
    if [[ -n "$avaliable_space" ]] ; then
    avaliable_space=$(echo "${avaliable_space%.*}" | sed 's/G//')
    avaliable_space_text="Avaliable space: ${avaliable_space%.*}"
    fi
    bento -t "Install Brunch" -c "What size in GB should this installation be?" "$avaliable_space_text" div "Enter size in GB, must be at least 14" -w
        previous_menu="select_size"
    if [[ -z "${selection##*[!0-9]*}" ]] ; then
        bento -g -c "Entered value is not numeric." "(Do not include letters or decimals)" -r
    elif [[ -z "$selection" ]] ; then
        bento -g -c "You must enter a number." -r
    elif (( "$selection" < "14" )) ; then
        bento -g -c "Entered value is too small." -r
        select_size
    elif (( "$selection" > "$avaliable_space" )) ; then
        bento -g -c "Entered value is too large." -r
    else
        : # proceed with this size
        selected_size="$selection"
        select_src
    fi
}

mount_target(){
    mkdir -p ~/tmpmount
    sudo mount "$selected_dst" ~/tmpmount
}

unmount_target(){
    # do this twice, just in case , errors here are inconsequential
    sudo umount ~/tmpmount 2> /dev/null
        sudo umount ~/tmpmount 2> /dev/null
}

select_src(){
    if [[ "$toolkit_mode" =~ "brunch" ]] ; then
        prepare_installation # skip getting a src and skip getting brunch files
    elif [[ "$onlineallowed" = "true" ]] ; then
        automatic_chromeos_download
        automatic_brunch_download
        prepare_installation
    else
        advanced_chromeos_select
        advanced_brunch_select
        prepare_installation
    fi
}

automatic_chromeos_download(){
            # Make a working directory to keep toolkit out of sight
                mkdir -p ~/tmp/brunch-workspace
                curdir=$(pwd)
                cd ~/tmp/brunch-workspace
                chrome_url=$(curl -s https://cros.tech/device/$selected_recovery | tr ' ' '\n' | tr '>' '\n' | grep href= | sed 's/"//g' | sed 's/href=//g' | tail -1)
                chrome_url_vers=$(curl -s https://cros.tech/device/$selected_recovery | tr ' ' '\n' | tr '>' '\n' | sed 's/"//g' | sed 's/href=//g' | grep '</span' | sed 's/<\/span//g' | tail -1)
                bento -t "Install Brunch" -c "Downloading the latest ${selected_recovery^} $chrome_url_vers recovery, please wait..."
                curl -L -O --progress-bar "$chrome_url"
                updatefile="$(find *$selected_recovery*bin.zip 2> /dev/null | sort -r | head -1 )"
            # unzip the file
                bento -t "Install Brunch" -c "Now extracting the recovery file, please wait..."
                if [[ "$toolkit_mode" =~ "linux" ]] || [[ "$toolkit_mode" =~ "arch" ]] ; then
                    unzip "$updatefile"
                elif [[ "$toolkit_mode" =~ "brunch" ]] ; then
                    bsdtar -xf "$updatefile"
                fi
                recovery_bin="$(find *$selected_recovery*bin 2> /dev/null | sort -r | head -1 )"
                selected_src="$recovery_bin"
                rm -rf "$updatefile"
                cd "$curdir"
}

advanced_chromeos_select(){
        previous_menu="install_brunch_sub"
        curdir=$(pwd)
        cd "$downloads"
        #brunch_files=($(find *runch*.tar.gz 2> /dev/null | sort -r))
        unset chrome_files
    chrome_files=()
    while IFS=  read -r -d $'\0'; do
        if [[ ! "$REPLY" =~ " " ]] ; then
            chrome_files+=("${REPLY:2}")
        fi
    done < <(find . -name "*hrome*.bin*" -print0)

        if [[ -n "$chrome_files" ]] ; then
        bento -t "Install Brunch" -c "Please select a recovery archive to install with." -m "${chrome_files[@]}" "Back" "Exit" -s "${chrome_files[@]}" "Go back to the previous menu" "Exit without installing." -a
        case "$selection" in
            "Back") cd "$curdir" ;"$previous_menu" ; return ;;
            "Exit") exit 0 ;;
            *) updatefile="$selection" ;;
        esac
        if [[ "${selection: -4}" == ".bin" ]] ; then
            bento -t "Install Brunch" -c "Now extracting the recovery file, please wait..."
            if [[ "$toolkit_mode" =~ "linux" ]] || [[ "$toolkit_mode" =~ "arch" ]] ; then
                unzip "$updatefile"
            elif [[ "$toolkit_mode" =~ "brunch" ]] ; then
                bsdtar -xf "$updatefile"
            fi
            recovery_bin=$(echo "$updatefile" | sed 's/.zip//')
            selected_src="$downloads/$recovery_bin"
        elif  [[ "${selection: -4}" == ".bin" ]] ; then
            recovery_bin="$updatefile"
        fi
        selected_src="$downloads/$recovery_bin"
            cd "$curdir"
        else
            cd "$curdir"
            bento -t "Install Brunch" -c "Unable to find ChromeOS recovery archives in $downloads" "You can manually download the latest release of ${selected_recovery^} here:" "https://cros.tech/device/$selected_recovery" div "Be sure to keep the default filename and extention, and make sure there are no spaces in the filename." -r
        fi
}

automatic_brunch_download(){
    # Make a working directory to keep toolkit out of sight
        mkdir -p ~/tmp/brunch-workspace
        curdir=$(pwd)
        cd ~/tmp/brunch-workspace
        bento -t "Install Brunch" -c "Downloading the latest Brunch release, please wait..."
        curl -L -O --progress-bar "$(curl -s https://api.github.com/repos/sebanc/brunch/releases/latest | grep 'browser_' | cut -d\" -f4)"
        updatefile="$(find *runch*tar.gz 2> /dev/null | sort -r | head -1 )"
    # extract brunch release to the workspace
        bento -t "Install Brunch" -c "Now extracting the Brunch release, please wait..."
        tar zxvf "$updatefile"
        rm -rf "$updatefile"
    # eventually add MBR support here
        cd "$curdir"
}

advanced_brunch_select(){
    previous_menu="advanced_chromeos_select"
    curdir=$(pwd)
    cd "$downloads"
    #brunch_files=($(find *runch*.tar.gz 2> /dev/null | sort -r))
    unset brunch_files
brunch_files=()
while IFS=  read -r -d $'\0'; do
    if [[ ! "$REPLY" =~ " " ]] ; then
        brunch_files+=("${REPLY:2}")
    fi
done < <(find . -name "*runch_r*.tar.gz" -print0)

    if [[ -n "$brunch_files" ]] ; then
    bento -t "Install Brunch" -c "Please select a Brunch archive to install with." -m "${brunch_files[@]}" "Back" "Exit" -s "${brunch_files[@]}" "Go back to the previous menu" "Exit without updating." -a
    case "$selection" in
        "Back") cd "$curdir" ;"$previous_menu" ; return ;;
        "Exit") exit 0 ;;
        *) updatefile="$selection" ;;
    esac
# extract brunch release to the workspace
    bento - "Install Brunch" -c "Now extracting the Brunch release, please wait..."
        mkdir -p ~/tmp/brunch-workspace
    tar zxvf "$updatefile" -c ~/tmp/brunch-workspace
    rm -rf "$updatefile"
# eventually add MBR support here
        cd "$curdir"
    else
        cd "$curdir"
        bento -t "Install Brunch" -c "Unable to find Brunch tar.gz archives in $downloads" "You can manually download the latest release from github here:" "https://github.com/sebanc/brunch/releases" div "Be sure to keep the default filename and extention, and make sure there are no spaces in the filename." -r
    fi

}

prepare_installation(){
    #command -v bento >/dev/null 2>&1 || bento_installed="false"
    bento -t "Install Brunch" -c "Now installing Brunch, please wait..."
    curdir=$(pwd)
    cd ~/tmp/brunch-workspace

    if [[ "$toolkit_mode" =~ "brunch" ]] ; then
        sudo chromeos-install -dst "$selected_dst"

    elif [[ "$toolkit_mode" =~ "wsl" ]] ; then
        sudo bash chromeos-install.sh -dst "$downloads"/chromeos.img -src "$selected_src" -s "$selected_size"
        etcher=$(find $downloads/balenaEtcher*ortable*.exe 2> /dev/null | head -1 )
        etcherlink=$(curl -s https://api.github.com/repos/balena-io/etcher/releases/latest | grep 'browser_' | cut -d\" -f4 | grep 'Portable')
        if [ -z "$etcher" ] ; then
            bento -t "Install Brunch" -c "Now downloading Etcher, please wait..."
            curl -L -O --progress-bar "$etcherlink"
        fi
            bento -t "Install Brunch" -c "The Etcher window should open shortly, please select your chromeos.img and your USB to flash the img to it." "It should be located in: $downloads" -e
            $etcher

    elif [[ "$install_method" =~ "USB" ]] || [[ "$install_method" == "Singleboot" ]] ; then
        sudo bash chromeos-install.sh -dst "$selected_dst" -src "$selected_src"

    elif [[ "$install_method" =~ "IMG" ]] || [[ "$install_method" == "Dualboot" ]] ; then
        mount_target
        sudo bash chromeos-install.sh -dst ~/tmpmount/chromeos.img -src "$selected_src" -s "$selected_size"
        unmount_target
    fi
            cd "$curdir"
finalize_installation
}

finalize_installation(){
    if [[ "$install_method" == "Dualboot" ]] && [[ ! "$toolkit_mode" =~ "wsl" ]] ; then
    # detect grub and offer to add a menu entry for brunch to the user's system
    # This section is still incomplete
      bento -n -c "Brunch IMG created!" "See the messages above to finish the installation manually before continuing." -e
    elif [[ ! "$toolkit_mode" =~ "IMG" ]] ; then
      bento -c "Brunch IMG created!" -e
    else
      bento -c "Brunch install complete!" -e
    fi
    rm -rf ~/tmp/brunch-workspace/*
    main_menu_startup
}

#</>

#<~> Bootscripts

bootscript_menu(){
    curdir=$(pwd)
    cd /var/brunch/bootscripts
    unset bootscript
    unset bootscript_sub
# Use this for menu presentation
bootscript=()
bootscript_sub=()
# Find files and sort by extention
while IFS=  read -r -d $'\0'; do
    if [[ ! "$REPLY" =~ " " ]] ; then
        result_no_prefix="${REPLY:2}"
        if [[ "${REPLY: -3}" == ".sh" ]] ; then
            result_no_suffix="${result_no_prefix%".sh"}"
            bootscript+=("◆ $result_no_suffix")
            bootscript_sub+=("Disable $result_no_suffix")
        elif [[ "${REPLY: -4}" == ".off" ]] ; then
            result_no_suffix="${result_no_prefix%".off"}"
            bootscript+=("◯ $result_no_suffix")
            bootscript_sub+=("Enable $result_no_suffix")
        fi
    fi
done < <(find . -name "*" -print0)
if [[ -n "${bootscript[@]}" ]] ; then
    bootscript+=("div")
    bootscript_sub+=("div")
    bootscript+=("Remove Bootscript")
    bootscript_sub+=("Uninstall script file")
        bootscript+=("Edit Bootscript")
        bootscript_sub+=("Edit script file in $EDITOR")
fi
    bootscript+=("Install Bootscript")
    bootscript_sub+=("Install script file")

cd "$curdir"
    bento -t "Bootscript Menu" -c "Add, remove and toggle bootscripts." -m "${bootscript[@]}" "Back" "Exit" -s "${bootscript_sub[@]}" "Go back to the previous menu" "Exit the toolkit" -x
case "$selection" in
        "Exit") exit 0 ;;
        "Back") main_menu_startup ;;
        "Install Bootscript") install_bootscript ; bootscript_menu ; return ;;
        "Remove Bootscript") remove_bootscript ; bootscript_menu ; return ;;
        "Edit Bootscript") edit_bootscript ; bootscript_menu ; return ;;
        *) toggle_bootscript ; bootscript_menu ; return ;;
esac
}

edit_bootscript(){
    curdir=$(pwd)
    cd /var/brunch/bootscripts
    unset bootscript
    unset bootscript_sub
    # Use this for menu presentation
    bootscript=()
    bootscript_sub=()
# Find files
    while IFS=  read -r -d $'\0'; do
        bootscript_no_prefix="${REPLY:2}"
        if [[ ! "$REPLY" =~ " " ]] ; then
            if [[ "$REPLY" =~ .*\.(sh|off) ]] ; then
                bootscript+=("$bootscript_no_prefix")
                bootscript_sub+=("Remove $bootscript_no_prefix")
            fi
        fi
    done < <(find . -name "*" -print0)
    cd "$curdir"
        if [[ -z "${bootscript[@]}" ]] ; then
            bootscript_menu
        fi
    bento -t "Bootscript Menu" -c "Select a bootscript to edit with $EDITOR" -m "${bootscript[@]}" "Back" "Exit" -s "${bootscript_sub[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    case "$selection" in
            "Exit") exit 0 ;;
            "Back") bootscript_menu ;;
            *) edit_bootscript_sub ; edit_bootscript ; return ;;
    esac
}

edit_bootscript_sub(){
    sudo "$EDITOR" /var/brunch/bootscripts/"$selection"
}

remove_bootscript(){
        curdir=$(pwd)
        cd /var/brunch/bootscripts
        unset bootscript
        unset bootscript_sub
    # Use this for menu presentation
    bootscript=()
    bootscript_sub=()
    # Find files
    while IFS=  read -r -d $'\0'; do
        bootscript_no_prefix="${REPLY:2}"
        if [[ ! "$REPLY" =~ " " ]] ; then
            if [[ "$REPLY" =~ .*\.(sh|off) ]] ; then
                bootscript+=("$bootscript_no_prefix")
                bootscript_sub+=("Remove $bootscript_no_prefix")
            fi
        fi
    done < <(find . -name "*" -print0)
    cd "$curdir"

    if [[ -z "${bootscript[@]}" ]] ; then
        bootscript_menu
    fi
    bento -t "Bootscript Menu" -c "Select a bootscript to remove" "It will be deleted, this cannot be undone." -m "${bootscript[@]}" "Back" "Exit" -s "${bootscript_sub[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    case "$selection" in
            "Exit") exit 0 ;;
            "Back") bootscript_menu ;;
            *) remove_bootscript_sub ; remove_bootscript ; return ;;
    esac
}

remove_bootscript_sub(){
    rm /var/brunch/bootscripts/"$selection"
}

install_bootscript(){
    if [[ "$rerun" == "true" ]] ; then
        ins_boot_box="Select another script to be added as a bootscript."
    else
        ins_boot_box="Select a script, a copy will be added as a bootscript."
    fi
    curdir=$(pwd)
    cd "$downloads"
    unset found_scripts
    unset found_scripts_subs
    found_scripts=()
    # Find files and sort by extention
    while IFS=  read -r -d $'\0'; do
        if [[ ! "$REPLY" =~ " " ]] ; then
            found_scripts+=("${REPLY:2}")
            found_scripts_subs+=("Add ${REPLY:2} to bootscripts")
        fi
    done < <(find . -name "*.sh" -print0)
    cd "$curdir"
    bento -t "Bootscript Menu" -c "$ins_boot_box" -a -m "${found_scripts[@]}" "Back" "Exit" -s "${found_scripts_subs[@]}" "Go back to the previous menu" "Exit the toolkit"

case "$selection" in
        "Exit") exit 0 ;;
        "Back") rerun="false" ; main_menu_startup ;;
        *) install_bootscript_sub ; bootscript_menu ; return ;;
esac
}

install_bootscript_sub(){
    cp "$downloads"/"$selection" /var/brunch/bootscripts/"$selection"
    rerun="true"
}

toggle_bootscript(){
    if [[ "$selection" =~ "◆" ]] ; then
        selection="${selection:4}"
        mv /var/brunch/bootscripts/"$selection".sh /var/brunch/bootscripts/"$selection".off
    elif  [[ "$selection" =~ "◯" ]] ; then
        selection="${selection:4}"
        mv /var/brunch/bootscripts/"$selection".off /var/brunch/bootscripts/"$selection".sh
    fi
}

#</>

#<~> Brioche Menu

brioche_menu(){
    unset brioche_opts
    unset brioche_subs
    toolchain_installed=$(command -v start-toolchain 2>&1)
    brioche_installed=$(command -v brioche 2>&1)
    if [[ -n "$toolchain_installed" ]] ; then
        brioche_opts+=("Update Toolchain")
        tc_ui="update"
        brioche_subs+=("${tc_ui^} the Brunch Toolchain")
    else
        brioche_opts+=("Install Toolchain")
        tc_ui="install"
        brioche_subs+=("${tc_ui^} the Brunch Toolchain")
    fi

    if [[ -n "$toolchain_installed" ]] && [[ -n "$brioche_installed" ]] && [[ "$onlineallowed" == "true" ]] ; then
        brioche_opts+=("Update Brioche")
        br_ui="update"
        brioche_subs+=("${br_ui^} Brioche")
    elif [[ "$onlineallowed" == "true" ]] ; then
        brioche_opts+=("Install Brioche")
        br_ui="install"
        brioche_subs+=("${br_ui^} Brioche")
    fi
    bento -t "Brioche Options" -c "Install and manage Brioche and the Brunch Toolchain." "(More options to be added to this menu later)" -m "${brioche_opts[@]}" "Back" "Exit" -s "${brioche_subs[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    case "$selection" in
        "Exit") exit 0 ;;
        "Back") $previous_menu ;;
        "Install Toolchain") install_toolchain ; brioche_menu ; return ;;
        "Install Brioche") install_brioche ; brioche_menu ; return ;;
        # For now, updating is the same as installing
        "Update Toolchain") install_toolchain ; brioche_menu ; return ;;
        "Update Brioche") install_brioche ; brioche_menu ; return ;;
    esac
}

#</>

#<~> Brioche functions

install_brioche(){
    if [[ "$onlineallowed" == "true" ]] ; then
    mkdir -p ~/tmp/brunch-workspace
    bento -t "${br_ui^} Brioche" -c "Downloading Brioche, please wait..."
    curl -l https://raw.githubusercontent.com/sebanc/brioche/main/brioche -o ~/tmp/brunch-workspace/brioche
    install -Dt /usr/local/bin -m 755 ~/tmp/brunch-workspace/brioche
    bento -t "${br_ui^} Brioche" -c "Brioche has been ${br_ui^}ed." -e
    else
        bento -t "${br_ui^} Brioche" -c "Currently unable to download the latest release of Brioche." -e
    fi
}


#</>

#<~> Toolchain functions
install_toolchain(){
    bento -t "${tc_ui^} Toolchain" -c "This will erase anything in /usr/local and take approximately 2GB of space." "If you previously had Chromebrew or the Brunch Toolchain installed, it will be removed and replaced."
    bento -n -g -c "Do you wish to continue?" -m "Yes" "No" "Exit" -s "Continue" "Go back to the previous menu" "Exit without ${tc_ui}ing"
    case "$selection" in
            "Exit") exit 0 ;;
            "No") brioche_menu ;;
            "Yes") install_toolchain_sub ;;
    esac
}

install_toolchain_adv(){
    bento -t "${tc_ui^} Toolchain" -c "This will erase anything in /usr/local and take approximately 2GB of space." "If you previously had Chromebrew or the Brunch Toolchain installed, it will be removed and replaced."
    bento -n -g -c "Do you wish to continue?" -m "Yes" "No" "Exit" -s "Continue" "Go back to the previous menu" "Exit without ${tc_ui}ing"
    case "$selection" in
            "Exit") exit 0 ;;
            "No") advanced_options_menu ;;
            "Yes") advanced_install_toolchain ;;
    esac
}

install_toolchain_sub(){
    if [[ "$onlineallowed" == "true" ]] ; then
        automatic_install_toolchain
    else
        bento -t "${tc_ui^} Toolchain" -c "Unable to $tc_ui automatically, trying advanced $tc_ui option." -e
        advanced_install_toolchain
    fi
}

automatic_install_toolchain(){
    sudo rm -r /usr/local/*
    sudo chown -R 1000:1000 /usr/local
    mkdir -p ~/tmp/brunch-workspace
    curdir=$(pwd)
    cd ~/tmp/brunch-workspace
    bento -t "${tc_ui^} Toolchain" -c "Downloading the latest Brunch Toolchain, please wait..."
    curl -L -O --progress-bar "$(curl -s https://api.github.com/repos/sebanc/brunch-toolchain/releases/latest | grep 'browser_' | cut -d\" -f4)"
    updatefile="$(find *runch*toolchain*tar.gz 2> /dev/null | sort -r | head -1 )"
    bento -t "${tc_ui^} Toolchain" -c "Now ${tc_ui^}ing Brunch Toolchain, please wait..."
    tar zxf ~/tmp/brunch-workspace/"$updatefile" -C /usr/local
    echo "source /usr/local/bin/start-toolchain" >> ~/.bashrc
    cd "$curdir"
    bento -t "${tc_ui^} Toolchain" -c "${tc_ui^} complete" "Please exit and reopen the terminal to see changes." -e
}

advanced_install_toolchain(){
    curdir=$(pwd)
    cd "$downloads"
    unset toolchain_files
    toolchain_files=()
    while IFS=  read -r -d $'\0'; do
        if [[ ! "$REPLY" =~ " " ]] ; then
            toolchain_files+=("${REPLY:2}")
        fi
    done < <(find . -name "*runch_t*.tar.gz" -print0)

        if [[ -n "$toolchain_files" ]] ; then
        bento -t "${tc_ui^} Toolchain" -c "Please select a Brunch Toolchain archive to $tc_ui with." -m "${toolchain_files[@]}" "Back" "Exit" -s "${toolchain_files[@]}" "Go back to the previous menu" "Exit without updating." -a
        case "$selection" in
            "Back") cd "$curdir" ; brioche_menu ;;
            "Exit") exit 0 ;;
            *) updatefile="$selection" ;;
        esac
        sudo rm -r /usr/local/*
        sudo chown -R 1000:1000 /usr/local
        tar zxf "$downloads/$updatefile" -C /usr/local
        echo "source /usr/local/bin/start-toolchain" >> ~/.bashrc
        cd "$curdir"
        bento -t "${tc_ui^} Toolchain" -c "${tc_ui^} complete" "Please exit and reopen the terminal to see changes." -e
    else

        cd "$curdir"
        bento -t "${tc_ui^} Toolchain" -c "Unable to find Brunch Toolchain tar.gz archives in $downloads" "You can manually download the latest release from github here:" "https://github.com/sebanc/brunch-toolchain/releases" div "Be sure to keep the default filename and extention, and make sure there are no spaces in the filename." -r
    fi

}

#</>

#<~> Update Toolkit
    update_brunch_toolkit(){
        if [[ "$onlineallowed" == "true" ]] ; then
        mkdir -p ~/tmp/brunch-workspace
        bento -t "Update Toolkit" -c "Downloading the latest Brunch Toolkit, please wait..."
    curl -l https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/brunch-toolkit -o ~/tmp/brunch-workspace/brunch-toolkit
    sudo install -Dt /usr/local/bin -m 755 ~/tmp/brunch-workspace/brunch-toolkit
        bento -t "Update Toolkit" -c "Update complete" "Exit and reopen the Toolkit to see changes." -e
        else
            bento -t "Update Toolkit" -c "Currently unable to download the latest Toolkit." -e
        fi
    }
#</>

#<~> Update Brunch
update_brunch(){
    if [[ "$onlineallowed" == "true" ]] ; then
        automatic_brunch_update
    else
        bento -t "Update Brunch" -c "Unable to update automatically, trying advanced update option." -e
        advanced_brunch_update
    fi
}

advanced_brunch_update(){
    curdir=$(pwd)
    cd "$downloads"
    #brunch_files=($(find *runch*.tar.gz 2> /dev/null | sort -r))
    unset brunch_files
brunch_files=()
while IFS=  read -r -d $'\0'; do
    if [[ ! "$REPLY" =~ " " ]] ; then
        brunch_files+=("${REPLY:2}")
    fi
done < <(find . -name "*runch_r*.tar.gz" -print0)

    if [[ -n "$brunch_files" ]] ; then
    bento -t "Update Brunch" -c "Please select a Brunch archive to update with." -m "${brunch_files[@]}" "Back" "Exit" -s "${brunch_files[@]}" "Go back to the previous menu" "Exit without updating." -a
    case "$selection" in
        "Back") cd "$curdir" ;"$previous_menu" ; return ;;
        "Exit") exit 0 ;;
        *) updatefile="$selection" ;;
    esac
    bento -t "Update Brunch" -c "Now applying Brunch update, please wait..."
    # Call built in update command
        sudo chromeos-update -f "$downloads/$updatefile"
        cd "$curdir"
        # clean up
        sed -i "s/current_brunch_version=.*/current_brunch_version=$latest_brunch_version/" "$config_file"
        source "$config_file" 2> /dev/null
        update_complete="true"
        bento -t "Update Brunch" -c "Update complete" "Please reboot to see changes." -e
    else

        cd "$curdir"
        bento -t "Update Brunch" -c "Unable to find Brunch tar.gz archives in $downloads" "You can manually download the latest release from github here:" "https://github.com/sebanc/brunch/releases" div "Be sure to keep the default filename and extention, and make sure there are no spaces in the filename." -r
    fi
}

automatic_brunch_update(){
    # Make a working directory to keep toolkit out of sight
        mkdir -p ~/tmp/brunch-workspace
        curdir=$(pwd)
        cd ~/tmp/brunch-workspace
        bento -t "Update Brunch" -c "Downloading the latest Brunch update, please wait..."
        curl -L -O --progress-bar "$(curl -s https://api.github.com/repos/sebanc/brunch/releases/latest | grep 'browser_' | cut -d\" -f4)"
        updatefile="$(find *runch*tar.gz 2> /dev/null | sort -r | head -1 )"
    # Call built in update command
        bento -t "Update Brunch" -c "Now applying Brunch update, please wait..."
        sudo chromeos-update -f ~/tmp/brunch-workspace/"$updatefile"
        cd "$curdir"
    # clean up
        rm -rf ~/tmp/brunch-workspace/*
        sed -i "s/current_brunch_version=.*/current_brunch_version=$latest_brunch_version/" "$config_file"
        source "$config_file" 2> /dev/null
        update_complete="true"
        bento -t "Update Brunch" -c "Update complete" "Please reboot to see changes." -e
}

#</>

#<~> Updates and Notifications

check_for_updates(){
    if [[ "$onlineallowed" == true ]] && [[ ! "$autocheck" == "disabled" ]] || [[ "$force_update" == "true" ]] ; then
        bento -t "Network Check" -c "Checking for updates, please wait..."
      # Online calls - try to minimize calls
      # Look for announcements
        curl -s -l https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/announcement -o /var/brunch/toolkit/annoucement 2> /dev/null
        source /var/brunch/toolkit/annoucement 2> /dev/null
        if [[ "$announcement_ver" == "0" ]] ; then
            bento -n -cla -c "No Announcements"
        elif [[ -n "$announcement_ver" ]] ; then
            bento -n -cla -c "Found Announcement: $announcement_ver"
        fi
        if [[ "$toolkit_mode" =~ "brunch" ]] ; then
      # check for brunch releases
        latestbrunch=$(curl -s "https://api.github.com/repos/sebanc/brunch/releases/latest" | grep 'name' | cut -d\" -f4 | grep 'tar.gz' )
        # Strip all of the unnecessary bits off, integers only
        lbv1=${latestbrunch/unstable_}
        lbv2=${lbv1/stable_}
        lbv3=${lbv2/testing_}
        latestbrunchversion=$(echo "$lbv3" | cut -d'_' -f3 | cut -d'.' -f1)
        bento -n -cla -c "Found Brunch Version: $latestbrunchversion"


        if [[ "$get_unstable_updates" == "true" ]]; then
            latestbrunchunstable=$(curl -s "https://api.github.com/repos/sebanc/brunch-unstable/releases/latest" | grep 'name' | cut -d\" -f4 | grep 'tar.gz')
            # Strip all of the unnecessary bits off, integers only
            lbuv1=${latestbrunchunstable/unstable_}
            lbuv2=${lbuv1/stable_}
            lbuv3=${lbuv2/testing_}
            latestbrunchunstableversion=$(echo "$lbuv3" | cut -d'_' -f3 | cut -d'.' -f1)
            bento -n -cla -c "Found Brunch Unstable Version: $latestbrunchunstableversion"
        fi


    # get the latest ChromeOS release from cros.tech
        cros_url=$(curl -s https://cros.tech/device/$selected_recovery | tr ' ' '\n' | tr '>' '\n' | grep href= | sed 's/"//g' | sed 's/href=//g' | tail -1)
        #cros_release=$(curl https://cros.tech/device/$RECOVERYTODOWNLOAD | tr ' ' '\n' | tr '>' '\n' | sed 's/"//g' | sed 's/href=//g' | grep '</span' | sed 's/<\/span//g' | tail -1)
        cros_release=$(echo "$cros_url" | cut -d'_' -f2)
        bento -n -cla -c "Found ${selected_recovery^} Version: $cros_release"
        fi

        # Do this one last to measure github's api limit in a later script
        #latesttoolkit=$(curl -s https://api.github.com/repos/WesBosch/brunch-toolkit/releases/latest | grep 'name' | cut -d\" -f4 | grep '.sh' | cut -d'-' -f3 | sed -e s/.sh// )
        latesttoolkiturl=$(curl -s https://api.github.com/repos/WesBosch/brunch-toolkit/releases/latest  | grep 'browser_' | cut -d\" -f4 | grep '.sh')
        latesttoolkit=$(echo "$latesttoolkiturl" | cut -d'v' -f3 | sed 's/.sh//')
        latestsemversion=$(echo "$latesttoolkit" | sed -e "s/^v//" -e "s/b$//")
        bento -n -cla -c "Found Brunch Toolkit Version: $latestsemversion"
        # put a sleep delay here for aesthetic reasons Only
        sleep 1
    # store latest update versions until next check.
    # This lets us continue to notify for updates even without checking each time
        if [[ -n "$latesttoolkit" ]] ; then
            if [[ "$toolkit_mode" =~ "brunch" ]] ; then
            sed -i "s/latest_brunch_version=.*/latest_brunch_version=$latestbrunchversion/" "$config_file"
            sed -i "s/latest_brunch_unstable_version=.*/latest_brunch_unstable_version=$latestbrunchunstableversion/" "$config_file"
            sed -i "s/latest_chromeos_version=.*/latest_chromeos_version=$cros_release/" "$config_file"
            fi
            sed -i "s/latest_toolkit_version=.*/latest_toolkit_version=$latestsemversion/" "$config_file"
        fi
    fi

    # This one doesnt require a network connection and should always run to keep the config file updated
    currentsemversion=$(echo "$toolkitversion" | sed -e "s/^v//" -e "s/b$//")
    sed -i "s/current_toolkit_version=.*/current_toolkit_version=$currentsemversion/" "$config_file"
    source "$config_file" 2> /dev/null


 # Check if toolkit is outdated, strip down to numbers for versioning
    csvint1=$(echo "$current_toolkit_version" | cut -d'.' -f1)
    csvint2=$(echo "$current_toolkit_version" | cut -d'.' -f2)
    csvint3=$(echo "$current_toolkit_version" | cut -d'.' -f3)
    lsvint1=$(echo "$latest_toolkit_version" | cut -d'.' -f1)
    lsvint2=$(echo "$latest_toolkit_version" | cut -d'.' -f2)
    lsvint3=$(echo "$latest_toolkit_version" | cut -d'.' -f3)
    toolkit_update="false"
   if [ -z "$latest_toolkit_version" ] ; then
   :
   elif (( "$csvint1" < "$lsvint1" )) ; then
     toolkit_update="true"
   elif [ "$csvint1" == "$lsvint1" ] && (( "$csvint2" < "$lsvint2" )) ; then
     toolkit_update="true"
   elif [ "$csvint1" == "$lsvint1" ] && [ "$csvint2" == "$lsvint2" ] && (( "$csvint3" < "$lsvint3" )) ; then
     toolkit_update="true"
   else
     toolkit_update="false" # Toolkit version is greater or equal in all aspects, don't notify
   fi

if [[ "$toolkit_mode" =~ "brunch" ]] ; then
# Check if Brunch is outdated
   if [ -z "$latest_brunch_version" ] ; then
       stable_update="false"
   elif (( "$current_brunch_version" < "$latest_brunch_version" )) ; then
       stable_update="true"
   else
    stable_update="false"

   fi
   if [ -z "$latest_brunch_unstable_version" ] ; then
       unstable_update="false"
   elif (( "$current_brunch_version" < "$latest_brunch_unstable_version" )) ; then
       unstable_update="true"
   else
       unstable_update="true"
   fi

   # check if ChromeOS is outdated

 # Check if toolkit is outdated, strip down to numbers for versioning
    ccvint1=$(echo "$current_chromeos_version" | cut -d'.' -f1)
    ccvint2=$(echo "$current_chromeos_version" | cut -d'.' -f2)
    ccvint3=$(echo "$current_chromeos_version" | cut -d'.' -f3)
    lcvint1=$(echo "$latest_chromeos_version" | cut -d'.' -f1)
    lcvint2=$(echo "$latest_chromeos_version" | cut -d'.' -f2)
    lcvint3=$(echo "$latest_chromeos_version" | cut -d'.' -f3)
    chromeos_update="false"
   if [ -z "$latest_chromeos_version" ] ; then
   :
elif (( "$ccvint1" < "$lcvint1" )) ; then
     chromeos_update="true"
 elif [ "$ccvint1" == "$lcvint1" ] && (( "$ccvint2" < "$lcvint2" )) ; then
     chromeos_update="true"
 elif [ "$ccvint1" == "$lcvint1" ] && [ "$ccvint2" == "$lcvint2" ] && (( "$ccvint3" < "$lcvint3" )) ; then
     chromeos_update="true"
   else
     chromeos_update="false" # ChromeOS version is greater or equal in all aspects, don't notify
   fi

fi
sed -i "s/stable_update=.*/stable_update=$stable_update/" "$config_file"
sed -i "s/unstable_update=.*/unstable_update=$unstable_update/" "$config_file"
sed -i "s/chromeos_update=.*/chromeos_update=$chromeos_update/" "$config_file"
sed -i "s/toolkit_update=.*/toolkit_update=$toolkit_update/" "$config_file"
source "$config_file" 2> /dev/null

# Check if github's API limit has been reached or if Github is down
   if [[ $onlineallowed == true ]] && [[ -z "$latesttoolkit" ]] && [[ ! "$autocheck" == "disabled" ]] ||  [[ "$force_update" == "true" ]] && [[ -z "$latesttoolkit" ]] ; then
   bento -t "Network Check" -c "The toolkit is online, but the Github API limit has been reached." "Please wait a little while before trying again." -e
   onlineallowed="false"
   fi


   force_update="false"
}

check_for_notifications(){
    unset notify_content

    if [[ "$onlineallowed" == "false" ]] ; then
    notify_content+=("Currently Offline!")
    fi
    if [[ "$toolkit_update" == "true" ]] ; then
    notify_content+=("Brunch Toolkit update avaliable!")
    fi

    if [[ "$toolkit_mode" =~ "brunch" ]] ; then
    if [[ "$stable_update" == "true" ]] ; then
    notify_content+=("Brunch Stable update avaliable!")
    fi
    if [[ "$chromeos_update" == "true" ]] ; then
    notify_content+=("ChromeOS update avaliable!")
    fi
    if [[ "$unstable_update" == "true" ]] && [[ "$get_unstable_updates" == "true" ]]; then
    notify_content+=("Brunch Unstable update avaliable!")
    fi
    fi
}

#</>

#<~> Compatibility Check/Report

compatibility_report(){
    d1="$(sudo dmidecode -s system-version)"
    d2="$(sudo dmidecode -s system-manufacturer)"
    d3="$(sudo dmidecode -s system-family)"
    d4="$(sudo dmidecode -s system-product-name)"
    model1="$d1"
    model2="$d2 $d3"
    model3="$d2 $d4"
    cpu="$(awk -F '\\s*: | @' \
    	'/model name|Hardware|Processor|^cpu model|chip type|^cpu type/ {
    	cpu=$2; if ($1 == "Hardware") exit } END { print cpu }' "/proc/cpuinfo")"
    echo "< RAM information"
    IFS=":" read -r a b < /proc/meminfo
    ram="${b/kB}"
    ram="$((ram/1024)) MB"
    rootdev="$(rootdev -d)"
    storage_prepare="$(< /sys/block/${rootdev##*/}/queue/rotational)"
    	case "$storage_prepare" in
    		1) storage_type="(HDD)" ;;
    		0) storage_type="(SSD)" ;;
    		*) storage_type="" ;;
    	esac
    storage="$(sudo lsblk -b -n -d -o SIZE $rootdev)"
    storage="$((storage/1024/1024/1024)) GB"
    if [[ "$rootdev" =~ .*"loop".* ]]; then
    	dualboot=1
    	if [ -n "$storage_type" ]; then
    		storage_model="(on ${storage_type//[()]/})"
    		storage="Image file ${storage_model}: $storage"
    	else
    		storage="Image file: $storage"
    	fi
    else
    	dualboot=0
    	storage_model="$(sudo lsblk -b -n -d -o MODEL $rootdev)"
    	if [ -z "$storage_model" ]; then
    		storage_model="Unknown drive ${storage_type} $storage"
    	fi
    	storage="$storage_model $storage"
    fi
    brunch="$(< /etc/brunch_version)"
    lsb_file="$(< /etc/lsb-release)"
    board="$(grep -o "^CHROMEOS_RELEASE_DESCRIPTION=.*" <<<"$lsb_file" | rev | cut -d " " -f 1,2 | rev)"
    board=$board
    board="${board% *}"
    version="$(grep -o "^CHROMEOS_RELEASE_CHROME_MILESTONE=.*" <<<"$lsb_file")"
    version="${version##*=}"
    build="$(grep -o "^CHROMEOS_RELEASE_VERSION=.*" <<<"$lsb_file")"
    build="${build##*=}"
    echo "< Linux information"
    hasorhasnot="$(vmc list)"
    if [[ "$hasorhasnot" =~ "termina".* ]]; then
    	linux_installed=1
    else
    	linux_installed=0
    fi
    menuopts=("Yes" "No" "Not Avaliable" "Back" "Exit")
    menuopts_model=("$model1" "$model2" "$model3" "None of these" "Back" "Exit")
    menuopts_model_sub=("Yes" "No" "Back" "Exit")
    page-android
}


page-android(){
        # navigation variables
        selection=
        previous=
        next="page-linux"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Android" -c "Does the Android Subsystem (Android apps) run?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) android="$selection" ; "$next" ;;
        esac
}

page-linux(){
        #Auto-detect linux if possible
        if [[ "$linux_installed" == 1 ]] ; then
		    linux="Yes"
		    linux_install="Yes"
            skipped="true"
            page-linux_run
        else
        # navigation variables
        selection=
        previous="page-android"
        next="page-linux_install"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Linux" -c "Is Linux container install option available?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) linux="$selection" ; "$next" ;;
        esac
        fi
}

page-linux_install(){
        # navigation variables
        selection=
        previous="page-linux"
        next="page-linux_run"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Linux" -c "Does the Linux container install?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) linux_install="$selection" ; "$next" ;;
        esac
}

page-linux_run(){
        # navigation variables
        selection=
        if [[ "$skipped" == true ]] ; then
            previous="page-android"
            skipped="false"
        else
            previous="page-linux_install"
        fi
        next="page-bluetooth"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Linux" -c "Does the Linux container run?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) linux_run="$selection" ; "$next" ;;
        esac
}

page-bluetooth(){
        # navigation variables
        selection=
        previous="page-linux_run"
        next="page-wifi"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Networking" -c "Is Bluetooth working?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) bluetooth="$selection" ; "$next" ;;
        esac
}

page-wifi(){
        # navigation variables
        selection=
        previous="page-bluetooth"
        next="page-camera"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Networking" -c "Is WiFi working?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) wifi="$selection" ; "$next" ;;
        esac
}

page-camera(){
        # navigation variables
        selection=
        previous="page-wifi"
        next="page-microphone"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Hardware" -c "Is the camera working?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) camera="$selection" ; "$next" ;;
        esac
}

page-microphone(){
        # navigation variables
        selection=
        previous="page-camera"
        next="page-touchscreen"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Hardware" -c "Is the microphone working?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) microphone="$selection" ; "$next" ;;
        esac
}

page-touchscreen(){
        # navigation variables
        selection=
        previous="page-microphone"
        next="page-trackpad"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Hardware" -c "Does the touchscreen work?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) touchscreen="$selection" ; "$next" ;;
        esac
}

page-trackpad(){
        # navigation variables
        selection=
        previous="page-touchscreen"
        next="page-model"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Hardware" -c "Does trackpad and gestures work?" -m "${menuopts[@]}" -a
        case "$selection" in
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) trackpad="$selection" ; "$next" ;;
        esac
}

page-model(){
        # navigation variables
        selection=
        previous="page-trackpad"
        next="page-results"
        # clear the screen and make a nice textbox"Does trackpad and gestures work?"
        bento -t "Compatibility Report - Model" -c "Which of the options best describes the model of your device?" -m "${menuopts_model[@]}" -a
        case "$selection" in
            "None of these") page-model_sub ;;
            "Back") $previous ;;
            "Exit") exit 0 ;;
            *) model="$selection" ; "$next" ;;
        esac
}

page-model_sub(){
        # navigation variables
        modelnumber=
        selection=
        previous_menu="page-model"
        next="page-results"
        # clear the screen and make a nice textbox
        bento -t "Compatibility Report - Model" -c "Enter the model of your device in your own way." -w
        case "$selection" in
            "Back") $previous_menu ;;
            "Exit") exit 0 ;;
            *) model="$selection" ; "$next" ;;
        esac
}

page-results(){
    clear
    echo "------------------------------"
    cat <<EOF | tee "$HOME"/MyFiles/Downloads/brunch-hwcomp.log.txt
$model
CPU: $cpu
RAM: $ram
Storage: $storage
Brunch: $brunch
Recovery: $board $version (build $build)
- Does the Android Subsystem (Android apps) run?
[$android]
- Is Linux container install option available?
[$linux]
- Does Linux container install?
[$linux_install]
- Does Linux terminal run?
[$linux_run]
- Is Bluetooth working?
[$bluetooth]
- Is WiFi working?
[$wifi]
- Is the camera working?
[$camera]
- Is microphone working?
[$microphone]
- Does the touchscreen work?
[$touchscreen]
- Does trackpad and gestures work?
[$trackpad]
EOF
    sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" -i "$HOME"/MyFiles/Downloads/brunch-hwcomp.log.txt
    echo ''
    echo "(Log saved to Downloads folder)"
    comp_repo_results=(
    "$model"
    "CPU: $cpu"
    "RAM: $ram"
    "Storage: $storage"
    "Brunch: $brunch"
    "Recovery: $board $version (build $build)"
    "div"
    "Does the Android Subsystem (Android apps) run?"
    "[$android]"
    "Is Linux container install option available?"
    "[$linux]"
    "Does Linux container install?"
    "[$linux_install]"
    "Does Linux terminal run?"
    "[$linux_run]"
    "Is Bluetooth working?"
    "[$bluetooth]"
    "Is WiFi working?"
    "[$wifi]"
    "Is the camera working?"
    "[$camera]"
    "Is microphone working?"
    "[$microphone]"
    "Does the touchscreen work?"
    "[$touchscreen]"
    "Does trackpad and gestures work?"
    "[$trackpad]"
    "div"
    "(brunch-hwcomp.log.txt saved to Downloads folder)"
    )
    previous_menu="main_menu_startup"
    bento -t "Compatibility Report - Results" -cla -c "${comp_repo_results[@]}" -r
}



loud_compatibility_check(){
    quiet_compatibility_check
    previous_menu="main_menu_startup"
    if [[ "$detected_recovery" == "unsupported" ]] ; then
        bento -t "Compatibility Check" -c "Your detected cpu is: $cputype" "div" "Your CPU is not recognized or is not compatible." -r
    else
        bento -t "Compatibility Check" -c "Your detected cpu is: $cputype" "div" "Your suggested recovery is $detected_recovery." -r
    fi
}

#</>

#<~> Advanced Options
# Some of these are backup options for other functions (such as when internet is disabled)
# Other options are just better suited for here due to complexity to prevent user error
advanced_options_menu(){
    unset advanced_opts
    unset advanced_subs
    if [[ -z "$brunch_editor" ]] ; then
        brunch_editor="nano"
    fi

    if [[ "$toolkit_mode" =~ "brunch" ]] ; then
        advanced_opts+=("Update Brunch from file")
        advanced_subs+=("Select a Brunch archive to update with")
        advanced_opts+=("Install/Update Toolchain from file")
        advanced_subs+=("Select a Brunch Toolchain archive to install/update with")
        advanced_opts+=("Edit Grub Manually")
        advanced_subs+=("Open Brunch's Grub config in $brunch_editor")
    else
        advanced_opts+=("Force Install Dependencies")
        advanced_subs+=("Install dependencies for Linux/Arch")
    fi
        advanced_opts+=("Edit Toolkit Config Manually")
        advanced_subs+=("Open the Brunch Toolkit's config in $brunch_editor")
        advanced_opts+=("Erase Toolkit Config")
        advanced_subs+=("Completely erases the Brunch Toolkit's config file")
        advanced_opts+=("Change editor (Currently $brunch_editor)")
        advanced_subs+=("Toggle which editor you'd like to use")

    bento -t "Advanced Options" -c "Proceed with caution" -m "${advanced_opts[@]}" "Back" "Exit" -s "${advanced_subs[@]}" "Go back to the previous menu" "Exit the toolkit" -a
    case "$selection" in
        "Back")   main_menu_startup ; return ;;
        "Exit")   exit 0 ;;
        "Edit Toolkit Config Manually") edit_config ; advanced_options_menu ; return ;;
        "Edit Grub Manually") edit_grub_config ; advanced_options_menu ; return ;;
        "Erase Toolkit Config") erase_toolkit_config ; advanced_options_menu ; return ;;
        "Force Install Dependencies") dependency_search ; advanced_options_menu ; return ;;
        "Update Brunch from file") advanced_brunch_update ; advanced_options_menu ; return ;;
        "Install/Update Toolchain from file") install_toolchain_adv ; advanced_options_menu ; return ;;
        "Change editor (Currently $brunch_editor)")
                                                if [[ "$brunch_editor" == "nano" ]] ; then
                                                    brunch_editor="vi"
                                                else
                                                    brunch_editor="nano"
                                                fi
                                                sed -i "s/brunch_editor=.*/brunch_editor=$brunch_editor/" "$config_file"
                                                advanced_options_menu ; return ;;
    esac
}

#</>

#<~> Toolkit Settings
toolkit_settings_menu(){
    command -v bento >/dev/null 2>&1 && bento_installed="true" || bento_installed="false"
    previous_menu="main_menu_startup"
    source "$config_file" 2> /dev/null

        if [[ "$first_time_init" == "disabled" ]] ; then
            bs_ft="◯ First Time Init"
        elif [[ "$first_time_init" == "enabled" ]] ; then
            bs_ft="◆ First Time Init"
        else
            bs_ft="? First Time Init"
        fi

        if [[ "$startup_anim" == "disabled" ]] ; then
            bs_sa="◯ Startup Animation"
        elif [[ "$startup_anim" == "enabled" ]] ; then
            bs_sa="◆ Startup Animation"
        else
            bs_sa="? Startup Animatio"
        fi

        if [[ "$bento_boxes" == "disabled" ]] ; then
            bs_bb="◯ Bento"
        elif [[ "$bento_boxes" == "enabled" ]] ; then
            bs_bb="◆ Bento"
        else
            bs_bb="? Bento"
        fi

        if [[ "$tooltips" == "disabled" ]] ; then
            bs_tt="◯ Tooltips"
        elif [[ "$tooltips" == "enabled" ]] ; then
            bs_tt="◆ Tooltips"
        else
            bs_tt="? Tooltips"
        fi

        if [[ "$autocheck" == "disabled" ]] ; then
            bs_au="◯ Autocheck for Updates"
        elif [[ "$autocheck" == "enabled" ]] ; then
            bs_au="◆ Autocheck for Updates"
        else
            bs_au="? Autocheck for Updates"
        fi

        if [[ "$get_unstable_updates" == "false" ]] ; then
            bs_uu="◯ Check Unstable Updates"
        elif [[ "$get_unstable_updates" == "true" ]] ; then
            bs_uu="◆ Check Unstable Updates"
        else
            bs_uu="? Check Unstable Updates"
        fi


        if [[ "$advanced_options" == "disabled" ]] ; then
            bs_ao="◯ Advanced Options Menu"
        elif [[ "$advanced_options" == "enabled" ]] ; then
            bs_ao="◆ Advanced Options Menu"
        else
            bs_ao="? Advanced Options Menu"
        fi

            bs_sr="Selected Recovery:    ${selected_recovery^}"
            bs_tm="Toolkit Mode:         ${toolkit_mode^}"


        if [[ "$scaling" == "fit" ]] ; then
            scaling_tip="Fits the image to the canvas as well as it can. Quality may be lost at the risk of fitting the canvas as well as possible."
        elif [[ "$scaling" == "shrink" ]] ; then
            scaling_tip="Shrinks the image and tries to render a background automatically based on the top-left pixel. This is great for turning large images into centered icons"
        else
            scaling="center"
            scaling_tip="Centers the image and tries to render a background automatically based on the top-left pixel. Select this if your image is the right size already to preserve scale."
        fi

        if [[ "$test_convert" == "disabled" ]] ; then
            bs_tc="◯ Preview Image Conversion"
        elif [[ "$test_convert" == "enabled" ]] ; then
            bs_tc="◆ Preview Image Conversion"
        else
            bs_tc="◯ Preview Image Conversion"
        fi

unset toolkit_settings_opts
unset toolkit_settings_subs

toolkit_settings_opts=("Toggle or set settings for the Brunch Toolkit." -m "$bs_ft" "$bs_sa" "$bs_bb" "$bs_tt" "$bs_au" "$bs_uu" "$bs_ao" "$bs_tc" "Image Scaling Method: ${scaling^}" "$bs_sr" "$bs_tm" "Redo First Run" "Install/Update Bento" "Back" "Exit")
toolkit_settings_subs=("Enable/Disable First Time Init" "Enable/Disable Startup Animation" "Enable/Disable Bento" "Enable/Disable Tooltips" "Enable/Disable Autocheck" "Enable/Disable Checking for Unstable Updates" "Enable/Disable Advanced Menu Options" "Creates a test file called results.png in your Downloads when enabled." "$scaling_tip" "Select Recovery" "Select Toolkit Mode" "Replay the first time init to reset your settings" "Get Bento on the go!" "Replay the first time init to reset your settings" "Go back to the previous menu" "Exit the toolkit")

    bento -t "Toolkit Settings" -c "${toolkit_settings_opts[@]}" -s "${toolkit_settings_subs[@]}" -x

    case "$selection" in
        "$bs_ft")
                    if  [[ "$bs_ft" =~ "◯" ]] ; then
                        sed -i "s/first_time_init=.*/first_time_init=enabled/" "$config_file"
                    else
                        sed -i "s/first_time_init=.*/first_time_init=disabled/" "$config_file"
                    fi
                    ;;
        "$bs_sa")
                    if  [[ "$bs_sa" =~ "◯" ]] ; then
                        sed -i "s/startup_anim=.*/startup_anim=enabled/" "$config_file"
                    else
                        sed -i "s/startup_anim=.*/startup_anim=disabled/" "$config_file"
                    fi
                    ;;
        "$bs_bb")
                    if [[ "$bs_bb" =~ "◆" ]] ; then
                        sed -i "s/bento_boxes=.*/bento_boxes=disabled/" "$config_file"
                    else
                        sed -i "s/bento_boxes=.*/bento_boxes=enabled/" "$config_file"
                    fi
                    ;;
        "$bs_tt")
                    if [[ "$bs_tt" =~ "◆" ]] ; then
                        sed -i "s/tooltips=.*/tooltips=disabled/" "$config_file"
                    else
                        sed -i "s/tooltips=.*/tooltips=enabled/" "$config_file"
                    fi
                    ;;
        "$bs_au")
                    if [[ "$bs_au" =~ "◯" ]] ; then
                        sed -i "s/autocheck=.*/autocheck=enabled/" "$config_file"
                    else
                        sed -i "s/autocheck=.*/autocheck=disabled/" "$config_file"
                    fi
                    ;;
        "$bs_ao")
                    if [[ "$bs_ao" =~ "◆" ]] ; then
                        sed -i "s/advanced_options=.*/advanced_options=disabled/" "$config_file"
                    else
                        sed -i "s/advanced_options=.*/advanced_options=enabled/" "$config_file"
                    fi
                    ;;
        "$bs_uu")
                    if [[ "$bs_uu" =~ "◯" ]] ; then
                        sed -i "s/get_unstable_updates=.*/get_unstable_updates=true/" "$config_file"
                    else
                        sed -i "s/get_unstable_updates=.*/get_unstable_updates=false/" "$config_file"
                    fi
                    ;;
        "$bs_sr")
                    previous_menu="toolkit_settings_menu"
                    select_a_recovery
                    sed -i "s/selected_recovery=.*/selected_recovery=$selected_recovery/" "$config_file"
                    ;;
        "$bs_tc")
                    if [[ "$test_convert" == "enabled" ]] ; then
                        test_convert="disabled"
                    else
                        test_convert="enabled"
                    fi
                    ;;
        "Image Scaling Method: ${scaling^}")
                        if [[ "$scaling" == "fit" ]] ; then
                            scaling="shrink"
                        elif [[ "$scaling" == "shrink" ]] ; then
                            scaling="center"
                        else
                            scaling="fit"
                        fi
                            sed -i "s/scaling=.*/scaling=$scaling/" "$config_file"
                        ;;

        "$bs_tm") previous_menu="toolkit_settings_menu" ; select_toolkit_mode ;;
        "Redo First Run") second_run_init ; return ;;
        "Install/Update Bento") install_bento_tk ; return ;;
        "Back")   "$previous_menu" ; return ;;
        "Exit")   exit 0 ;;
    esac

    # loop this menu until the user specifically exits or goes back
    toolkit_settings_menu
}

select_toolkit_mode(){
    previous_menu="toolkit_settings_menu"
    source "$config_file" 2> /dev/null
    toolkit_modes=(
    "brunch"
    "brunch_usb"
    "brunch_dualboot"
    "linux"
    "linux_usb"
    "linux_wsl"
    "arch"
    "arch_usb"
    "arch_wsl"
    )

    unset toolkit_mode_options
    for elem in "${toolkit_modes[@]}" ; do
    if [[ "$elem" == "$toolkit_mode" ]] ; then
        toolkit_mode_options+=("◆ $elem")
    else
        toolkit_mode_options+=("◯ $elem")
    fi
    done

    toolkit_mode_subs=(
    "Brunch (Singleboot)"
    "Brunch (USB)"
    "Brunch (Dualboot)"
    "Ubuntu/Debian/Mint based distro"
    "Ubuntu/Debian/Mint based distro"
    "Ubuntu/Debian/Mint based distro"
    "Arch based distro"
    "Arch based distro"
    "Arch based distro"
    )

    bento -t "Select Toolkit Mode" -c "This setting changes which options are avaliable in the toolkit." "div" "Currently running in $toolkit_mode mode." -m "${toolkit_mode_options[@]}" "Back" "Exit"
    if [[ "$selection" =~ (◆|◯) ]] ; then
        selection=${selection:4}
    fi
    case "$selection" in
        "Back") "$previous_menu" ; return ;;
        "Exit") exit 0 ;;
        *) sed -i "s/toolkit_mode=.*/toolkit_mode=$selection/" "$config_file" ;;
    esac

    # loop this menu until the user specifically exits or goes back
    select_toolkit_mode
}

second_run_init(){
    rm "$config_file"
    bento -c "Preparing to replay first time init, please wait..."
    first_time_init="enabled"
    sleep 1
    check_for_config
    startup_anim
    first_time_init_startup
    main_menu_startup
}

erase_toolkit_config(){
    previous_menu="toolkit_settings_menu"
    rm "$config_file"
}

edit_config(){
    previous_menu="toolkit_settings_menu"
    "$brunch_editor" "$config_file"
}


edit_grub_config(){
check_for_dualboot
# Look for the new flavor of grub, and adjust these variables as needed
brunch_config="$HOME/tmp/brunch-workspace/efi/boot/settings.cfg"
mount_grub
if [[ ! -e "$brunch_config" ]] ; then
    brunch_config="$HOME/tmp/brunch-workspace/efi/boot/grub.cfg"
fi
    previous_menu="toolkit_settings_menu"
    sudo "$brunch_editor" "$brunch_config"
    unmount_grub
}

install_bento_tk(){
        if [[ "$onlineallowed" == "true" ]] ; then
        mkdir -p ~/tmp/brunch-workspace
        bento -t "Install Bento" -c "Downloading the latest Bento release, please wait..."
    curl -l https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/bento -o ~/tmp/brunch-workspace/bento
    sudo install -Dt /usr/local/bin -m 755 ~/tmp/brunch-workspace/bento
        bento -t "Install Bento" -c "Install complete" "Exit and run the command 'bento' to see how it works!." -e
        else
        bento -t "Install Bento" -c "Unable to install Bento!" "Make sure your internet connection is stable and try again." "You can also install manually by downloading Bento from:" "https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/bento" "then run: bash ~/Downloads/bento --install" -e
            # Install it from here?
        fi
}
#</>

#<~> Announcements

# Use this to display important annoucements about brunch, updates, etc..
check_for_announcements(){
    if [[ "$onlineallowed" == "true" ]] && [[ "$autocheck" == "enabled" ]] ; then
    curl -l https://raw.githubusercontent.com/WesBosch/brunch-toolkit/main/announcement -o /var/brunch/toolkit/annoucement
    source /var/brunch/toolkit/annoucement 2> /dev/null
    if [[ -z "$saved_announcement_ver" ]] ; then
        saved_announcement_ver="0"
    fi

    if (( $announcement_ver > $saved_announcement_ver )) ; then
        sed -i "s/saved_announcement_ver=.*/saved_announcement_ver=$announcement_ver/" "$config_file"
        bento -t "Announcement" -c "${announcement[@]}" -e
    fi
    fi
}

#</>

#<~> Debug functions go here
# Currently working on:

toolkit_debug(){
 function test_unicode {
  echo -ne "\xe2\x88\xb4\033[6n\033[1K\r"
  read -d R foo
  echo -ne "\033[1K\r"
  echo -e "${foo}" | cut -d \[ -f 2 | cut -d";" -f 2 | (
    read UNICODE
    [ $UNICODE -eq 2 ] && return 0
    [ $UNICODE -ne 2 ] && return 1
  )
}

test_unicode
RC=$?
export UNICODE_SUPPORT=`[ $RC -eq 0 ] && echo "Unicode Supported" || echo "Unicode is not supported"`
echo "$UNICODE_SUPPORT"
echo "Examples: ↑ ↓ ⏎ ◆ ◯ ➤"
unset test_unicode
}
#</>

preset_vars
check_for_options "$@"
check_for_root
#check_for_shell
check_for_config
check_for_network
startup_anim
first_time_init_startup
main_menu_startup

}
#</>

preset_vars
check_for_options "$@"
check_for_root
#check_for_shell
check_for_config
check_for_network
startup_anim
first_time_init_startup
main_menu_startup
